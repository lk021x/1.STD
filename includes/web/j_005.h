#ifndef _J_005_H_
#define _J_005_H_

#if Web_RunTime_Debug==1
static const char j_005[]={
"HTTP/1.1 200 OK\r\nContent-Type:text/javascript\r\nAccept-Ranges:bytes\r\n\r\n"
 //Pretty handling of time axes.\n"
 //Copyright (c) 2007-2014 IOLA and Ole Laursen.\n"
 //Licensed under the MIT license.\n"
 //Set axis.mode to \"time\" to enable. See the section \"Time series data\" in\n"
 //API.txt for details.\n"
"(function($) {\n"
 "var options = {\n"
 	"xaxis: {\n"
 		"timezone: null,\n"
 		"timeformat: null,\n"
 		"twelveHourClock: false,\n"
 		"monthNames: null\n"
 	"}\n"
 "};\n"
 	// round to nearby lower multiple of base\n"
 "function floorInBase(n, base) {\n"
 	"return base * Math.floor(n / base);\n"
 "}\n"
 	// Returns a string with the date d formatted according to fmt.\n"
 	// A subset of the Open Group's strftime format is supported.\n"
 "function formatDate(d, fmt, monthNames, dayNames) {\n"
 	"if (typeof d.strftime == \"function\") {\n"
 		"return d.strftime(fmt);\n"
 	"}\n"
 	"var leftPad = function(n, pad) {\n"
 		"n = \"\" + n;\n"
 		"pad = \"\" + (pad == null ? \"0\" : pad);\n"
 		"return n.length == 1 ? pad + n : n;\n"
 	"};\n"
 	"var r = [];\n"
 	"var escape = false;\n"
 	"var hours = d.getHours();\n"
 	"var isAM = hours < 12;\n"
 	"if (monthNames == null) {\n"
 		"monthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n"
 	"}\n"
 	"if (dayNames == null) {\n"
 		"dayNames = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n"
 	"}\n"
 	"var hours12;\n"
 	"if (hours > 12) {\n"
 		"hours12 = hours - 12;\n"
 	"} else if (hours == 0) {\n"
 		"hours12 = 12;\n"
 	"} else {\n"
 		"hours12 = hours;\n"
 	"}\n"
 	"for (var i = 0; i < fmt.length; ++i) {\n"
 		"var c = fmt.charAt(i);\n"
 		"if (escape) {\n"
 			"switch (c) {\n"
 				"case 'a': c = \"\" + dayNames[d.getDay()]; break;\n"
 				"case 'b': c = \"\" + monthNames[d.getMonth()]; break;\n"
 				"case 'd': c = leftPad(d.getDate()); break;\n"
 				"case 'e': c = leftPad(d.getDate(), \" \"); break;\n"
 				"case 'h':\n"
 				"case 'H': c = leftPad(hours); break;\n"
 				"case 'I': c = leftPad(hours12); break;\n"
 				"case 'l': c = leftPad(hours12, \" \"); break;\n"
 				"case 'm': c = leftPad(d.getMonth() + 1); break;\n"
 				"case 'M': c = leftPad(d.getMinutes()); break;\n"
 					// quarters not in Open Group's strftime specification\n"
 				"case 'q':\n"
 					"c = \"\" + (Math.floor(d.getMonth() / 3) + 1); break;\n"
 				"case 'S': c = leftPad(d.getSeconds()); break;\n"
 				"case 'y': c = leftPad(d.getFullYear() % 100); break;\n"
 				"case 'Y': c = \"\" + d.getFullYear(); break;\n"
 				"case 'p': c = (isAM) ? (\"\" + \"am\") : (\"\" + \"pm\"); break;\n"
 				"case 'P': c = (isAM) ? (\"\" + \"AM\") : (\"\" + \"PM\"); break;\n"
 				"case 'w': c = \"\" + d.getDay(); break;\n"
 			"}\n"
 			"r.push(c);\n"
 			"escape = false;\n"
 		"} else {\n"
 			"if (c == \"%\") {\n"
 				"escape = true;\n"
 			"} else {\n"
 				"r.push(c);\n"
 			"}\n"
 		"}\n"
 	"}\n"
 	"return r.join(\"\");\n"
 "}\n"
 	// To have a consistent view of time-based data independent of which time\n"
 	// zone the client happens to be in we need a date-like object independent\n"
 	// of time zones.  This is done through a wrapper that only calls the UTC\n"
 	// versions of the accessor methods.\n"
 "function makeUtcWrapper(d) {\n"
 	"function addProxyMethod(sourceObj, sourceMethod, targetObj, targetMethod) {\n"
 		"sourceObj[sourceMethod] = function() {\n"
 			"return targetObj[targetMethod].apply(targetObj, arguments);\n"
 		"};\n"
 	"};\n"
 	"var utc = {\n"
 		"date: d\n"
 	"};\n"
 		// support strftime, if found\n"
 	"if (d.strftime != undefined) {\n"
 		"addProxyMethod(utc, \"strftime\", d, \"strftime\");\n"
 	"}\n"
 	"addProxyMethod(utc, \"getTime\", d, \"getTime\");\n"
 	"addProxyMethod(utc, \"setTime\", d, \"setTime\");\n"
 	"var props = [\"Date\", \"Day\", \"FullYear\", \"Hours\", \"Milliseconds\", \"Minutes\", \"Month\", \"Seconds\"];\n"
 	"for (var p = 0; p < props.length; p++) {\n"
 		"addProxyMethod(utc, \"get\" + props[p], d, \"getUTC\" + props[p]);\n"
 		"addProxyMethod(utc, \"set\" + props[p], d, \"setUTC\" + props[p]);\n"
 	"}\n"
 	"return utc;\n"
 "};\n"
 	// select time zone strategy.  This returns a date-like object tied to the\n"
 	// desired timezone\n"
 "function dateGenerator(ts, opts) {\n"
 	"if (opts.timezone == \"browser\") {\n"
 		"return new Date(ts);\n"
 	"} else if (!opts.timezone || opts.timezone == \"utc\") {\n"
 		"return makeUtcWrapper(new Date(ts));\n"
 	"} else if (typeof timezoneJS != \"undefined\" && typeof timezoneJS.Date != \"undefined\") {\n"
 		"var d = new timezoneJS.Date();\n"
 			// timezone-js is fickle, so be sure to set the time zone before\n"
 			// setting the time.\n"
 		"d.setTimezone(opts.timezone);\n"
 		"d.setTime(ts);\n"
 		"return d;\n"
 	"} else {\n"
 		"return makeUtcWrapper(new Date(ts));\n"
 	"}\n"
 "}\n"
 	// map of app. size of time units in milliseconds\n"
 "var timeUnitSize = {\n"
 	"\"second\": 1000,\n"
 	"\"minute\": 60 * 1000,\n"
 	"\"hour\": 60 * 60 * 1000,\n"
 	"\"day\": 24 * 60 * 60 * 1000,\n"
 	"\"month\": 30 * 24 * 60 * 60 * 1000,\n"
 	"\"quarter\": 3 * 30 * 24 * 60 * 60 * 1000,\n"
 	"\"year\": 365.2425 * 24 * 60 * 60 * 1000\n"
 "};\n"
 	// the allowed tick sizes, after 1 year we use\n"
 	// an integer algorithm\n"
 "var baseSpec = [\n"
 	"[1, \"second\"], [2, \"second\"], [5, \"second\"], [10, \"second\"],\n"
 	"[30, \"second\"], \n"
 	"[1, \"minute\"], [2, \"minute\"], [5, \"minute\"], [10, \"minute\"],\n"
 	"[30, \"minute\"], \n"
 	"[1, \"hour\"], [2, \"hour\"], [4, \"hour\"],\n"
 	"[8, \"hour\"], [12, \"hour\"],\n"
 	"[1, \"day\"], [2, \"day\"], [3, \"day\"],\n"
 	"[0.25, \"month\"], [0.5, \"month\"], [1, \"month\"],\n"
 	"[2, \"month\"]\n"
 "];\n"
 	// we don't know which variant(s) we'll need yet, but generating both is\n"
 	// cheap\n"
 "var specMonths = baseSpec.concat([[3, \"month\"], [6, \"month\"],\n"
 	"[1, \"year\"]]);\n"
 "var specQuarters = baseSpec.concat([[1, \"quarter\"], [2, \"quarter\"],\n"
 	"[1, \"year\"]]);\n"
 "function init(plot) {\n"
 	"plot.hooks.processOptions.push(function (plot, options) {\n"
 		"$.each(plot.getAxes(), function(axisName, axis) {\n"
 			"var opts = axis.options;\n"
 			"if (opts.mode == \"time\") {\n"
 				"axis.tickGenerator = function(axis) {\n"
 					"var ticks = [];\n"
 					"var d = dateGenerator(axis.min, opts);\n"
 					"var minSize = 0;\n"
 						// make quarter use a possibility if quarters are\n"
 						// mentioned in either of these options\n"
 					"var spec = (opts.tickSize && opts.tickSize[1] ===\n"
 						"\"quarter\") ||\n"
 						"(opts.minTickSize && opts.minTickSize[1] ===\n"
 						"\"quarter\") ? specQuarters : specMonths;\n"
 					"if (opts.minTickSize != null) {\n"
 						"if (typeof opts.tickSize == \"number\") {\n"
 							"minSize = opts.tickSize;\n"
 						"} else {\n"
 							"minSize = opts.minTickSize[0] * timeUnitSize[opts.minTickSize[1]];\n"
 						"}\n"
 					"}\n"
 					"for (var i = 0; i < spec.length - 1; ++i) {\n"
 						"if (axis.delta < (spec[i][0] * timeUnitSize[spec[i][1]]\n"
 											 "+ spec[i + 1][0] * timeUnitSize[spec[i + 1][1]]) / 2\n"
 							"&& spec[i][0] * timeUnitSize[spec[i][1]] >= minSize) {\n"
 							"break;\n"
 						"}\n"
 					"}\n"
 					"var size = spec[i][0];\n"
 					"var unit = spec[i][1];\n"
 						// special-case the possibility of several years\n"
 					"if (unit == \"year\") {\n"
 							// if given a minTickSize in years, just use it,\n"
 							// ensuring that it's an integer\n"
 						"if (opts.minTickSize != null && opts.minTickSize[1] == \"year\") {\n"
 							"size = Math.floor(opts.minTickSize[0]);\n"
 						"} else {\n"
 							"var magn = Math.pow(10, Math.floor(Math.log(axis.delta / timeUnitSize.year) / Math.LN10));\n"
 							"var norm = (axis.delta / timeUnitSize.year) / magn;\n"
 							"if (norm < 1.5) {\n"
 								"size = 1;\n"
 							"} else if (norm < 3) {\n"
 								"size = 2;\n"
 							"} else if (norm < 7.5) {\n"
 								"size = 5;\n"
 							"} else {\n"
 								"size = 10;\n"
 							"}\n"
 							"size *= magn;\n"
 						"}\n"
 							// minimum size for years is 1\n"
 						"if (size < 1) {\n"
 							"size = 1;\n"
 						"}\n"
 					"}\n"
 					"axis.tickSize = opts.tickSize || [size, unit];\n"
 					"var tickSize = axis.tickSize[0];\n"
 					"unit = axis.tickSize[1];\n"
 					"var step = tickSize * timeUnitSize[unit];\n"
 					"if (unit == \"second\") {\n"
 						"d.setSeconds(floorInBase(d.getSeconds(), tickSize));\n"
 					"} else if (unit == \"minute\") {\n"
 						"d.setMinutes(floorInBase(d.getMinutes(), tickSize));\n"
 					"} else if (unit == \"hour\") {\n"
 						"d.setHours(floorInBase(d.getHours(), tickSize));\n"
 					"} else if (unit == \"month\") {\n"
 						"d.setMonth(floorInBase(d.getMonth(), tickSize));\n"
 					"} else if (unit == \"quarter\") {\n"
 						"d.setMonth(3 * floorInBase(d.getMonth() / 3,\n"
 							"tickSize));\n"
 					"} else if (unit == \"year\") {\n"
 						"d.setFullYear(floorInBase(d.getFullYear(), tickSize));\n"
 					"}\n"
 						// reset smaller components\n"
 					"d.setMilliseconds(0);\n"
 					"if (step >= timeUnitSize.minute) {\n"
 						"d.setSeconds(0);\n"
 					"}\n"
 					"if (step >= timeUnitSize.hour) {\n"
 						"d.setMinutes(0);\n"
 					"}\n"
 					"if (step >= timeUnitSize.day) {\n"
 						"d.setHours(0);\n"
 					"}\n"
 					"if (step >= timeUnitSize.day * 4) {\n"
 						"d.setDate(1);\n"
 					"}\n"
 					"if (step >= timeUnitSize.month * 2) {\n"
 						"d.setMonth(floorInBase(d.getMonth(), 3));\n"
 					"}\n"
 					"if (step >= timeUnitSize.quarter * 2) {\n"
 						"d.setMonth(floorInBase(d.getMonth(), 6));\n"
 					"}\n"
 					"if (step >= timeUnitSize.year) {\n"
 						"d.setMonth(0);\n"
 					"}\n"
 					"var carry = 0;\n"
 					"var v = Number.NaN;\n"
 					"var prev;\n"
 					"do {\n"
 						"prev = v;\n"
 						"v = d.getTime();\n"
 						"ticks.push(v);\n"
 						"if (unit == \"month\" || unit == \"quarter\") {\n"
 							"if (tickSize < 1) {\n"
 									// a bit complicated - we'll divide the\n"
 									// month/quarter up but we need to take\n"
 									// care of fractions so we don't end up in\n"
 									// the middle of a day\n"
 								"d.setDate(1);\n"
 								"var start = d.getTime();\n"
 								"d.setMonth(d.getMonth() +\n"
 									"(unit == \"quarter\" ? 3 : 1));\n"
 								"var end = d.getTime();\n"
 								"d.setTime(v + carry * timeUnitSize.hour + (end - start) * tickSize);\n"
 								"carry = d.getHours();\n"
 								"d.setHours(0);\n"
 							"} else {\n"
 								"d.setMonth(d.getMonth() +\n"
 									"tickSize * (unit == \"quarter\" ? 3 : 1));\n"
 							"}\n"
 						"} else if (unit == \"year\") {\n"
 							"d.setFullYear(d.getFullYear() + tickSize);\n"
 						"} else {\n"
 							"d.setTime(v + step);\n"
 						"}\n"
 					"} while (v < axis.max && v != prev);\n"
 					"return ticks;\n"
 				"};\n"
 				"axis.tickFormatter = function (v, axis) {\n"
 					"var d = dateGenerator(v, axis.options);\n"
 						// first check global format\n"
 					"if (opts.timeformat != null) {\n"
 						"return formatDate(d, opts.timeformat, opts.monthNames, opts.dayNames);\n"
 					"}\n"
 						// possibly use quarters if quarters are mentioned in\n"
 						// any of these places\n"
 					"var useQuarters = (axis.options.tickSize &&\n"
 							"axis.options.tickSize[1] == \"quarter\") ||\n"
 						"(axis.options.minTickSize &&\n"
 							"axis.options.minTickSize[1] == \"quarter\");\n"
 					"var t = axis.tickSize[0] * timeUnitSize[axis.tickSize[1]];\n"
 					"var span = axis.max - axis.min;\n"
 					"var suffix = (opts.twelveHourClock) ? \" %p\" : \"\";\n"
 					"var hourCode = (opts.twelveHourClock) ? \"%I\" : \"%H\";\n"
 					"var fmt;\n"
 					"if (t < timeUnitSize.minute) {\n"
 						"fmt = hourCode + \":%M:%S\" + suffix;\n"
 					"} else if (t < timeUnitSize.day) {\n"
 						"if (span < 2 * timeUnitSize.day) {\n"
 							"fmt = hourCode + \":%M\" + suffix;\n"
 						"} else {\n"
 							"fmt = \"%b %d \" + hourCode + \":%M\" + suffix;\n"
 						"}\n"
 					"} else if (t < timeUnitSize.month) {\n"
 						"fmt = \"%b %d\";\n"
 					"} else if ((useQuarters && t < timeUnitSize.quarter) ||\n"
 						"(!useQuarters && t < timeUnitSize.year)) {\n"
 						"if (span < timeUnitSize.year) {\n"
 							"fmt = \"%b\";\n"
 						"} else {\n"
 							"fmt = \"%b %Y\";\n"
 						"}\n"
 					"} else if (useQuarters && t < timeUnitSize.year) {\n"
 						"if (span < timeUnitSize.year) {\n"
 							"fmt = \"Q%q\";\n"
 						"} else {\n"
 							"fmt = \"Q%q %Y\";\n"
 						"}\n"
 					"} else {\n"
 						"fmt = \"%Y\";\n"
 					"}\n"
 					"var rt = formatDate(d, fmt, opts.monthNames, opts.dayNames);\n"
 					"return rt;\n"
 				"};\n"
 			"}\n"
 		"});\n"
 	"});\n"
 "}\n"
 "$.plot.plugins.push({\n"
 	"init: init,\n"
 	"options: options,\n"
 	"name: 'time',\n"
 	"version: '1.0'\n"
 "});\n"
 	// Time-axis support used to be in Flot core, which exposed the\n"
 	// formatDate function on the plot object.  Various plugins depend\n"
 	// on the function, so we need to re-expose it here.\n"
 "$.plot.formatDate = formatDate;\n"
 "$.plot.dateGenerator = dateGenerator;\n"
"})(jQuery);\n"
};
#else
static const char j_005[]={0};
#endif
#endif
