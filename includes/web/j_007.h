#ifndef _J_007_H_
#define _J_007_H_

static const char j_007[]={
"HTTP/1.1 200 OK\r\nContent-Type:text/javascript\r\nAccept-Ranges:bytes\r\n\r\n"
 // Highcharts JS v5.0.10 (2017-03-31)\n"
 //(c) 2009-2016 Torstein Honsi\n"
 // License: www.highcharts.com/license\n"
"(function(L, a) {\n"
    "\"object\" === typeof module && module.exports ? module.exports = L.document ? a(L) : a: L.Highcharts = a(L)\n"
"})(\"undefined\" !== typeof window ? window: this,\n"
"function(L) {\n"
    "L = function() {\n"
        "var a = window,\n"
        "B = a.document,\n"
        "A = a.navigator && a.navigator.userAgent || \"\",\n"
        "H = B && B.createElementNS && !!B.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n"
        "G = /(edge|msie|trident)/i.test(A) && !window.opera,\n"
        "r = !H,\n"
        "f = /Firefox/.test(A),\n"
        "l = f && 4 > parseInt(A.split(\"Firefox/\")[1], 10);\n"
        "return a.Highcharts ? a.Highcharts.error(16, !0) : {\n"
            "product: \"Highcharts\",\n"
            "version: \"5.0.10\",\n"
            "deg2rad: 2 * Math.PI / 360,\n"
            "doc: B,\n"
            "hasBidiBug: l,\n"
            "hasTouch: B && void 0 !== B.documentElement.ontouchstart,\n"
            "isMS: G,\n"
            "isWebKit: /AppleWebKit/.test(A),\n"
            "isFirefox: f,\n"
            "isTouchDevice: /(Mobile|Android|Windows Phone)/.test(A),\n"
            "SVG_NS: \"http://www.w3.org/2000/svg\",\n"
            "chartCount: 0,\n"
            "seriesTypes: {},\n"
            "symbolSizes: {},\n"
            "svg: H,\n"
            "vml: r,\n"
            "win: a,\n"
            "charts: [],\n"
            "marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n"
            "noop: function() {}\n"
        "}\n"
    "} (); (function(a) {\n"
        "var B = [],\n"
        "A = a.charts,\n"
        "H = a.doc,\n"
        "G = a.win;\n"
        "a.error = function(r, f) {\n"
            "r = a.isNumber(r) ? \"Highcharts error #\" + r + \": www.highcharts.com/errors/\" + r: r;\n"
            "if (f) throw Error(r);\n"
            "G.console && console.log(r)\n"
        "};\n"
        "a.Fx = function(a, f, l) {\n"
            "this.options = f;\n"
            "this.elem = a;\n"
            "this.prop = l\n"
        "};\n"
        "a.Fx.prototype = {\n"
            "dSetter: function() {\n"
                "var a = this.paths[0],\n"
                "f = this.paths[1],\n"
                "l = [],\n"
                "q = this.now,\n"
                "k = a.length,\n"
                "u;\n"
                "if (1 === q) l = this.toD;\n"
                "else if (k === f.length && 1 > q) for (; k--;) u = parseFloat(a[k]),\n"
                "l[k] = isNaN(u) ? a[k] : q * parseFloat(f[k] - u) + u;\n"
                "else l = f;\n"
                "this.elem.attr(\"d\", l, null, !0)\n"
            "},\n"
            "update: function() {\n"
                "var a = this.elem,\n"
                "f = this.prop,\n"
                "l = this.now,\n"
                "q = this.options.step;\n"
                "if (this[f + \"Setter\"]) this[f + \"Setter\"]();\n"
                "else a.attr ? a.element && a.attr(f, l, null, !0) : a.style[f] = l + this.unit;\n"
                "q && q.call(a, l, this)\n"
            "},\n"
            "run: function(a, f, l) {\n"
                "var r = this,\n"
                "k = function(a) {\n"
                    "return k.stopped ? !1 : r.step(a)\n"
                "},\n"
                "u;\n"
                "this.startTime = +new Date;\n"
                "this.start = a;\n"
                "this.end = f;\n"
                "this.unit = l;\n"
                "this.now = this.start;\n"
                "this.pos = 0;\n"
                "k.elem = this.elem;\n"
                "k.prop = this.prop;\n"
                "k() && 1 === B.push(k) && (k.timerId = setInterval(function() {\n"
                    "for (u = 0; u < B.length; u++) B[u]() || B.splice(u--, 1);\n"
                    "B.length || clearInterval(k.timerId)\n"
                "},\n"
                "13))\n"
            "},\n"
            "step: function(a) {\n"
                "var f = +new Date,\n"
                "r, q = this.options;\n"
                "r = this.elem;\n"
                "var k = q.complete,\n"
                "u = q.duration,\n"
                "d = q.curAnim,\n"
                "c;\n"
                "if (r.attr && !r.element) r = !1;\n"
                "else if (a || f >= u + this.startTime) {\n"
                    "this.now = this.end;\n"
                    "this.pos = 1;\n"
                    "this.update();\n"
                    "a = d[this.prop] = !0;\n"
                    "for (c in d) ! 0 !== d[c] && (a = !1);\n"
                    "a && k && k.call(r);\n"
                    "r = !1\n"
                "} else this.pos = q.easing((f - this.startTime) / u),\n"
                "this.now = this.start + (this.end - this.start) * this.pos,\n"
                "this.update(),\n"
                "r = !0;\n"
                "return r\n"
            "},\n"
            "initPath: function(r, f, l) {\n"
                "function q(a) {\n"
                    "var b, e;\n"
                    "for (t = a.length; t--;) b = \"M\" === a[t] || \"L\" === a[t],\n"
                    "e = /[a-zA-Z]/.test(a[t + 3]),\n"
                    "b && e && a.splice(t + 1, 0, a[t + 1], a[t + 2], a[t + 1], a[t + 2])\n"
                "}\n"
                "function k(a, e) {\n"
                    "for (; a.length < p;) {\n"
                        "a[0] = e[p - a.length];\n"
                        "var h = a.slice(0, b); [].splice.apply(a, [0, 0].concat(h));\n"
                        "D && (h = a.slice(a.length - b), [].splice.apply(a, [a.length, 0].concat(h)), t--)\n"
                    "}\n"
                    "a[0] = \"M\"\n"
                "}\n"
                "function u(a, e) {\n"
                    "for (var c = (p - a.length) / b; 0 < c && c--;) h = a.slice().splice(a.length / w - b, b * w),\n"
                    "h[0] = e[p - b - c * b],\n"
                    "z && (h[b - 6] = h[b - 2], h[b - 5] = h[b - 1]),\n"
                    "[].splice.apply(a, [a.length / w, 0].concat(h)),\n"
                    "D && c--\n"
                "}\n"
                "f = f || \"\";\n"
                "var d, c = r.startX,\n"
                "n = r.endX,\n"
                "z = -1 < f.indexOf(\"C\"),\n"
                "b = z ? 7 : 3,\n"
                "p,\n"
                "h,\n"
                "t;\n"
                "f = f.split(\" \");\n"
                "l = l.slice();\n"
                "var D = r.isArea,\n"
                "w = D ? 2 : 1,\n"
                "e;\n"
                "z && (q(f), q(l));\n"
                "if (c && n) {\n"
                    "for (t = 0; t < c.length; t++) if (c[t] === n[0]) {\n"
                        "d = t;\n"
                        "break\n"
                    "} else if (c[0] === n[n.length - c.length + t]) {\n"
                        "d = t;\n"
                        "e = !0;\n"
                        "break\n"
                    "}\n"
                    "void 0 === d && (f = [])\n"
                "}\n"
                "f.length && a.isNumber(d) && (p = l.length + d * w * b, e ? (k(f, l), u(l, f)) : (k(l, f), u(f, l)));\n"
                "return [f, l]\n"
            "}\n"
        "};\n"
        "a.extend = function(a, f) {\n"
            "var r;\n"
            "a || (a = {});\n"
            "for (r in f) a[r] = f[r];\n"
            "return a\n"
        "};\n"
        "a.merge = function() {\n"
            "var r, f = arguments,\n"
            "l, q = {},\n"
            "k = function(u, d) {\n"
                "var c, n;\n"
                "\"object\" !== typeof u && (u = {});\n"
                "for (n in d) d.hasOwnProperty(n) && (c = d[n], a.isObject(c, !0) && \"renderTo\" !== n && \"number\" !== typeof c.nodeType ? u[n] = k(u[n] || {},\n"
                "c) : u[n] = d[n]);\n"
                "return u\n"
            "}; ! 0 === f[0] && (q = f[1], f = Array.prototype.slice.call(f, 2));\n"
            "l = f.length;\n"
            "for (r = 0; r < l; r++) q = k(q, f[r]);\n"
            "return q\n"
        "};\n"
        "a.pInt = function(a, f) {\n"
            "return parseInt(a, f || 10)\n"
        "};\n"
        "a.isString = function(a) {\n"
            "return \"string\" === typeof a\n"
        "};\n"
        "a.isArray = function(a) {\n"
            "a = Object.prototype.toString.call(a);\n"
            "return \"[object Array]\" === a || \"[object Array Iterator]\" === a\n"
        "};\n"
        "a.isObject = function(r, f) {\n"
            "return r && \"object\" === typeof r && (!f || !a.isArray(r))\n"
        "};\n"
        "a.isNumber = function(a) {\n"
            "return \"number\" === typeof a && !isNaN(a)\n"
        "};\n"
        "a.erase = function(a, f) {\n"
            "for (var r = a.length; r--;) if (a[r] === f) {\n"
                "a.splice(r, 1);\n"
                "break\n"
            "}\n"
        "};\n"
        "a.defined = function(a) {\n"
            "return void 0 !== a && null !== a\n"
        "};\n"
        "a.attr = function(r, f, l) {\n"
            "var q, k;\n"
            "if (a.isString(f)) a.defined(l) ? r.setAttribute(f, l) : r && r.getAttribute && (k = r.getAttribute(f));\n"
            "else if (a.defined(f) && a.isObject(f)) for (q in f) r.setAttribute(q, f[q]);\n"
            "return k\n"
        "};\n"
        "a.splat = function(r) {\n"
            "return a.isArray(r) ? r: [r]\n"
        "};\n"
        "a.syncTimeout = function(a, f, l) {\n"
            "if (f) return setTimeout(a, f, l);\n"
            "a.call(0, l)\n"
        "};\n"
        "a.pick = function() {\n"
            "var a = arguments,\n"
            "f, l, q = a.length;\n"
            "for (f = 0; f < q; f++) if (l = a[f], void 0 !== l && null !== l) return l\n"
        "};\n"
        "a.css = function(r, f) {\n"
            "a.isMS && !a.svg && f && void 0 !== f.opacity && (f.filter = \"alpha(opacity\\x3d\" + 100 * f.opacity + \")\");\n"
            "a.extend(r.style, f)\n"
        "};\n"
        "a.createElement = function(r, f, l, q, k) {\n"
            "r = H.createElement(r);\n"
            "var u = a.css;\n"
            "f && a.extend(r, f);\n"
            "k && u(r, {\n"
                "padding: 0,\n"
                "border: \"none\",\n"
                "margin: 0\n"
            "});\n"
            "l && u(r, l);\n"
            "q && q.appendChild(r);\n"
            "return r\n"
        "};\n"
        "a.extendClass = function(r, f) {\n"
            "var l = function() {};\n"
            "l.prototype = new r;\n"
            "a.extend(l.prototype, f);\n"
            "return l\n"
        "};\n"
        "a.pad = function(a, f, l) {\n"
            "return Array((f || 2) + 1 - String(a).length).join(l || 0) + a\n"
        "};\n"
        "a.relativeLength = function(a, f) {\n"
            "return /%$/.test(a) ? f * parseFloat(a) / 100 : parseFloat(a)\n"
        "};\n"
        "a.wrap = function(a, f, l) {\n"
            "var q = a[f];\n"
            "a[f] = function() {\n"
                "var a = Array.prototype.slice.call(arguments),\n"
                "u = arguments,\n"
                "d = this;\n"
                "d.proceed = function() {\n"
                    "q.apply(d, arguments.length ? arguments: u)\n"
                "};\n"
                "a.unshift(q);\n"
                "a = l.apply(this, a);\n"
                "d.proceed = null;\n"
                "return a\n"
            "}\n"
        "};\n"
        "a.getTZOffset = function(r) {\n"
            "var f = a.Date;\n"
            "return 6E4 * (f.hcGetTimezoneOffset && f.hcGetTimezoneOffset(r) || f.hcTimezoneOffset || 0)\n"
        "};\n"
        "a.dateFormat = function(r, f, l) {\n"
            "if (!a.defined(f) || isNaN(f)) return a.defaultOptions.lang.invalidDate || \"\";\n"
            "r = a.pick(r, \"%Y-%m-%d %H:%M:%S\");\n"
            "var q = a.Date,\n"
            "k = new q(f - a.getTZOffset(f)),\n"
            "u,\n"
            "d = k[q.hcGetHours](),\n"
            "c = k[q.hcGetDay](),\n"
            "n = k[q.hcGetDate](),\n"
            "z = k[q.hcGetMonth](),\n"
            "b = k[q.hcGetFullYear](),\n"
            "p = a.defaultOptions.lang,\n"
            "h = p.weekdays,\n"
            "t = p.shortWeekdays,\n"
            "D = a.pad,\n"
            "q = a.extend({\n"
                "a: t ? t[c] : h[c].substr(0, 3),\n"
                "A: h[c],\n"
                "d: D(n),\n"
                "e: D(n, 2, \" \"),\n"
                "w: c,\n"
                "b: p.shortMonths[z],\n"
                "B: p.months[z],\n"
                "m: D(z + 1),\n"
                "y: b.toString().substr(2, 2),\n"
                "Y: b,\n"
                "H: D(d),\n"
                "k: d,\n"
                "I: D(d % 12 || 12),\n"
                "l: d % 12 || 12,\n"
                "M: D(k[q.hcGetMinutes]()),\n"
                "p: 12 > d ? \"AM\": \"PM\",\n"
                "P: 12 > d ? \"am\": \"pm\",\n"
                "S: D(k.getSeconds()),\n"
                "L: D(Math.round(f % 1E3), 3)\n"
            "},\n"
            "a.dateFormats);\n"
            "for (u in q) for (; - 1 !== r.indexOf(\"%\" + u);) r = r.replace(\"%\" + u, \"function\" === typeof q[u] ? q[u](f) : q[u]);\n"
            "return l ? r.substr(0, 1).toUpperCase() + r.substr(1) : r\n"
        "};\n"
        "a.formatSingle = function(r, f) {\n"
            "var l = /\\.([0-9])/,\n"
            "q = a.defaultOptions.lang;\n"
            "/f$/.test(r) ? (l = (l = r.match(l)) ? l[1] : -1, null !== f && (f = a.numberFormat(f, l, q.decimalPoint, -1 < r.indexOf(\",\") ? q.thousandsSep: \"\"))) : f = a.dateFormat(r, f);\n"
            "return f\n"
        "};\n"
        "a.format = function(r, f) {\n"
            "for (var l = \"{\",\n"
            "q = !1,\n"
            "k, u, d, c, n = [], z; r;) {\n"
                "l = r.indexOf(l);\n"
                "if ( - 1 === l) break;\n"
                "k = r.slice(0, l);\n"
                "if (q) {\n"
                    "k = k.split(\":\");\n"
                    "u = k.shift().split(\".\");\n"
                    "c = u.length;\n"
                    "z = f;\n"
                    "for (d = 0; d < c; d++) z = z[u[d]];\n"
                    "k.length && (z = a.formatSingle(k.join(\":\"), z));\n"
                    "n.push(z)\n"
                "} else n.push(k);\n"
                "r = r.slice(l + 1);\n"
                "l = (q = !q) ? \"}\": \"{\"\n"
            "}\n"
            "n.push(r);\n"
            "return n.join(\"\")\n"
        "};\n"
        "a.getMagnitude = function(a) {\n"
            "return Math.pow(10, Math.floor(Math.log(a) / Math.LN10))\n"
        "};\n"
        "a.normalizeTickInterval = function(r, f, l, q, k) {\n"
            "var u, d = r;\n"
            "l = a.pick(l, 1);\n"
            "u = r / l;\n"
            "f || (f = k ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === q && (1 === l ? f = a.grep(f,\n"
            "function(a) {\n"
                "return 0 === a % 1\n"
            "}) : .1 >= l && (f = [1 / l])));\n"
            "for (q = 0; q < f.length && !(d = f[q], k && d * l >= r || !k && u <= (f[q] + (f[q + 1] || f[q])) / 2); q++);\n"
            "return d = a.correctFloat(d * l, -Math.round(Math.log(.001) / Math.LN10))\n"
        "};\n"
        "a.stableSort = function(a, f) {\n"
            "var l = a.length,\n"
            "q, k;\n"
            "for (k = 0; k < l; k++) a[k].safeI = k;\n"
            "a.sort(function(a, d) {\n"
                "q = f(a, d);\n"
                "return 0 === q ? a.safeI - d.safeI: q\n"
            "});\n"
            "for (k = 0; k < l; k++) delete a[k].safeI\n"
        "};\n"
        "a.arrayMin = function(a) {\n"
            "for (var f = a.length,\n"
            "l = a[0]; f--;) a[f] < l && (l = a[f]);\n"
            "return l\n"
        "};\n"
        "a.arrayMax = function(a) {\n"
            "for (var f = a.length,\n"
            "l = a[0]; f--;) a[f] > l && (l = a[f]);\n"
            "return l\n"
        "};\n"
        "a.destroyObjectProperties = function(a, f) {\n"
            "for (var l in a) a[l] && a[l] !== f && a[l].destroy && a[l].destroy(),\n"
            "delete a[l]\n"
        "};\n"
        "a.discardElement = function(r) {\n"
            "var f = a.garbageBin;\n"
            "f || (f = a.createElement(\"div\"));\n"
            "r && f.appendChild(r);\n"
            "f.innerHTML = \"\"\n"
        "};\n"
        "a.correctFloat = function(a, f) {\n"
            "return parseFloat(a.toPrecision(f || 14))\n"
        "};\n"
        "a.setAnimation = function(r, f) {\n"
            "f.renderer.globalAnimation = a.pick(r, f.options.chart.animation, !0)\n"
        "};\n"
        "a.animObject = function(r) {\n"
            "return a.isObject(r) ? a.merge(r) : {\n"
                "duration: r ? 500 : 0\n"
            "}\n"
        "};\n"
        "a.timeUnits = {\n"
            "millisecond: 1,\n"
            "second: 1E3,\n"
            "minute: 6E4,\n"
            "hour: 36E5,\n"
            "day: 864E5,\n"
            "week: 6048E5,\n"
            "month: 24192E5,\n"
            "year: 314496E5\n"
        "};\n"
        "a.numberFormat = function(r, f, l, q) {\n"
            "r = +r || 0;\n"
            "f = +f;\n"
            "var k = a.defaultOptions.lang,\n"
            "u = (r.toString().split(\".\")[1] || \"\").length,\n"
            "d,\n"
            "c; - 1 === f ? f = Math.min(u, 20) : a.isNumber(f) || (f = 2);\n"
            "c = (Math.abs(r) + Math.pow(10, -Math.max(f, u) - 1)).toFixed(f);\n"
            "u = String(a.pInt(c));\n"
            "d = 3 < u.length ? u.length % 3 : 0;\n"
            "l = a.pick(l, k.decimalPoint);\n"
            "q = a.pick(q, k.thousandsSep);\n"
            "r = (0 > r ? \"-\": \"\") + (d ? u.substr(0, d) + q: \"\");\n"
            "r += u.substr(d).replace(/(\\d{3})(?=\\d)/g, \"$1\" + q);\n"
            "f && (r += l + c.slice( - f));\n"
            "return r\n"
        "};\n"
        "Math.easeInOutSine = function(a) {\n"
            "return - .5 * (Math.cos(Math.PI * a) - 1)\n"
        "};\n"
        "a.getStyle = function(r, f) {\n"
            "return \"width\" === f ? Math.min(r.offsetWidth, r.scrollWidth) - a.getStyle(r, \"padding-left\") - a.getStyle(r, \"padding-right\") : \"height\" === f ? Math.min(r.offsetHeight, r.scrollHeight) - a.getStyle(r, \"padding-top\") - a.getStyle(r, \"padding-bottom\") : (r = G.getComputedStyle(r, void 0)) && a.pInt(r.getPropertyValue(f))\n"
        "};\n"
        "a.inArray = function(a, f) {\n"
            "return f.indexOf ? f.indexOf(a) : [].indexOf.call(f, a)\n"
        "};\n"
        "a.grep = function(a, f) {\n"
            "return [].filter.call(a, f)\n"
        "};\n"
        "a.find = function(a, f) {\n"
            "return [].find.call(a, f)\n"
        "};\n"
        "a.map = function(a, f) {\n"
            "for (var l = [], q = 0, k = a.length; q < k; q++) l[q] = f.call(a[q], a[q], q, a);\n"
            "return l\n"
        "};\n"
        "a.offset = function(a) {\n"
            "var f = H.documentElement;\n"
            "a = a.getBoundingClientRect();\n"
            "return {\n"
                "top: a.top + (G.pageYOffset || f.scrollTop) - (f.clientTop || 0),\n"
                "left: a.left + (G.pageXOffset || f.scrollLeft) - (f.clientLeft || 0)\n"
            "}\n"
        "};\n"
        "a.stop = function(a, f) {\n"
            "for (var l = B.length; l--;) B[l].elem !== a || f && f !== B[l].prop || (B[l].stopped = !0)\n"
        "};\n"
        "a.each = function(a, f, l) {\n"
            "return Array.prototype.forEach.call(a, f, l)\n"
        "};\n"
        "a.addEvent = function(r, f, l) {\n"
            "function q(a) {\n"
                "a.target = a.srcElement || G;\n"
                "l.call(r, a)\n"
            "}\n"
            "var k = r.hcEvents = r.hcEvents || {};\n"
            "r.addEventListener ? r.addEventListener(f, l, !1) : r.attachEvent && (r.hcEventsIE || (r.hcEventsIE = {}), r.hcEventsIE[l.toString()] = q, r.attachEvent(\"on\" + f, q));\n"
            "k[f] || (k[f] = []);\n"
            "k[f].push(l);\n"
            "return function() {\n"
                "a.removeEvent(r, f, l)\n"
            "}\n"
        "};\n"
        "a.removeEvent = function(r, f, l) {\n"
            "function q(a, c) {\n"
                "r.removeEventListener ? r.removeEventListener(a, c, !1) : r.attachEvent && (c = r.hcEventsIE[c.toString()], r.detachEvent(\"on\" + a, c))\n"
            "}\n"
            "function k() {\n"
                "var a, c;\n"
                "if (r.nodeName) for (c in f ? (a = {},\n"
                "a[f] = !0) : a = d, a) if (d[c]) for (a = d[c].length; a--;) q(c, d[c][a])\n"
            "}\n"
            "var u, d = r.hcEvents,\n"
            "c;\n"
            "d && (f ? (u = d[f] || [], l ? (c = a.inArray(l, u), -1 < c && (u.splice(c, 1), d[f] = u), q(f, l)) : (k(), d[f] = [])) : (k(), r.hcEvents = {}))\n"
        "};\n"
        "a.fireEvent = function(r, f, l, q) {\n"
            "var k;\n"
            "k = r.hcEvents;\n"
            "var u, d;\n"
            "l = l || {};\n"
            "if (H.createEvent && (r.dispatchEvent || r.fireEvent)) k = H.createEvent(\"Events\"),\n"
            "k.initEvent(f, !0, !0),\n"
            "a.extend(k, l),\n"
            "r.dispatchEvent ? r.dispatchEvent(k) : r.fireEvent(f, k);\n"
            "else if (k) for (k = k[f] || [], u = k.length, l.target || a.extend(l, {\n"
                "preventDefault: function() {\n"
                    "l.defaultPrevented = !0\n"
                "},\n"
                "target: r,\n"
                "type: f\n"
            "}), f = 0; f < u; f++)(d = k[f]) && !1 === d.call(r, l) && l.preventDefault();\n"
            "q && !l.defaultPrevented && q(l)\n"
        "};\n"
        "a.animate = function(r, f, l) {\n"
            "var q, k = \"\",\n"
            "u, d, c;\n"
            "a.isObject(l) || (q = arguments, l = {\n"
                "duration: q[2],\n"
                "easing: q[3],\n"
                "complete: q[4]\n"
            "});\n"
            "a.isNumber(l.duration) || (l.duration = 400);\n"
            "l.easing = \"function\" === typeof l.easing ? l.easing: Math[l.easing] || Math.easeInOutSine;\n"
            "l.curAnim = a.merge(f);\n"
            "for (c in f) a.stop(r, c),\n"
            "d = new a.Fx(r, l, c),\n"
            "u = null,\n"
            "\"d\" === c ? (d.paths = d.initPath(r, r.d, f.d), d.toD = f.d, q = 0, u = 1) : r.attr ? q = r.attr(c) : (q = parseFloat(a.getStyle(r, c)) || 0, \"opacity\" !== c && (k = \"px\")),\n"
            "u || (u = f[c]),\n"
            "u && u.match && u.match(\"px\") && (u = u.replace(/px/g, \"\")),\n"
            "d.run(q, u, k)\n"
        "};\n"
        "a.seriesType = function(r, f, l, q, k) {\n"
            "var u = a.getOptions(),\n"
            "d = a.seriesTypes;\n"
            "u.plotOptions[r] = a.merge(u.plotOptions[f], l);\n"
            "d[r] = a.extendClass(d[f] ||\n"
            "function() {},\n"
            "q);\n"
            "d[r].prototype.type = r;\n"
            "k && (d[r].prototype.pointClass = a.extendClass(a.Point, k));\n"
            "return d[r]\n"
        "};\n"
        "a.uniqueKey = function() {\n"
            "var a = Math.random().toString(36).substring(2, 9),\n"
            "f = 0;\n"
            "return function() {\n"
                "return \"highcharts-\" + a + \"-\" + f++\n"
            "}\n"
        "} ();\n"
        "G.jQuery && (G.jQuery.fn.highcharts = function() {\n"
            "var r = [].slice.call(arguments);\n"
            "if (this[0]) return r[0] ? (new(a[a.isString(r[0]) ? r.shift() : \"Chart\"])(this[0], r[0], r[1]), this) : A[a.attr(this[0], \"data-highcharts-chart\")]\n"
        "});\n"
        "H && !H.defaultView && (a.getStyle = function(r, f) {\n"
            "var l = {\n"
                "width: \"clientWidth\",\n"
                "height: \"clientHeight\"\n"
            "} [f];\n"
            "if (r.style[f]) return a.pInt(r.style[f]);\n"
            "\"opacity\" === f && (f = \"filter\");\n"
            "if (l) return r.style.zoom = 1,\n"
            "Math.max(r[l] - 2 * a.getStyle(r, \"padding\"), 0);\n"
            "r = r.currentStyle[f.replace(/\\-(\\w)/g,\n"
            "function(a, k) {\n"
                "return k.toUpperCase()\n"
            "})];\n"
            "\"filter\" === f && (r = r.replace(/alpha\\(opacity=([0-9]+)\\)/,\n"
            "function(a, k) {\n"
                "return k / 100\n"
            "}));\n"
            "return \"\" === r ? 1 : a.pInt(r)\n"
        "});\n"
        "Array.prototype.forEach || (a.each = function(a, f, l) {\n"
            "for (var q = 0,\n"
            "k = a.length; q < k; q++) if (!1 === f.call(l, a[q], q, a)) return q\n"
        "});\n"
        "Array.prototype.indexOf || (a.inArray = function(a, f) {\n"
            "var l, q = 0;\n"
            "if (f) for (l = f.length; q < l; q++) if (f[q] === a) return q;\n"
            "return - 1\n"
        "});\n"
        "Array.prototype.filter || (a.grep = function(a, f) {\n"
            "for (var l = [], q = 0, k = a.length; q < k; q++) f(a[q], q) && l.push(a[q]);\n"
            "return l\n"
        "});\n"
        "Array.prototype.find || (a.find = function(a, f) {\n"
            "var l, q = a.length;\n"
            "for (l = 0; l < q; l++) if (f(a[l], l)) return a[l]\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.each,\n"
        "A = a.isNumber,\n"
        "H = a.map,\n"
        "G = a.merge,\n"
        "r = a.pInt;\n"
        "a.Color = function(f) {\n"
            "if (! (this instanceof a.Color)) return new a.Color(f);\n"
            "this.init(f)\n"
        "};\n"
        "a.Color.prototype = {\n"
            "parsers: [{\n"
                "regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n"
                "parse: function(a) {\n"
                    "return [r(a[1]), r(a[2]), r(a[3]), parseFloat(a[4], 10)]\n"
                "}\n"
            "},\n"
            "{\n"
                "regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n"
                "parse: function(a) {\n"
                    "return [r(a[1]), r(a[2]), r(a[3]), 1]\n"
                "}\n"
            "}],\n"
            "names: {\n"
                "white: \"#ffffff\",\n"
                "black: \"#000000\"\n"
            "},\n"
            "init: function(f) {\n"
                "var l, q, k, u;\n"
                "if ((this.input = f = this.names[f && f.toLowerCase ? f.toLowerCase() : \"\"] || f) && f.stops) this.stops = H(f.stops,\n"
                "function(d) {\n"
                    "return new a.Color(d[1])\n"
                "});\n"
                "else if (f && \"#\" === f[0] && (l = f.length, f = parseInt(f.substr(1), 16), 7 === l ? q = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === l && (q = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1])), !q) for (k = this.parsers.length; k--&&!q;) u = this.parsers[k],\n"
                "(l = u.regex.exec(f)) && (q = u.parse(l));\n"
                "this.rgba = q || []\n"
            "},\n"
            "get: function(a) {\n"
                "var f = this.input,\n"
                "q = this.rgba,\n"
                "k;\n"
                "this.stops ? (k = G(f), k.stops = [].concat(k.stops), B(this.stops,\n"
                "function(u, d) {\n"
                    "k.stops[d] = [k.stops[d][0], u.get(a)]\n"
                "})) : k = q && A(q[0]) ? \"rgb\" === a || !a && 1 === q[3] ? \"rgb(\" + q[0] + \",\" + q[1] + \",\" + q[2] + \")\": \"a\" === a ? q[3] : \"rgba(\" + q.join(\",\") + \")\": f;\n"
                "return k\n"
            "},\n"
            "brighten: function(a) {\n"
                "var f, q = this.rgba;\n"
                "if (this.stops) B(this.stops,\n"
                "function(k) {\n"
                    "k.brighten(a)\n"
                "});\n"
                "else if (A(a) && 0 !== a) for (f = 0; 3 > f; f++) q[f] += r(255 * a),\n"
                "0 > q[f] && (q[f] = 0),\n"
                "255 < q[f] && (q[f] = 255);\n"
                "return this\n"
            "},\n"
            "setOpacity: function(a) {\n"
                "this.rgba[3] = a;\n"
                "return this\n"
            "}\n"
        "};\n"
        "a.color = function(f) {\n"
            "return new a.Color(f)\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B, A, H = a.addEvent,\n"
        "G = a.animate,\n"
        "r = a.attr,\n"
        "f = a.charts,\n"
        "l = a.color,\n"
        "q = a.css,\n"
        "k = a.createElement,\n"
        "u = a.defined,\n"
        "d = a.deg2rad,\n"
        "c = a.destroyObjectProperties,\n"
        "n = a.doc,\n"
        "z = a.each,\n"
        "b = a.extend,\n"
        "p = a.erase,\n"
        "h = a.grep,\n"
        "t = a.hasTouch,\n"
        "D = a.inArray,\n"
        "w = a.isArray,\n"
        "e = a.isFirefox,\n"
        "x = a.isMS,\n"
        "C = a.isObject,\n"
        "E = a.isString,\n"
        "m = a.isWebKit,\n"
        "y = a.merge,\n"
        "I = a.noop,\n"
        "K = a.pick,\n"
        "J = a.pInt,\n"
        "g = a.removeEvent,\n"
        "F = a.stop,\n"
        "Q = a.svg,\n"
        "N = a.SVG_NS,\n"
        "P = a.symbolSizes,\n"
        "O = a.win;\n"
        "B = a.SVGElement = function() {\n"
            "return this\n"
        "};\n"
        "B.prototype = {\n"
            "opacity: 1,\n"
            "SVG_NS: N,\n"
            "textProps: \"direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline\".split(\" \"),\n"
            "init: function(a, g) {\n"
                "this.element = \"span\" === g ? k(g) : n.createElementNS(this.SVG_NS, g);\n"
                "this.renderer = a\n"
            "},\n"
            "animate: function(v, g, b) {\n"
                "g = a.animObject(K(g, this.renderer.globalAnimation, !0));\n"
                "0 !== g.duration ? (b && (g.complete = b), G(this, v, g)) : (this.attr(v, null, b), g.step && g.step.call(this));\n"
                "return this\n"
            "},\n"
            "colorGradient: function(v, g, b) {\n"
                "var e = this.renderer,\n"
                "h, c, m, M, F, x, d, C, t, p, n, k = [],\n"
                "R;\n"
                "v.radialGradient ? c = \"radialGradient\": v.linearGradient && (c = \"linearGradient\");\n"
                "if (c) {\n"
                    "m = v[c];\n"
                    "F = e.gradients;\n"
                    "d = v.stops;\n"
                    "p = b.radialReference;\n"
                    "w(m) && (v[c] = m = {\n"
                        "x1: m[0],\n"
                        "y1: m[1],\n"
                        "x2: m[2],\n"
                        "y2: m[3],\n"
                        "gradientUnits: \"userSpaceOnUse\"\n"
                    "});\n"
                    "\"radialGradient\" === c && p && !u(m.gradientUnits) && (M = m, m = y(m, e.getRadialAttr(p, M), {\n"
                        "gradientUnits: \"userSpaceOnUse\"\n"
                    "}));\n"
                    "for (n in m)\"id\" !== n && k.push(n, m[n]);\n"
                    "for (n in d) k.push(d[n]);\n"
                    "k = k.join(\",\");\n"
                    "F[k] ? p = F[k].attr(\"id\") : (m.id = p = a.uniqueKey(), F[k] = x = e.createElement(c).attr(m).add(e.defs), x.radAttr = M, x.stops = [], z(d,\n"
                    "function(v) {\n"
                        "0 === v[1].indexOf(\"rgba\") ? (h = a.color(v[1]), C = h.get(\"rgb\"), t = h.get(\"a\")) : (C = v[1], t = 1);\n"
                        "v = e.createElement(\"stop\").attr({\n"
                            "offset: v[0],\n"
                            "\"stop-color\": C,\n"
                            "\"stop-opacity\": t\n"
                        "}).add(x);\n"
                        "x.stops.push(v)\n"
                    "}));\n"
                    "R = \"url(\" + e.url + \"#\" + p + \")\";\n"
                    "b.setAttribute(g, R);\n"
                    "b.gradient = k;\n"
                    "v.toString = function() {\n"
                        "return R\n"
                    "}\n"
                "}\n"
            "},\n"
            "applyTextOutline: function(v) {\n"
                "var g = this.element,\n"
                "b, e, c, h, m; - 1 !== v.indexOf(\"contrast\") && (v = v.replace(/contrast/g, this.renderer.getContrast(g.style.fill)));\n"
                "v = v.split(\" \");\n"
                "e = v[v.length - 1];\n"
                "if ((c = v[0]) && \"none\" !== c && a.svg) {\n"
                    "this.fakeTS = !0;\n"
                    "v = [].slice.call(g.getElementsByTagName(\"tspan\"));\n"
                    "this.ySetter = this.xSetter;\n"
                    "c = c.replace(/(^[\\d\\.]+)(.*?)$/g,\n"
                    "function(a, v, g) {\n"
                        "return 2 * v + g\n"
                    "});\n"
                    "for (m = v.length; m--;) b = v[m],\n"
                    "\"highcharts-text-outline\" === b.getAttribute(\"class\") && p(v, g.removeChild(b));\n"
                    "h = g.firstChild;\n"
                    "z(v,\n"
                    "function(a, v) {\n"
                        "0 === v && (a.setAttribute(\"x\", g.getAttribute(\"x\")), v = g.getAttribute(\"y\"), a.setAttribute(\"y\", v || 0), null === v && g.setAttribute(\"y\", 0));\n"
                        "a = a.cloneNode(1);\n"
                        "r(a, {\n"
                            "\"class\": \"highcharts-text-outline\",\n"
                            "fill: e,\n"
                            "stroke: e,\n"
                            "\"stroke-width\": c,\n"
                            "\"stroke-linejoin\": \"round\"\n"
                        "});\n"
                        "g.insertBefore(a, h)\n"
                    "})\n"
                "}\n"
            "},\n"
            "attr: function(a, g, b, e) {\n"
                "var v, c = this.element,\n"
                "h, m = this,\n"
                "M;\n"
                "\"string\" === typeof a && void 0 !== g && (v = a, a = {},\n"
                "a[v] = g);\n"
                "if (\"string\" === typeof a) m = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, c);\n"
                "else {\n"
                    "for (v in a) g = a[v],\n"
                    "M = !1,\n"
                    "e || F(this, v),\n"
                    "this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(v) && (h || (this.symbolAttr(a), h = !0), M = !0),\n"
                    "!this.rotation || \"x\" !== v && \"y\" !== v || (this.doTransform = !0),\n"
                    "M || (M = this[v + \"Setter\"] || this._defaultSetter, M.call(this, g, v, c), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(v) && this.updateShadows(v, g, M));\n"
                    "this.doTransform && (this.updateTransform(), this.doTransform = !1)\n"
                "}\n"
                "b && b();\n"
                "return m\n"
            "},\n"
            "updateShadows: function(a, g, b) {\n"
                "for (var v = this.shadows,\n"
                "e = v.length; e--;) b.call(v[e], \"height\" === a ? Math.max(g - (v[e].cutHeight || 0), 0) : \"d\" === a ? this.d: g, a, v[e])\n"
            "},\n"
            "addClass: function(a, g) {\n"
                "var v = this.attr(\"class\") || \"\"; - 1 === v.indexOf(a) && (g || (a = (v + (v ? \" \": \"\") + a).replace(\"  \", \" \")), this.attr(\"class\", a));\n"
                "return this\n"
            "},\n"
            "hasClass: function(a) {\n"
                "return - 1 !== r(this.element, \"class\").indexOf(a)\n"
            "},\n"
            "removeClass: function(a) {\n"
                "r(this.element, \"class\", (r(this.element, \"class\") || \"\").replace(a, \"\"));\n"
                "return this\n"
            "},\n"
            "symbolAttr: function(a) {\n"
                "var v = this;\n"
                "z(\"x y r start end width height innerR anchorX anchorY\".split(\" \"),\n"
                "function(g) {\n"
                    "v[g] = K(a[g], v[g])\n"
                "});\n"
                "v.attr({\n"
                    "d: v.renderer.symbols[v.symbolName](v.x, v.y, v.width, v.height, v)\n"
                "})\n"
            "},\n"
            "clip: function(a) {\n"
                "return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\": \"none\")\n"
            "},\n"
            "crisp: function(a, g) {\n"
                "var v, b = {},\n"
                "e;\n"
                "g = g || a.strokeWidth || 0;\n"
                "e = Math.round(g) % 2 / 2;\n"
                "a.x = Math.floor(a.x || this.x || 0) + e;\n"
                "a.y = Math.floor(a.y || this.y || 0) + e;\n"
                "a.width = Math.floor((a.width || this.width || 0) - 2 * e);\n"
                "a.height = Math.floor((a.height || this.height || 0) - 2 * e);\n"
                "u(a.strokeWidth) && (a.strokeWidth = g);\n"
                "for (v in a) this[v] !== a[v] && (this[v] = b[v] = a[v]);\n"
                "return b\n"
            "},\n"
            "css: function(a) {\n"
                "var v = this.styles,\n"
                "g = {},\n"
                "e = this.element,\n"
                "c, h = \"\",\n"
                "m = !v,\n"
                "F = [\"textOutline\", \"textOverflow\", \"width\"];\n"
                "a && a.color && (a.fill = a.color);\n"
                "if (v) for (c in a) a[c] !== v[c] && (g[c] = a[c], m = !0);\n"
                "if (m) {\n"
                    "v && (a = b(v, g));\n"
                    "v = this.textWidth = a && a.width && \"auto\" !== a.width && \"text\" === e.nodeName.toLowerCase() && J(a.width);\n"
                    "this.styles = a;\n"
                    "v && !Q && this.renderer.forExport && delete a.width;\n"
                    "if (x && !Q) q(this.element, a);\n"
                    "else {\n"
                        "v = function(a, v) {\n"
                            "return \"-\" + v.toLowerCase()\n"
                        "};\n"
                        "for (c in a) - 1 === D(c, F) && (h += c.replace(/([A-Z])/g, v) + \":\" + a[c] + \";\");\n"
                        "h && r(e, \"style\", h)\n"
                    "}\n"
                    "this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline))\n"
                "}\n"
                "return this\n"
            "},\n"
            "strokeWidth: function() {\n"
                "return this[\"stroke-width\"] || 0\n"
            "},\n"
            "on: function(a, g) {\n"
                "var v = this,\n"
                "e = v.element;\n"
                "t && \"click\" === a ? (e.ontouchstart = function(a) {\n"
                    "v.touchEventFired = Date.now();\n"
                    "a.preventDefault();\n"
                    "g.call(e, a)\n"
                "},\n"
                "e.onclick = function(a) { ( - 1 === O.navigator.userAgent.indexOf(\"Android\") || 1100 < Date.now() - (v.touchEventFired || 0)) && g.call(e, a)\n"
                "}) : e[\"on\" + a] = g;\n"
                "return this\n"
            "},\n"
            "setRadialReference: function(a) {\n"
                "var v = this.renderer.gradients[this.element.gradient];\n"
                "this.element.radialReference = a;\n"
                "v && v.radAttr && v.animate(this.renderer.getRadialAttr(a, v.radAttr));\n"
                "return this\n"
            "},\n"
            "translate: function(a, g) {\n"
                "return this.attr({\n"
                    "translateX: a,\n"
                    "translateY: g\n"
                "})\n"
            "},\n"
            "invert: function(a) {\n"
                "this.inverted = a;\n"
                "this.updateTransform();\n"
                "return this\n"
            "},\n"
            "updateTransform: function() {\n"
                "var a = this.translateX || 0,\n"
                "g = this.translateY || 0,\n"
                "e = this.scaleX,\n"
                "b = this.scaleY,\n"
                "c = this.inverted,\n"
                "h = this.rotation,\n"
                "m = this.element;\n"
                "c && (a += this.width, g += this.height);\n"
                "a = [\"translate(\" + a + \",\" + g + \")\"];\n"
                "c ? a.push(\"rotate(90) scale(-1,1)\") : h && a.push(\"rotate(\" + h + \" \" + (m.getAttribute(\"x\") || 0) + \" \" + (m.getAttribute(\"y\") || 0) + \")\"); (u(e) || u(b)) && a.push(\"scale(\" + K(e, 1) + \" \" + K(b, 1) + \")\");\n"
                "a.length && m.setAttribute(\"transform\", a.join(\" \"))\n"
            "},\n"
            "toFront: function() {\n"
                "var a = this.element;\n"
                "a.parentNode.appendChild(a);\n"
                "return this\n"
            "},\n"
            "align: function(a, g, e) {\n"
                "var v, b, c, h, m = {};\n"
                "b = this.renderer;\n"
                "c = b.alignedObjects;\n"
                "var F, x;\n"
                "if (a) {\n"
                    "if (this.alignOptions = a, this.alignByTranslate = g, !e || E(e)) this.alignTo = v = e || \"renderer\",\n"
                    "p(c, this),\n"
                    "c.push(this),\n"
                    "e = null\n"
                "} else a = this.alignOptions,\n"
                "g = this.alignByTranslate,\n"
                "v = this.alignTo;\n"
                "e = K(e, b[v], b);\n"
                "v = a.align;\n"
                "b = a.verticalAlign;\n"
                "c = (e.x || 0) + (a.x || 0);\n"
                "h = (e.y || 0) + (a.y || 0);\n"
                "\"right\" === v ? F = 1 : \"center\" === v && (F = 2);\n"
                "F && (c += (e.width - (a.width || 0)) / F);\n"
                "m[g ? \"translateX\": \"x\"] = Math.round(c);\n"
                "\"bottom\" === b ? x = 1 : \"middle\" === b && (x = 2);\n"
                "x && (h += (e.height - (a.height || 0)) / x);\n"
                "m[g ? \"translateY\": \"y\"] = Math.round(h);\n"
                "this[this.placed ? \"animate\": \"attr\"](m);\n"
                "this.placed = !0;\n"
                "this.alignAttr = m;\n"
                "return this\n"
            "},\n"
            "getBBox: function(a, g) {\n"
                "var v, e = this.renderer,\n"
                "c, h = this.element,\n"
                "m = this.styles,\n"
                "F, x = this.textStr,\n"
                "y, M = e.cache,\n"
                "C = e.cacheKeys,\n"
                "t;\n"
                "g = K(g, this.rotation);\n"
                "c = g * d;\n"
                "F = m && m.fontSize;\n"
                "void 0 !== x && (t = x.toString(), -1 === t.indexOf(\"\\x3c\") && (t = t.replace(/[0-9]/g, \"0\")), t += [\"\", g || 0, F, m && m.width, m && m.textOverflow].join());\n"
                "t && !a && (v = M[t]);\n"
                "if (!v) {\n"
                    "if (h.namespaceURI === this.SVG_NS || e.forExport) {\n"
                        "try { (y = this.fakeTS &&\n"
                            "function(a) {\n"
                                "z(h.querySelectorAll(\".highcharts-text-outline\"),\n"
                                "function(v) {\n"
                                    "v.style.display = a\n"
                                "})\n"
                            "}) && y(\"none\"),\n"
                            "v = h.getBBox ? b({},\n"
                            "h.getBBox()) : {\n"
                                "width: h.offsetWidth,\n"
                                "height: h.offsetHeight\n"
                            "},\n"
                            "y && y(\"\")\n"
                        "} catch(X) {}\n"
                        "if (!v || 0 > v.width) v = {\n"
                            "width: 0,\n"
                            "height: 0\n"
                        "}\n"
                    "} else v = this.htmlGetBBox();\n"
                    "e.isSVG && (a = v.width, e = v.height, m && \"11px\" === m.fontSize && 17 === Math.round(e) && (v.height = e = 14), g && (v.width = Math.abs(e * Math.sin(c)) + Math.abs(a * Math.cos(c)), v.height = Math.abs(e * Math.cos(c)) + Math.abs(a * Math.sin(c))));\n"
                    "if (t && 0 < v.height) {\n"
                        "for (; 250 < C.length;) delete M[C.shift()];\n"
                        "M[t] || C.push(t);\n"
                        "M[t] = v\n"
                    "}\n"
                "}\n"
                "return v\n"
            "},\n"
            "show: function(a) {\n"
                "return this.attr({\n"
                    "visibility: a ? \"inherit\": \"visible\"\n"
                "})\n"
            "},\n"
            "hide: function() {\n"
                "return this.attr({\n"
                    "visibility: \"hidden\"\n"
                "})\n"
            "},\n"
            "fadeOut: function(a) {\n"
                "var v = this;\n"
                "v.animate({\n"
                    "opacity: 0\n"
                "},\n"
                "{\n"
                    "duration: a || 150,\n"
                    "complete: function() {\n"
                        "v.attr({\n"
                            "y: -9999\n"
                        "})\n"
                    "}\n"
                "})\n"
            "},\n"
            "add: function(a) {\n"
                "var v = this.renderer,\n"
                "g = this.element,\n"
                "e;\n"
                "a && (this.parentGroup = a);\n"
                "this.parentInverted = a && a.inverted;\n"
                "void 0 !== this.textStr && v.buildText(this);\n"
                "this.added = !0;\n"
                "if (!a || a.handleZ || this.zIndex) e = this.zIndexSetter();\n"
                "e || (a ? a.element: v.box).appendChild(g);\n"
                "if (this.onAdd) this.onAdd();\n"
                "return this\n"
            "},\n"
            "safeRemoveChild: function(a) {\n"
                "var v = a.parentNode;\n"
                "v && v.removeChild(a)\n"
            "},\n"
            "destroy: function() {\n"
                "var a = this,\n"
                "g = a.element || {},\n"
                "e = a.renderer.isSVG && \"SPAN\" === g.nodeName && a.parentGroup,\n"
                "b, c;\n"
                "g.onclick = g.onmouseout = g.onmouseover = g.onmousemove = g.point = null;\n"
                "F(a);\n"
                "a.clipPath && (z(a.element.ownerSVGElement.querySelectorAll(\"[clip-path]\"),\n"
                "function(v) { - 1 < v.getAttribute(\"clip-path\").indexOf(a.clipPath.element.id) && v.removeAttribute(\"clip-path\")\n"
                "}), a.clipPath = a.clipPath.destroy());\n"
                "if (a.stops) {\n"
                    "for (c = 0; c < a.stops.length; c++) a.stops[c] = a.stops[c].destroy();\n"
                    "a.stops = null\n"
                "}\n"
                "a.safeRemoveChild(g);\n"
                "for (a.destroyShadows(); e && e.div && 0 === e.div.childNodes.length;) g = e.parentGroup,\n"
                "a.safeRemoveChild(e.div),\n"
                "delete e.div,\n"
                "e = g;\n"
                "a.alignTo && p(a.renderer.alignedObjects, a);\n"
                "for (b in a) delete a[b];\n"
                "return null\n"
            "},\n"
            "shadow: function(a, g, e) {\n"
                "var v = [],\n"
                "b,\n"
                "c,\n"
                "h = this.element,\n"
                "m,\n"
                "F,\n"
                "x,\n"
                "y;\n"
                "if (!a) this.destroyShadows();\n"
                "else if (!this.shadows) {\n"
                    "F = K(a.width, 3);\n"
                    "x = (a.opacity || .15) / F;\n"
                    "y = this.parentInverted ? \"(-1,-1)\": \"(\" + K(a.offsetX, 1) + \", \" + K(a.offsetY, 1) + \")\";\n"
                    "for (b = 1; b <= F; b++) c = h.cloneNode(0),\n"
                    "m = 2 * F + 1 - 2 * b,\n"
                    "r(c, {\n"
                        "isShadow: \"true\",\n"
                        "stroke: a.color || \"#000000\",\n"
                        "\"stroke-opacity\": x * b,\n"
                        "\"stroke-width\": m,\n"
                        "transform: \"translate\" + y,\n"
                        "fill: \"none\"\n"
                    "}),\n"
                    "e && (r(c, \"height\", Math.max(r(c, \"height\") - m, 0)), c.cutHeight = m),\n"
                    "g ? g.element.appendChild(c) : h.parentNode.insertBefore(c, h),\n"
                    "v.push(c);\n"
                    "this.shadows = v\n"
                "}\n"
                "return this\n"
            "},\n"
            "destroyShadows: function() {\n"
                "z(this.shadows || [],\n"
                "function(a) {\n"
                    "this.safeRemoveChild(a)\n"
                "},\n"
                "this);\n"
                "this.shadows = void 0\n"
            "},\n"
            "xGetter: function(a) {\n"
                "\"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\": \"y\" === a && (a = \"cy\"));\n"
                "return this._defaultGetter(a)\n"
            "},\n"
            "_defaultGetter: function(a) {\n"
                "a = K(this[a], this.element ? this.element.getAttribute(a) : null, 0);\n"
                "/^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n"
                "return a\n"
            "},\n"
            "dSetter: function(a, g, e) {\n"
                "a && a.join && (a = a.join(\" \"));\n"
                "/(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n"
                "e.setAttribute(g, a);\n"
                "this[g] = a\n"
            "},\n"
            "dashstyleSetter: function(a) {\n"
                "var v, g = this[\"stroke-width\"];\n"
                "\"inherit\" === g && (g = 1);\n"
                "if (a = a && a.toLowerCase()) {\n"
                    "a = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n"
                    "for (v = a.length; v--;) a[v] = J(a[v]) * g;\n"
                    "a = a.join(\",\").replace(/NaN/g, \"none\");\n"
                    "this.element.setAttribute(\"stroke-dasharray\", a)\n"
                "}\n"
            "},\n"
            "alignSetter: function(a) {\n"
                "this.element.setAttribute(\"text-anchor\", {\n"
                    "left: \"start\",\n"
                    "center: \"middle\",\n"
                    "right: \"end\"\n"
                "} [a])\n"
            "},\n"
            "opacitySetter: function(a, g, e) {\n"
                "this[g] = a;\n"
                "e.setAttribute(g, a)\n"
            "},\n"
            "titleSetter: function(a) {\n"
                "var v = this.element.getElementsByTagName(\"title\")[0];\n"
                "v || (v = n.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(v));\n"
                "v.firstChild && v.removeChild(v.firstChild);\n"
                "v.appendChild(n.createTextNode(String(K(a), \"\").replace(/<[^>]*>/g, \"\")))\n"
            "},\n"
            "textSetter: function(a) {\n"
                "a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this))\n"
            "},\n"
            "fillSetter: function(a, g, e) {\n"
                "\"string\" === typeof a ? e.setAttribute(g, a) : a && this.colorGradient(a, g, e)\n"
            "},\n"
            "visibilitySetter: function(a, g, e) {\n"
                "\"inherit\" === a ? e.removeAttribute(g) : e.setAttribute(g, a)\n"
            "},\n"
            "zIndexSetter: function(a, g) {\n"
                "var v = this.renderer,\n"
                "e = this.parentGroup,\n"
                "b = (e || v).element || v.box,\n"
                "c,\n"
                "h = this.element,\n"
                "m;\n"
                "c = this.added;\n"
                "var F;\n"
                "u(a) && (h.zIndex = a, a = +a, this[g] === a && (c = !1), this[g] = a);\n"
                "if (c) { (a = this.zIndex) && e && (e.handleZ = !0);\n"
                    "g = b.childNodes;\n"
                    "for (F = 0; F < g.length && !m; F++) e = g[F],\n"
                    "c = e.zIndex,\n"
                    "e !== h && (J(c) > a || !u(a) && u(c) || 0 > a && !u(c) && b !== v.box) && (b.insertBefore(h, e), m = !0);\n"
                    "m || b.appendChild(h)\n"
                "}\n"
                "return m\n"
            "},\n"
            "_defaultSetter: function(a, g, e) {\n"
                "e.setAttribute(g, a)\n"
            "}\n"
        "};\n"
        "B.prototype.yGetter = B.prototype.xGetter;\n"
        "B.prototype.translateXSetter = B.prototype.translateYSetter = B.prototype.rotationSetter = B.prototype.verticalAlignSetter = B.prototype.scaleXSetter = B.prototype.scaleYSetter = function(a, g) {\n"
            "this[g] = a;\n"
            "this.doTransform = !0\n"
        "};\n"
        "B.prototype[\"stroke-widthSetter\"] = B.prototype.strokeSetter = function(a, g, e) {\n"
            "this[g] = a;\n"
            "this.stroke && this[\"stroke-width\"] ? (B.prototype.fillSetter.call(this, this.stroke, \"stroke\", e), e.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === g && 0 === a && this.hasStroke && (e.removeAttribute(\"stroke\"), this.hasStroke = !1)\n"
        "};\n"
        "A = a.SVGRenderer = function() {\n"
            "this.init.apply(this, arguments)\n"
        "};\n"
        "A.prototype = {\n"
            "Element: B,\n"
            "SVG_NS: N,\n"
            "init: function(a, g, b, c, h, F) {\n"
                "var v;\n"
                "c = this.createElement(\"svg\").attr({\n"
                    "version: \"1.1\",\n"
                    "\"class\": \"highcharts-root\"\n"
                "}).css(this.getStyle(c));\n"
                "v = c.element;\n"
                "a.appendChild(v); - 1 === a.innerHTML.indexOf(\"xmlns\") && r(v, \"xmlns\", this.SVG_NS);\n"
                "this.isSVG = !0;\n"
                "this.box = v;\n"
                "this.boxWrapper = c;\n"
                "this.alignedObjects = [];\n"
                "this.url = (e || m) && n.getElementsByTagName(\"base\").length ? O.location.href.replace(/#.*?$/, \"\").replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n"
                "this.createElement(\"desc\").add().element.appendChild(n.createTextNode(\"Created with Highcharts 5.0.10\"));\n"
                "this.defs = this.createElement(\"defs\").add();\n"
                "this.allowHTML = F;\n"
                "this.forExport = h;\n"
                "this.gradients = {};\n"
                "this.cache = {};\n"
                "this.cacheKeys = [];\n"
                "this.imgCount = 0;\n"
                "this.setSize(g, b, !1);\n"
                "var x;\n"
                "e && a.getBoundingClientRect && (g = function() {\n"
                    "q(a, {\n"
                        "left: 0,\n"
                        "top: 0\n"
                    "});\n"
                    "x = a.getBoundingClientRect();\n"
                    "q(a, {\n"
                        "left: Math.ceil(x.left) - x.left + \"px\",\n"
                        "top: Math.ceil(x.top) - x.top + \"px\"\n"
                    "})\n"
                "},\n"
                "g(), this.unSubPixelFix = H(O, \"resize\", g))\n"
            "},\n"
            "getStyle: function(a) {\n"
                "return this.style = b({\n"
                    "fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n"
                    "fontSize: \"12px\"\n"
                "},\n"
                "a)\n"
            "},\n"
            "setStyle: function(a) {\n"
                "this.boxWrapper.css(this.getStyle(a))\n"
            "},\n"
            "isHidden: function() {\n"
                "return ! this.boxWrapper.getBBox().width\n"
            "},\n"
            "destroy: function() {\n"
                "var a = this.defs;\n"
                "this.box = null;\n"
                "this.boxWrapper = this.boxWrapper.destroy();\n"
                "c(this.gradients || {});\n"
                "this.gradients = null;\n"
                "a && (this.defs = a.destroy());\n"
                "this.unSubPixelFix && this.unSubPixelFix();\n"
                "return this.alignedObjects = null\n"
            "},\n"
            "createElement: function(a) {\n"
                "var g = new this.Element;\n"
                "g.init(this, a);\n"
                "return g\n"
            "},\n"
            "draw: I,\n"
            "getRadialAttr: function(a, g) {\n"
                "return {\n"
                    "cx: a[0] - a[2] / 2 + g.cx * a[2],\n"
                    "cy: a[1] - a[2] / 2 + g.cy * a[2],\n"
                    "r: g.r * a[2]\n"
                "}\n"
            "},\n"
            "getSpanWidth: function(a, g) {\n"
                "var v = a.getBBox(!0).width; ! Q && this.forExport && (v = this.measureSpanWidth(g.firstChild.data, a.styles));\n"
                "return v\n"
            "},\n"
            "applyEllipsis: function(a, g, e, b) {\n"
                "var v = this.getSpanWidth(a, g),\n"
                "c = v > b,\n"
                "v = e,\n"
                "h,\n"
                "m = 0,\n"
                "F = e.length,\n"
                "x = function(a) {\n"
                    "g.removeChild(g.firstChild);\n"
                    "a && g.appendChild(n.createTextNode(a))\n"
                "};\n"
                "if (c) {\n"
                    "for (; m <= F;) h = Math.ceil((m + F) / 2),\n"
                    "v = e.substring(0, h) + \"\\u2026\",\n"
                    "x(v),\n"
                    "v = this.getSpanWidth(a, g),\n"
                    "m === F ? m = F + 1 : v > b ? F = h - 1 : m = h;\n"
                    "0 === F && x(\"\")\n"
                "}\n"
                "return c\n"
            "},\n"
            "buildText: function(a) {\n"
                "var g = a.element,\n"
                "e = this,\n"
                "v = e.forExport,\n"
                "b = K(a.textStr, \"\").toString(),\n"
                "c = -1 !== b.indexOf(\"\\x3c\"),\n"
                "m = g.childNodes,\n"
                "F,\n"
                "x,\n"
                "y,\n"
                "t,\n"
                "d = r(g, \"x\"),\n"
                "C = a.styles,\n"
                "p = a.textWidth,\n"
                "k = C && C.lineHeight,\n"
                "w = C && C.textOutline,\n"
                "u = C && \"ellipsis\" === C.textOverflow,\n"
                "f = C && \"nowrap\" === C.whiteSpace,\n"
                "E = C && C.fontSize,\n"
                "D,\n"
                "I,\n"
                "l = m.length,\n"
                "C = p && !a.added && this.box,\n"
                "P = function(a) {\n"
                    "var v;\n"
                    "v = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize: E || e.style.fontSize || 12;\n"
                    "return k ? J(k) : e.fontMetrics(v, a.getAttribute(\"style\") ? a: g).h\n"
                "};\n"
                "D = [b, u, f, k, w, E, p].join();\n"
                "if (D !== a.textCache) {\n"
                    "for (a.textCache = D; l--;) g.removeChild(m[l]);\n"
                    "c || w || u || p || -1 !== b.indexOf(\" \") ? (F = /<.*class=\"([^\"]+)\".*>/, x = /<.*style=\"([^\"]+)\".*>/, y = /<.*href=\"(http[^\"]+)\".*>/, C && C.appendChild(g), b = c ? b.replace(/<(b|strong)>/g, '\\x3cspan style\\x3d\"font-weight:bold\"\\x3e').replace(/<(i|em)>/g, '\\x3cspan style\\x3d\"font-style:italic\"\\x3e').replace(/<a/g, \"\\x3cspan\").replace(/<\\/(b|strong|i|em|a)>/g, \"\\x3c/span\\x3e\").split(/<br.*?>/g) : [b], b = h(b,\n"
                    "function(a) {\n"
                        "return \"\" !== a\n"
                    "}), z(b,\n"
                    "function(b, c) {\n"
                        "var m, h = 0;\n"
                        "b = b.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||\\x3cspan\").replace(/<\\/span>/g, \"\\x3c/span\\x3e|||\");\n"
                        "m = b.split(\"|||\");\n"
                        "z(m,\n"
                        "function(b) {\n"
                            "if (\"\" !== b || 1 === m.length) {\n"
                                "var C = {},\n"
                                "k = n.createElementNS(e.SVG_NS, \"tspan\"),\n"
                                "w,\n"
                                "E;\n"
                                "F.test(b) && (w = b.match(F)[1], r(k, \"class\", w));\n"
                                "x.test(b) && (E = b.match(x)[1].replace(/(;| |^)color([ :])/, \"$1fill$2\"), r(k, \"style\", E));\n"
                                "y.test(b) && !v && (r(k, \"onclick\", 'location.href\\x3d\"' + b.match(y)[1] + '\"'), q(k, {\n"
                                    "cursor: \"pointer\"\n"
                                "}));\n"
                                "b = (b.replace(/<(.|\\n)*?>/g, \"\") || \" \").replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\");\n"
                                "if (\" \" !== b) {\n"
                                    "k.appendChild(n.createTextNode(b));\n"
                                    "h ? C.dx = 0 : c && null !== d && (C.x = d);\n"
                                    "r(k, C);\n"
                                    "g.appendChild(k); ! h && I && (!Q && v && q(k, {\n"
                                        "display: \"block\"\n"
                                    "}), r(k, \"dy\", P(k)));\n"
                                    "if (p) {\n"
                                        "C = b.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n"
                                        "w = 1 < m.length || c || 1 < C.length && !f;\n"
                                        "var D = [],\n"
                                        "M,\n"
                                        "z = P(k),\n"
                                        "l = a.rotation;\n"
                                        "for (u && (t = e.applyEllipsis(a, k, b, p)); ! u && w && (C.length || D.length);) a.rotation = 0,\n"
                                        "M = e.getSpanWidth(a, k),\n"
                                        "b = M > p,\n"
                                        "void 0 === t && (t = b),\n"
                                        "b && 1 !== C.length ? (k.removeChild(k.firstChild), D.unshift(C.pop())) : (C = D, D = [], C.length && !f && (k = n.createElementNS(N, \"tspan\"), r(k, {\n"
                                            "dy: z,\n"
                                            "x: d\n"
                                        "}), E && r(k, \"style\", E), g.appendChild(k)), M > p && (p = M)),\n"
                                        "C.length && k.appendChild(n.createTextNode(C.join(\" \").replace(/- /g, \"-\")));\n"
                                        "a.rotation = l\n"
                                    "}\n"
                                    "h++\n"
                                "}\n"
                            "}\n"
                        "});\n"
                        "I = I || g.childNodes.length\n"
                    "}), t && a.attr(\"title\", a.textStr), C && C.removeChild(g), w && a.applyTextOutline && a.applyTextOutline(w)) : g.appendChild(n.createTextNode(b.replace(/&lt;/g, \"\\x3c\").replace(/&gt;/g, \"\\x3e\")))\n"
                "}\n"
            "},\n"
            "getContrast: function(a) {\n"
                "a = l(a).rgba;\n"
                "return 510 < a[0] + a[1] + a[2] ? \"#000000\": \"#FFFFFF\"\n"
            "},\n"
            "button: function(a, g, e, c, m, h, F, C, t) {\n"
                "var v = this.label(a, g, e, t, null, null, null, null, \"button\"),\n"
                "d = 0;\n"
                "v.attr(y({\n"
                    "padding: 8,\n"
                    "r: 2\n"
                "},\n"
                "m));\n"
                "var p, n, k, w;\n"
                "m = y({\n"
                    "fill: \"#f7f7f7\",\n"
                    "stroke: \"#cccccc\",\n"
                    "\"stroke-width\": 1,\n"
                    "style: {\n"
                        "color: \"#333333\",\n"
                        "cursor: \"pointer\",\n"
                        "fontWeight: \"normal\"\n"
                    "}\n"
                "},\n"
                "m);\n"
                "p = m.style;\n"
                "delete m.style;\n"
                "h = y(m, {\n"
                    "fill: \"#e6e6e6\"\n"
                "},\n"
                "h);\n"
                "n = h.style;\n"
                "delete h.style;\n"
                "F = y(m, {\n"
                    "fill: \"#e6ebf5\",\n"
                    "style: {\n"
                        "color: \"#000000\",\n"
                        "fontWeight: \"bold\"\n"
                    "}\n"
                "},\n"
                "F);\n"
                "k = F.style;\n"
                "delete F.style;\n"
                "C = y(m, {\n"
                    "style: {\n"
                        "color: \"#cccccc\"\n"
                    "}\n"
                "},\n"
                "C);\n"
                "w = C.style;\n"
                "delete C.style;\n"
                "H(v.element, x ? \"mouseover\": \"mouseenter\",\n"
                "function() {\n"
                    "3 !== d && v.setState(1)\n"
                "});\n"
                "H(v.element, x ? \"mouseout\": \"mouseleave\",\n"
                "function() {\n"
                    "3 !== d && v.setState(d)\n"
                "});\n"
                "v.setState = function(a) {\n"
                    "1 !== a && (v.state = d = a);\n"
                    "v.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n"
                    "v.attr([m, h, F, C][a || 0]).css([p, n, k, w][a || 0])\n"
                "};\n"
                "v.attr(m).css(b({\n"
                    "cursor: \"default\"\n"
                "},\n"
                "p));\n"
                "return v.on(\"click\",\n"
                "function(a) {\n"
                    "3 !== d && c.call(v, a)\n"
                "})\n"
            "},\n"
            "crispLine: function(a, g) {\n"
                "a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - g % 2 / 2);\n"
                "a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + g % 2 / 2);\n"
                "return a\n"
            "},\n"
            "path: function(a) {\n"
                "var g = {\n"
                    "fill: \"none\"\n"
                "};\n"
                "w(a) ? g.d = a: C(a) && b(g, a);\n"
                "return this.createElement(\"path\").attr(g)\n"
            "},\n"
            "circle: function(a, g, e) {\n"
                "a = C(a) ? a: {\n"
                    "x: a,\n"
                    "y: g,\n"
                    "r: e\n"
                "};\n"
                "g = this.createElement(\"circle\");\n"
                "g.xSetter = g.ySetter = function(a, g, e) {\n"
                    "e.setAttribute(\"c\" + g, a)\n"
                "};\n"
                "return g.attr(a)\n"
            "},\n"
            "arc: function(a, g, e, b, c, m) {\n"
                "C(a) ? (b = a, g = b.y, e = b.r, a = b.x) : b = {\n"
                    "innerR: b,\n"
                    "start: c,\n"
                    "end: m\n"
                "};\n"
                "a = this.symbol(\"arc\", a, g, e, e, b);\n"
                "a.r = e;\n"
                "return a\n"
            "},\n"
            "rect: function(a, g, e, b, c, m) {\n"
                "c = C(a) ? a.r: c;\n"
                "var v = this.createElement(\"rect\");\n"
                "a = C(a) ? a: void 0 === a ? {}: {\n"
                    "x: a,\n"
                    "y: g,\n"
                    "width: Math.max(e, 0),\n"
                    "height: Math.max(b, 0)\n"
                "};\n"
                "void 0 !== m && (a.strokeWidth = m, a = v.crisp(a));\n"
                "a.fill = \"none\";\n"
                "c && (a.r = c);\n"
                "v.rSetter = function(a, g, e) {\n"
                    "r(e, {\n"
                        "rx: a,\n"
                        "ry: a\n"
                    "})\n"
                "};\n"
                "return v.attr(a)\n"
            "},\n"
            "setSize: function(a, g, e) {\n"
                "var b = this.alignedObjects,\n"
                "v = b.length;\n"
                "this.width = a;\n"
                "this.height = g;\n"
                "for (this.boxWrapper.animate({\n"
                    "width: a,\n"
                    "height: g\n"
                "},\n"
                "{\n"
                    "step: function() {\n"
                        "this.attr({\n"
                            "viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n"
                        "})\n"
                    "},\n"
                    "duration: K(e, !0) ? void 0 : 0\n"
                "}); v--;) b[v].align()\n"
            "},\n"
            "g: function(a) {\n"
                "var g = this.createElement(\"g\");\n"
                "return a ? g.attr({\n"
                    "\"class\": \"highcharts-\" + a\n"
                "}) : g\n"
            "},\n"
            "image: function(a, g, e, c, m) {\n"
                "var v = {\n"
                    "preserveAspectRatio: \"none\"\n"
                "};\n"
                "1 < arguments.length && b(v, {\n"
                    "x: g,\n"
                    "y: e,\n"
                    "width: c,\n"
                    "height: m\n"
                "});\n"
                "v = this.createElement(\"image\").attr(v);\n"
                "v.element.setAttributeNS ? v.element.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", a) : v.element.setAttribute(\"hc-svg-href\", a);\n"
                "return v\n"
            "},\n"
            "symbol: function(a, g, e, c, m, h) {\n"
                "var v = this,\n"
                "F, x = this.symbols[a],\n"
                "y = u(g) && x && this.symbols[a](Math.round(g), Math.round(e), c, m, h),\n"
                "C = /^url\\((.*?)\\)$/,\n"
                "d,\n"
                "t;\n"
                "x ? (F = this.path(y), F.attr(\"fill\", \"none\"), b(F, {\n"
                    "symbolName: a,\n"
                    "x: g,\n"
                    "y: e,\n"
                    "width: c,\n"
                    "height: m\n"
                "}), h && b(F, h)) : C.test(a) && (d = a.match(C)[1], F = this.image(d), F.imgwidth = K(P[d] && P[d].width, h && h.width), F.imgheight = K(P[d] && P[d].height, h && h.height), t = function() {\n"
                    "F.attr({\n"
                        "width: F.width,\n"
                        "height: F.height\n"
                    "})\n"
                "},\n"
                "z([\"width\", \"height\"],\n"
                "function(a) {\n"
                    "F[a + \"Setter\"] = function(a, g) {\n"
                        "var e = {},\n"
                        "b = this[\"img\" + g],\n"
                        "v = \"width\" === g ? \"translateX\": \"translateY\";\n"
                        "this[g] = a;\n"
                        "u(b) && (this.element && this.element.setAttribute(g, b), this.alignByTranslate || (e[v] = ((this[g] || 0) - b) / 2, this.attr(e)))\n"
                    "}\n"
                "}), u(g) && F.attr({\n"
                    "x: g,\n"
                    "y: e\n"
                "}), F.isImg = !0, u(F.imgwidth) && u(F.imgheight) ? t() : (F.attr({\n"
                    "width: 0,\n"
                    "height: 0\n"
                "}), k(\"img\", {\n"
                    "onload: function() {\n"
                        "var a = f[v.chartIndex];\n"
                        "0 === this.width && (q(this, {\n"
                            "position: \"absolute\",\n"
                            "top: \"-999em\"\n"
                        "}), n.body.appendChild(this));\n"
                        "P[d] = {\n"
                            "width: this.width,\n"
                            "height: this.height\n"
                        "};\n"
                        "F.imgwidth = this.width;\n"
                        "F.imgheight = this.height;\n"
                        "F.element && t();\n"
                        "this.parentNode && this.parentNode.removeChild(this);\n"
                        "v.imgCount--;\n"
                        "if (!v.imgCount && a && a.onload) a.onload()\n"
                    "},\n"
                    "src: d\n"
                "}), this.imgCount++));\n"
                "return F\n"
            "},\n"
            "symbols: {\n"
                "circle: function(a, g, e, b) {\n"
                    "return this.arc(a + e / 2, g + b / 2, e / 2, b / 2, {\n"
                        "start: 0,\n"
                        "end: 2 * Math.PI,\n"
                        "open: !1\n"
                    "})\n"
                "},\n"
                "square: function(a, g, e, b) {\n"
                    "return [\"M\", a, g, \"L\", a + e, g, a + e, g + b, a, g + b, \"Z\"]\n"
                "},\n"
                "triangle: function(a, g, e, b) {\n"
                    "return [\"M\", a + e / 2, g, \"L\", a + e, g + b, a, g + b, \"Z\"]\n"
                "},\n"
                "\"triangle-down\": function(a, g, e, b) {\n"
                    "return [\"M\", a, g, \"L\", a + e, g, a + e / 2, g + b, \"Z\"]\n"
                "},\n"
                "diamond: function(a, g, e, b) {\n"
                    "return [\"M\", a + e / 2, g, \"L\", a + e, g + b / 2, a + e / 2, g + b, a, g + b / 2, \"Z\"]\n"
                "},\n"
                "arc: function(a, g, e, b, c) {\n"
                    "var v = c.start,\n"
                    "m = c.r || e,\n"
                    "h = c.r || b || e,\n"
                    "F = c.end - .001;\n"
                    "e = c.innerR;\n"
                    "b = c.open;\n"
                    "var x = Math.cos(v),\n"
                    "y = Math.sin(v),\n"
                    "C = Math.cos(F),\n"
                    "F = Math.sin(F);\n"
                    "c = c.end - v < Math.PI ? 0 : 1;\n"
                    "m = [\"M\", a + m * x, g + h * y, \"A\", m, h, 0, c, 1, a + m * C, g + h * F];\n"
                    "u(e) && m.push(b ? \"M\": \"L\", a + e * C, g + e * F, \"A\", e, e, 0, c, 0, a + e * x, g + e * y);\n"
                    "m.push(b ? \"\": \"Z\");\n"
                    "return m\n"
                "},\n"
                "callout: function(a, g, e, b, c) {\n"
                    "var m = Math.min(c && c.r || 0, e, b),\n"
                    "h = m + 6,\n"
                    "v = c && c.anchorX;\n"
                    "c = c && c.anchorY;\n"
                    "var F;\n"
                    "F = [\"M\", a + m, g, \"L\", a + e - m, g, \"C\", a + e, g, a + e, g, a + e, g + m, \"L\", a + e, g + b - m, \"C\", a + e, g + b, a + e, g + b, a + e - m, g + b, \"L\", a + m, g + b, \"C\", a, g + b, a, g + b, a, g + b - m, \"L\", a, g + m, \"C\", a, g, a, g, a + m, g];\n"
                    "v && v > e ? c > g + h && c < g + b - h ? F.splice(13, 3, \"L\", a + e, c - 6, a + e + 6, c, a + e, c + 6, a + e, g + b - m) : F.splice(13, 3, \"L\", a + e, b / 2, v, c, a + e, b / 2, a + e, g + b - m) : v && 0 > v ? c > g + h && c < g + b - h ? F.splice(33, 3, \"L\", a, c + 6, a - 6, c, a, c - 6, a, g + m) : F.splice(33, 3, \"L\", a, b / 2, v, c, a, b / 2, a, g + m) : c && c > b && v > a + h && v < a + e - h ? F.splice(23, 3, \"L\", v + 6, g + b, v, g + b + 6, v - 6, g + b, a + m, g + b) : c && 0 > c && v > a + h && v < a + e - h && F.splice(3, 3, \"L\", v - 6, g, v, g - 6, v + 6, g, e - m, g);\n"
                    "return F\n"
                "}\n"
            "},\n"
            "clipRect: function(g, e, b, c) {\n"
                "var m = a.uniqueKey(),\n"
                "h = this.createElement(\"clipPath\").attr({\n"
                    "id: m\n"
                "}).add(this.defs);\n"
                "g = this.rect(g, e, b, c, 0).add(h);\n"
                "g.id = m;\n"
                "g.clipPath = h;\n"
                "g.count = 0;\n"
                "return g\n"
            "},\n"
            "text: function(a, g, e, b) {\n"
                "var c = !Q && this.forExport,\n"
                "m = {};\n"
                "if (b && (this.allowHTML || !this.forExport)) return this.html(a, g, e);\n"
                "m.x = Math.round(g || 0);\n"
                "e && (m.y = Math.round(e));\n"
                "if (a || 0 === a) m.text = a;\n"
                "a = this.createElement(\"text\").attr(m);\n"
                "c && a.css({\n"
                    "position: \"absolute\"\n"
                "});\n"
                "b || (a.xSetter = function(a, g, e) {\n"
                    "var b = e.getElementsByTagName(\"tspan\"),\n"
                    "c,\n"
                    "m = e.getAttribute(g),\n"
                    "h;\n"
                    "for (h = 0; h < b.length; h++) c = b[h],\n"
                    "c.getAttribute(g) === m && c.setAttribute(g, a);\n"
                    "e.setAttribute(g, a)\n"
                "});\n"
                "return a\n"
            "},\n"
            "fontMetrics: function(a, g) {\n"
                "a = a || g && g.style && g.style.fontSize || this.style && this.style.fontSize;\n"
                "a = /px/.test(a) ? J(a) : /em/.test(a) ? parseFloat(a) * (g ? this.fontMetrics(null, g.parentNode).f: 16) : 12;\n"
                "g = 24 > a ? a + 3 : Math.round(1.2 * a);\n"
                "return {\n"
                    "h: g,\n"
                    "b: Math.round(.8 * g),\n"
                    "f: a\n"
                "}\n"
            "},\n"
            "rotCorr: function(a, g, e) {\n"
                "var b = a;\n"
                "g && e && (b = Math.max(b * Math.cos(g * d), 4));\n"
                "return {\n"
                    "x: -a / 3 * Math.sin(g * d),\n"
                    "y: b\n"
                "}\n"
            "},\n"
            "label: function(e, c, m, h, F, x, C, d, t) {\n"
                "var v = this,\n"
                "p = v.g(\"button\" !== t && \"label\"),\n"
                "n = p.text = v.text(\"\", 0, 0, C).attr({\n"
                    "zIndex: 1\n"
                "}),\n"
                "k,\n"
                "w,\n"
                "E = 0,\n"
                "f = 3,\n"
                "D = 0,\n"
                "I,\n"
                "q,\n"
                "l,\n"
                "Q,\n"
                "N,\n"
                "K = {},\n"
                "J,\n"
                "r,\n"
                "M = /^url\\((.*?)\\)$/.test(h),\n"
                "P = M,\n"
                "R,\n"
                "S,\n"
                "O,\n"
                "U;\n"
                "t && p.addClass(\"highcharts-\" + t);\n"
                "P = M;\n"
                "R = function() {\n"
                    "return (J || 0) % 2 / 2\n"
                "};\n"
                "S = function() {\n"
                    "var a = n.element.style,\n"
                    "g = {};\n"
                    "w = (void 0 === I || void 0 === q || N) && u(n.textStr) && n.getBBox();\n"
                    "p.width = (I || w.width || 0) + 2 * f + D;\n"
                    "p.height = (q || w.height || 0) + 2 * f;\n"
                    "r = f + v.fontMetrics(a && a.fontSize, n).b;\n"
                    "P && (k || (p.box = k = v.symbols[h] || M ? v.symbol(h) : v.rect(), k.addClass((\"button\" === t ? \"\": \"highcharts-label-box\") + (t ? \" highcharts-\" + t + \"-box\": \"\")), k.add(p), a = R(), g.x = a, g.y = (d ? -r: 0) + a), g.width = Math.round(p.width), g.height = Math.round(p.height), k.attr(b(g, K)), K = {})\n"
                "};\n"
                "O = function() {\n"
                    "var a = D + f,\n"
                    "g;\n"
                    "g = d ? 0 : r;\n"
                    "u(I) && w && (\"center\" === N || \"right\" === N) && (a += {\n"
                        "center: .5,\n"
                        "right: 1\n"
                    "} [N] * (I - w.width));\n"
                    "if (a !== n.x || g !== n.y) n.attr(\"x\", a),\n"
                    "void 0 !== g && n.attr(\"y\", g);\n"
                    "n.x = a;\n"
                    "n.y = g\n"
                "};\n"
                "U = function(a, g) {\n"
                    "k ? k.attr(a, g) : K[a] = g\n"
                "};\n"
                "p.onAdd = function() {\n"
                    "n.add(p);\n"
                    "p.attr({\n"
                        "text: e || 0 === e ? e: \"\",\n"
                        "x: c,\n"
                        "y: m\n"
                    "});\n"
                    "k && u(F) && p.attr({\n"
                        "anchorX: F,\n"
                        "anchorY: x\n"
                    "})\n"
                "};\n"
                "p.widthSetter = function(g) {\n"
                    "I = a.isNumber(g) ? g: null\n"
                "};\n"
                "p.heightSetter = function(a) {\n"
                    "q = a\n"
                "};\n"
                "p[\"text-alignSetter\"] = function(a) {\n"
                    "N = a\n"
                "};\n"
                "p.paddingSetter = function(a) {\n"
                    "u(a) && a !== f && (f = p.padding = a, O())\n"
                "};\n"
                "p.paddingLeftSetter = function(a) {\n"
                    "u(a) && a !== D && (D = a, O())\n"
                "};\n"
                "p.alignSetter = function(a) {\n"
                    "a = {\n"
                        "left: 0,\n"
                        "center: .5,\n"
                        "right: 1\n"
                    "} [a];\n"
                    "a !== E && (E = a, w && p.attr({\n"
                        "x: l\n"
                    "}))\n"
                "};\n"
                "p.textSetter = function(a) {\n"
                    "void 0 !== a && n.textSetter(a);\n"
                    "S();\n"
                    "O()\n"
                "};\n"
                "p[\"stroke-widthSetter\"] = function(a, g) {\n"
                    "a && (P = !0);\n"
                    "J = this[\"stroke-width\"] = a;\n"
                    "U(g, a)\n"
                "};\n"
                "p.strokeSetter = p.fillSetter = p.rSetter = function(a, g) {\n"
                    "\"fill\" === g && a && (P = !0);\n"
                    "U(g, a)\n"
                "};\n"
                "p.anchorXSetter = function(a, g) {\n"
                    "F = a;\n"
                    "U(g, Math.round(a) - R() - l)\n"
                "};\n"
                "p.anchorYSetter = function(a, g) {\n"
                    "x = a;\n"
                    "U(g, a - Q)\n"
                "};\n"
                "p.xSetter = function(a) {\n"
                    "p.x = a;\n"
                    "E && (a -= E * ((I || w.width) + 2 * f));\n"
                    "l = Math.round(a);\n"
                    "p.attr(\"translateX\", l)\n"
                "};\n"
                "p.ySetter = function(a) {\n"
                    "Q = p.y = Math.round(a);\n"
                    "p.attr(\"translateY\", Q)\n"
                "};\n"
                "var W = p.css;\n"
                "return b(p, {\n"
                    "css: function(a) {\n"
                        "if (a) {\n"
                            "var g = {};\n"
                            "a = y(a);\n"
                            "z(p.textProps,\n"
                            "function(e) {\n"
                                "void 0 !== a[e] && (g[e] = a[e], delete a[e])\n"
                            "});\n"
                            "n.css(g)\n"
                        "}\n"
                        "return W.call(p, a)\n"
                    "},\n"
                    "getBBox: function() {\n"
                        "return {\n"
                            "width: w.width + 2 * f,\n"
                            "height: w.height + 2 * f,\n"
                            "x: w.x - f,\n"
                            "y: w.y - f\n"
                        "}\n"
                    "},\n"
                    "shadow: function(a) {\n"
                        "a && (S(), k && k.shadow(a));\n"
                        "return p\n"
                    "},\n"
                    "destroy: function() {\n"
                        "g(p.element, \"mouseenter\");\n"
                        "g(p.element, \"mouseleave\");\n"
                        "n && (n = n.destroy());\n"
                        "k && (k = k.destroy());\n"
                        "B.prototype.destroy.call(p);\n"
                        "p = v = S = O = U = null\n"
                    "}\n"
                "})\n"
            "}\n"
        "};\n"
        "a.Renderer = A\n"
    "})(L); (function(a) {\n"
        "var B = a.attr,\n"
        "A = a.createElement,\n"
        "H = a.css,\n"
        "G = a.defined,\n"
        "r = a.each,\n"
        "f = a.extend,\n"
        "l = a.isFirefox,\n"
        "q = a.isMS,\n"
        "k = a.isWebKit,\n"
        "u = a.pInt,\n"
        "d = a.SVGRenderer,\n"
        "c = a.win,\n"
        "n = a.wrap;\n"
        "f(a.SVGElement.prototype, {\n"
            "htmlCss: function(a) {\n"
                "var b = this.element;\n"
                "if (b = a && \"SPAN\" === b.tagName && a.width) delete a.width,\n"
                "this.textWidth = b,\n"
                "this.updateTransform();\n"
                "a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n"
                "this.styles = f(this.styles, a);\n"
                "H(this.element, a);\n"
                "return this\n"
            "},\n"
            "htmlGetBBox: function() {\n"
                "var a = this.element;\n"
                "\"text\" === a.nodeName && (a.style.position = \"absolute\");\n"
                "return {\n"
                    "x: a.offsetLeft,\n"
                    "y: a.offsetTop,\n"
                    "width: a.offsetWidth,\n"
                    "height: a.offsetHeight\n"
                "}\n"
            "},\n"
            "htmlUpdateTransform: function() {\n"
                "if (this.added) {\n"
                    "var a = this.renderer,\n"
                    "b = this.element,\n"
                    "c = this.translateX || 0,\n"
                    "h = this.translateY || 0,\n"
                    "d = this.x || 0,\n"
                    "n = this.y || 0,\n"
                    "w = this.textAlign || \"left\",\n"
                    "e = {\n"
                        "left: 0,\n"
                        "center: .5,\n"
                        "right: 1\n"
                    "} [w],\n"
                    "x = this.styles;\n"
                    "H(b, {\n"
                        "marginLeft: c,\n"
                        "marginTop: h\n"
                    "});\n"
                    "this.shadows && r(this.shadows,\n"
                    "function(a) {\n"
                        "H(a, {\n"
                            "marginLeft: c + 1,\n"
                            "marginTop: h + 1\n"
                        "})\n"
                    "});\n"
                    "this.inverted && r(b.childNodes,\n"
                    "function(e) {\n"
                        "a.invertChild(e, b)\n"
                    "});\n"
                    "if (\"SPAN\" === b.tagName) {\n"
                        "var C = this.rotation,\n"
                        "f = u(this.textWidth),\n"
                        "m = x && x.whiteSpace,\n"
                        "y = [C, w, b.innerHTML, this.textWidth, this.textAlign].join();\n"
                        "y !== this.cTT && (x = a.fontMetrics(b.style.fontSize).b, G(C) && this.setSpanRotation(C, e, x), H(b, {\n"
                            "width: \"\",\n"
                            "whiteSpace: m || \"nowrap\"\n"
                        "}), b.offsetWidth > f && /[ \\-]/.test(b.textContent || b.innerText) && H(b, {\n"
                            "width: f + \"px\",\n"
                            "display: \"block\",\n"
                            "whiteSpace: m || \"normal\"\n"
                        "}), this.getSpanCorrection(b.offsetWidth, x, e, C, w));\n"
                        "H(b, {\n"
                            "left: d + (this.xCorr || 0) + \"px\",\n"
                            "top: n + (this.yCorr || 0) + \"px\"\n"
                        "});\n"
                        "k && (x = b.offsetHeight);\n"
                        "this.cTT = y\n"
                    "}\n"
                "} else this.alignOnAdd = !0\n"
            "},\n"
            "setSpanRotation: function(a, b, p) {\n"
                "var h = {},\n"
                "d = q ? \"-ms-transform\": k ? \"-webkit-transform\": l ? \"MozTransform\": c.opera ? \"-o-transform\": \"\";\n"
                "h[d] = h.transform = \"rotate(\" + a + \"deg)\";\n"
                "h[d + (l ? \"Origin\": \"-origin\")] = h.transformOrigin = 100 * b + \"% \" + p + \"px\";\n"
                "H(this.element, h)\n"
            "},\n"
            "getSpanCorrection: function(a, b, c) {\n"
                "this.xCorr = -a * c;\n"
                "this.yCorr = -b\n"
            "}\n"
        "});\n"
        "f(d.prototype, {\n"
            "html: function(a, b, c) {\n"
                "var h = this.createElement(\"span\"),\n"
                "d = h.element,\n"
                "p = h.renderer,\n"
                "k = p.isSVG,\n"
                "e = function(a, e) {\n"
                    "r([\"opacity\", \"visibility\"],\n"
                    "function(b) {\n"
                        "n(a, b + \"Setter\",\n"
                        "function(a, b, c, h) {\n"
                            "a.call(this, b, c, h);\n"
                            "e[c] = b\n"
                        "})\n"
                    "})\n"
                "};\n"
                "h.textSetter = function(a) {\n"
                    "a !== d.innerHTML && delete this.bBox;\n"
                    "d.innerHTML = this.textStr = a;\n"
                    "h.htmlUpdateTransform()\n"
                "};\n"
                "k && e(h, h.element.style);\n"
                "h.xSetter = h.ySetter = h.alignSetter = h.rotationSetter = function(a, e) {\n"
                    "\"align\" === e && (e = \"textAlign\");\n"
                    "h[e] = a;\n"
                    "h.htmlUpdateTransform()\n"
                "};\n"
                "h.attr({\n"
                    "text: a,\n"
                    "x: Math.round(b),\n"
                    "y: Math.round(c)\n"
                "}).css({\n"
                    "fontFamily: this.style.fontFamily,\n"
                    "fontSize: this.style.fontSize,\n"
                    "position: \"absolute\"\n"
                "});\n"
                "d.style.whiteSpace = \"nowrap\";\n"
                "h.css = h.htmlCss;\n"
                "k && (h.add = function(a) {\n"
                    "var b, c = p.box.parentNode,\n"
                    "m = [];\n"
                    "if (this.parentGroup = a) {\n"
                        "if (b = a.div, !b) {\n"
                            "for (; a;) m.push(a),\n"
                            "a = a.parentGroup;\n"
                            "r(m.reverse(),\n"
                            "function(a) {\n"
                                "var x, d = B(a.element, \"class\");\n"
                                "d && (d = {\n"
                                    "className: d\n"
                                "});\n"
                                "b = a.div = a.div || A(\"div\", d, {\n"
                                    "position: \"absolute\",\n"
                                    "left: (a.translateX || 0) + \"px\",\n"
                                    "top: (a.translateY || 0) + \"px\",\n"
                                    "display: a.display,\n"
                                    "opacity: a.opacity,\n"
                                    "pointerEvents: a.styles && a.styles.pointerEvents\n"
                                "},\n"
                                "b || c);\n"
                                "x = b.style;\n"
                                "f(a, {\n"
                                    "on: function() {\n"
                                        "h.on.apply({\n"
                                            "element: m[0].div\n"
                                        "},\n"
                                        "arguments);\n"
                                        "return a\n"
                                    "},\n"
                                    "translateXSetter: function(e, g) {\n"
                                        "x.left = e + \"px\";\n"
                                        "a[g] = e;\n"
                                        "a.doTransform = !0\n"
                                    "},\n"
                                    "translateYSetter: function(e, g) {\n"
                                        "x.top = e + \"px\";\n"
                                        "a[g] = e;\n"
                                        "a.doTransform = !0\n"
                                    "}\n"
                                "});\n"
                                "e(a, x)\n"
                            "})\n"
                        "}\n"
                    "} else b = c;\n"
                    "b.appendChild(d);\n"
                    "h.added = !0;\n"
                    "h.alignOnAdd && h.htmlUpdateTransform();\n"
                    "return h\n"
                "});\n"
                "return h\n"
            "}\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B, A, H = a.createElement,\n"
        "G = a.css,\n"
        "r = a.defined,\n"
        "f = a.deg2rad,\n"
        "l = a.discardElement,\n"
        "q = a.doc,\n"
        "k = a.each,\n"
        "u = a.erase,\n"
        "d = a.extend;\n"
        "B = a.extendClass;\n"
        "var c = a.isArray,\n"
        "n = a.isNumber,\n"
        "z = a.isObject,\n"
        "b = a.merge;\n"
        "A = a.noop;\n"
        "var p = a.pick,\n"
        "h = a.pInt,\n"
        "t = a.SVGElement,\n"
        "D = a.SVGRenderer,\n"
        "w = a.win;\n"
        "a.svg || (A = {\n"
            "docMode8: q && 8 === q.documentMode,\n"
            "init: function(a, b) {\n"
                "var e = [\"\\x3c\", b, ' filled\\x3d\"f\" stroked\\x3d\"f\"'],\n"
                "c = [\"position: \", \"absolute\", \";\"],\n"
                "m = \"div\" === b; (\"shape\" === b || m) && c.push(\"left:0;top:0;width:1px;height:1px;\");\n"
                "c.push(\"visibility: \", m ? \"hidden\": \"visible\");\n"
                "e.push(' style\\x3d\"', c.join(\"\"), '\"/\\x3e');\n"
                "b && (e = m || \"span\" === b || \"img\" === b ? e.join(\"\") : a.prepVML(e), this.element = H(e));\n"
                "this.renderer = a\n"
            "},\n"
            "add: function(a) {\n"
                "var e = this.renderer,\n"
                "b = this.element,\n"
                "c = e.box,\n"
                "m = a && a.inverted,\n"
                "c = a ? a.element || a: c;\n"
                "a && (this.parentGroup = a);\n"
                "m && e.invertChild(b, c);\n"
                "c.appendChild(b);\n"
                "this.added = !0;\n"
                "this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform();\n"
                "if (this.onAdd) this.onAdd();\n"
                "this.className && this.attr(\"class\", this.className);\n"
                "return this\n"
            "},\n"
            "updateTransform: t.prototype.htmlUpdateTransform,\n"
            "setSpanRotation: function() {\n"
                "var a = this.rotation,\n"
                "b = Math.cos(a * f),\n"
                "c = Math.sin(a * f);\n"
                "G(this.element, {\n"
                    "filter: a ? [\"progid:DXImageTransform.Microsoft.Matrix(M11\\x3d\", b, \", M12\\x3d\", -c, \", M21\\x3d\", c, \", M22\\x3d\", b, \", sizingMethod\\x3d'auto expand')\"].join(\"\") : \"none\"\n"
                "})\n"
            "},\n"
            "getSpanCorrection: function(a, b, c, h, m) {\n"
                "var e = h ? Math.cos(h * f) : 1,\n"
                "x = h ? Math.sin(h * f) : 0,\n"
                "d = p(this.elemHeight, this.element.offsetHeight),\n"
                "t;\n"
                "this.xCorr = 0 > e && -a;\n"
                "this.yCorr = 0 > x && -d;\n"
                "t = 0 > e * x;\n"
                "this.xCorr += x * b * (t ? 1 - c: c);\n"
                "this.yCorr -= e * b * (h ? t ? c: 1 - c: 1);\n"
                "m && \"left\" !== m && (this.xCorr -= a * c * (0 > e ? -1 : 1), h && (this.yCorr -= d * c * (0 > x ? -1 : 1)), G(this.element, {\n"
                    "textAlign: m\n"
                "}))\n"
            "},\n"
            "pathToVML: function(a) {\n"
                "for (var e = a.length,\n"
                "b = []; e--;) n(a[e]) ? b[e] = Math.round(10 * a[e]) - 5 : \"Z\" === a[e] ? b[e] = \"x\": (b[e] = a[e], !a.isArc || \"wa\" !== a[e] && \"at\" !== a[e] || (b[e + 5] === b[e + 7] && (b[e + 7] += a[e + 7] > a[e + 5] ? 1 : -1), b[e + 6] === b[e + 8] && (b[e + 8] += a[e + 8] > a[e + 6] ? 1 : -1)));\n"
                "return b.join(\" \") || \"x\"\n"
            "},\n"
            "clip: function(a) {\n"
                "var e = this,\n"
                "b;\n"
                "a ? (b = a.members, u(b, e), b.push(e), e.destroyClip = function() {\n"
                    "u(b, e)\n"
                "},\n"
                "a = a.getCSS(e)) : (e.destroyClip && e.destroyClip(), a = {\n"
                    "clip: e.docMode8 ? \"inherit\": \"rect(auto)\"\n"
                "});\n"
                "return e.css(a)\n"
            "},\n"
            "css: t.prototype.htmlCss,\n"
            "safeRemoveChild: function(a) {\n"
                "a.parentNode && l(a)\n"
            "},\n"
            "destroy: function() {\n"
                "this.destroyClip && this.destroyClip();\n"
                "return t.prototype.destroy.apply(this)\n"
            "},\n"
            "on: function(a, b) {\n"
                "this.element[\"on\" + a] = function() {\n"
                    "var a = w.event;\n"
                    "a.target = a.srcElement;\n"
                    "b(a)\n"
                "};\n"
                "return this\n"
            "},\n"
            "cutOffPath: function(a, b) {\n"
                "var e;\n"
                "a = a.split(/[ ,]/);\n"
                "e = a.length;\n"
                "if (9 === e || 11 === e) a[e - 4] = a[e - 2] = h(a[e - 2]) - 10 * b;\n"
                "return a.join(\" \")\n"
            "},\n"
            "shadow: function(a, b, c) {\n"
                "var e = [],\n"
                "m,\n"
                "d = this.element,\n"
                "t = this.renderer,\n"
                "x,\n"
                "n = d.style,\n"
                "g,\n"
                "F = d.path,\n"
                "k,\n"
                "C,\n"
                "w,\n"
                "f;\n"
                "F && \"string\" !== typeof F.value && (F = \"x\");\n"
                "C = F;\n"
                "if (a) {\n"
                    "w = p(a.width, 3);\n"
                    "f = (a.opacity || .15) / w;\n"
                    "for (m = 1; 3 >= m; m++) k = 2 * w + 1 - 2 * m,\n"
                    "c && (C = this.cutOffPath(F.value, k + .5)),\n"
                    "g = ['\\x3cshape isShadow\\x3d\"true\" strokeweight\\x3d\"', k, '\" filled\\x3d\"false\" path\\x3d\"', C, '\" coordsize\\x3d\"10 10\" style\\x3d\"', d.style.cssText, '\" /\\x3e'],\n"
                    "x = H(t.prepVML(g), null, {\n"
                        "left: h(n.left) + p(a.offsetX, 1),\n"
                        "top: h(n.top) + p(a.offsetY, 1)\n"
                    "}),\n"
                    "c && (x.cutOff = k + 1),\n"
                    "g = ['\\x3cstroke color\\x3d\"', a.color || \"#000000\", '\" opacity\\x3d\"', f * m, '\"/\\x3e'],\n"
                    "H(t.prepVML(g), null, null, x),\n"
                    "b ? b.element.appendChild(x) : d.parentNode.insertBefore(x, d),\n"
                    "e.push(x);\n"
                    "this.shadows = e\n"
                "}\n"
                "return this\n"
            "},\n"
            "updateShadows: A,\n"
            "setAttr: function(a, b) {\n"
                "this.docMode8 ? this.element[a] = b: this.element.setAttribute(a, b)\n"
            "},\n"
            "classSetter: function(a) { (this.added ? this.element: this).className = a\n"
            "},\n"
            "dashstyleSetter: function(a, b, c) { (c.getElementsByTagName(\"stroke\")[0] || H(this.renderer.prepVML([\"\\x3cstroke/\\x3e\"]), null, null, c))[b] = a || \"solid\";\n"
                "this[b] = a\n"
            "},\n"
            "dSetter: function(a, b, c) {\n"
                "var e = this.shadows;\n"
                "a = a || [];\n"
                "this.d = a.join && a.join(\" \");\n"
                "c.path = a = this.pathToVML(a);\n"
                "if (e) for (c = e.length; c--;) e[c].path = e[c].cutOff ? this.cutOffPath(a, e[c].cutOff) : a;\n"
                "this.setAttr(b, a)\n"
            "},\n"
            "fillSetter: function(a, b, c) {\n"
                "var e = c.nodeName;\n"
                "\"SPAN\" === e ? c.style.color = a: \"IMG\" !== e && (c.filled = \"none\" !== a, this.setAttr(\"fillcolor\", this.renderer.color(a, c, b, this)))\n"
            "},\n"
            "\"fill-opacitySetter\": function(a, b, c) {\n"
                "H(this.renderer.prepVML([\"\\x3c\", b.split(\"-\")[0], ' opacity\\x3d\"', a, '\"/\\x3e']), null, null, c)\n"
            "},\n"
            "opacitySetter: A,\n"
            "rotationSetter: function(a, b, c) {\n"
                "c = c.style;\n"
                "this[b] = c[b] = a;\n"
                "c.left = -Math.round(Math.sin(a * f) + 1) + \"px\";\n"
                "c.top = Math.round(Math.cos(a * f)) + \"px\"\n"
            "},\n"
            "strokeSetter: function(a, b, c) {\n"
                "this.setAttr(\"strokecolor\", this.renderer.color(a, c, b, this))\n"
            "},\n"
            "\"stroke-widthSetter\": function(a, b, c) {\n"
                "c.stroked = !!a;\n"
                "this[b] = a;\n"
                "n(a) && (a += \"px\");\n"
                "this.setAttr(\"strokeweight\", a)\n"
            "},\n"
            "titleSetter: function(a, b) {\n"
                "this.setAttr(b, a)\n"
            "},\n"
            "visibilitySetter: function(a, b, c) {\n"
                "\"inherit\" === a && (a = \"visible\");\n"
                "this.shadows && k(this.shadows,\n"
                "function(e) {\n"
                    "e.style[b] = a\n"
                "});\n"
                "\"DIV\" === c.nodeName && (a = \"hidden\" === a ? \"-999em\": 0, this.docMode8 || (c.style[b] = a ? \"visible\": \"hidden\"), b = \"top\");\n"
                "c.style[b] = a\n"
            "},\n"
            "xSetter: function(a, b, c) {\n"
                "this[b] = a;\n"
                "\"x\" === b ? b = \"left\": \"y\" === b && (b = \"top\");\n"
                "this.updateClipping ? (this[b] = a, this.updateClipping()) : c.style[b] = a\n"
            "},\n"
            "zIndexSetter: function(a, b, c) {\n"
                "c.style[b] = a\n"
            "}\n"
        "},\n"
        "A[\"stroke-opacitySetter\"] = A[\"fill-opacitySetter\"], a.VMLElement = A = B(t, A), A.prototype.ySetter = A.prototype.widthSetter = A.prototype.heightSetter = A.prototype.xSetter, A = {\n"
            "Element: A,\n"
            "isIE8: -1 < w.navigator.userAgent.indexOf(\"MSIE 8.0\"),\n"
            "init: function(a, b, c) {\n"
                "var e, m;\n"
                "this.alignedObjects = [];\n"
                "e = this.createElement(\"div\").css({\n"
                    "position: \"relative\"\n"
                "});\n"
                "m = e.element;\n"
                "a.appendChild(e.element);\n"
                "this.isVML = !0;\n"
                "this.box = m;\n"
                "this.boxWrapper = e;\n"
                "this.gradients = {};\n"
                "this.cache = {};\n"
                "this.cacheKeys = [];\n"
                "this.imgCount = 0;\n"
                "this.setSize(b, c, !1);\n"
                "if (!q.namespaces.hcv) {\n"
                    "q.namespaces.add(\"hcv\", \"urn:schemas-microsoft-com:vml\");\n"
                    "try {\n"
                        "q.createStyleSheet().cssText = \"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } \"\n"
                    "} catch(y) {\n"
                        "q.styleSheets[0].cssText += \"hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke{ behavior:url(#default#VML); display: inline-block; } \"\n"
                    "}\n"
                "}\n"
            "},\n"
            "isHidden: function() {\n"
                "return ! this.box.offsetWidth\n"
            "},\n"
            "clipRect: function(a, b, c, h) {\n"
                "var e = this.createElement(),\n"
                "p = z(a);\n"
                "return d(e, {\n"
                    "members: [],\n"
                    "count: 0,\n"
                    "left: (p ? a.x: a) + 1,\n"
                    "top: (p ? a.y: b) + 1,\n"
                    "width: (p ? a.width: c) - 1,\n"
                    "height: (p ? a.height: h) - 1,\n"
                    "getCSS: function(a) {\n"
                        "var b = a.element,\n"
                        "c = b.nodeName,\n"
                        "g = a.inverted,\n"
                        "e = this.top - (\"shape\" === c ? b.offsetTop: 0),\n"
                        "m = this.left,\n"
                        "b = m + this.width,\n"
                        "h = e + this.height,\n"
                        "e = {\n"
                            "clip: \"rect(\" + Math.round(g ? m: e) + \"px,\" + Math.round(g ? h: b) + \"px,\" + Math.round(g ? b: h) + \"px,\" + Math.round(g ? e: m) + \"px)\"\n"
                        "}; ! g && a.docMode8 && \"DIV\" === c && d(e, {\n"
                            "width: b + \"px\",\n"
                            "height: h + \"px\"\n"
                        "});\n"
                        "return e\n"
                    "},\n"
                    "updateClipping: function() {\n"
                        "k(e.members,\n"
                        "function(a) {\n"
                            "a.element && a.css(e.getCSS(a))\n"
                        "})\n"
                    "}\n"
                "})\n"
            "},\n"
            "color: function(b, c, h, d) {\n"
                "var e = this,\n"
                "p, t = /^rgba/,\n"
                "n, x, g = \"none\";\n"
                "b && b.linearGradient ? x = \"gradient\": b && b.radialGradient && (x = \"pattern\");\n"
                "if (x) {\n"
                    "var F, w, f = b.linearGradient || b.radialGradient,\n"
                    "C, u, v, D, q, l = \"\";\n"
                    "b = b.stops;\n"
                    "var z, E = [],\n"
                    "r = function() {\n"
                        "n = ['\\x3cfill colors\\x3d\"' + E.join(\",\") + '\" opacity\\x3d\"', v, '\" o:opacity2\\x3d\"', u, '\" type\\x3d\"', x, '\" ', l, 'focus\\x3d\"100%\" method\\x3d\"any\" /\\x3e'];\n"
                        "H(e.prepVML(n), null, null, c)\n"
                    "};\n"
                    "C = b[0];\n"
                    "z = b[b.length - 1];\n"
                    "0 < C[0] && b.unshift([0, C[1]]);\n"
                    "1 > z[0] && b.push([1, z[1]]);\n"
                    "k(b,\n"
                    "function(g, b) {\n"
                        "t.test(g[1]) ? (p = a.color(g[1]), F = p.get(\"rgb\"), w = p.get(\"a\")) : (F = g[1], w = 1);\n"
                        "E.push(100 * g[0] + \"% \" + F);\n"
                        "b ? (v = w, D = F) : (u = w, q = F)\n"
                    "});\n"
                    "if (\"fill\" === h) if (\"gradient\" === x) h = f.x1 || f[0] || 0,\n"
                    "b = f.y1 || f[1] || 0,\n"
                    "C = f.x2 || f[2] || 0,\n"
                    "f = f.y2 || f[3] || 0,\n"
                    "l = 'angle\\x3d\"' + (90 - 180 * Math.atan((f - b) / (C - h)) / Math.PI) + '\"',\n"
                    "r();\n"
                    "else {\n"
                        "var g = f.r,\n"
                        "A = 2 * g,\n"
                        "B = 2 * g,\n"
                        "G = f.cx,\n"
                        "V = f.cy,\n"
                        "L = c.radialReference,\n"
                        "T, g = function() {\n"
                            "L && (T = d.getBBox(), G += (L[0] - T.x) / T.width - .5, V += (L[1] - T.y) / T.height - .5, A *= L[2] / T.width, B *= L[2] / T.height);\n"
                            "l = 'src\\x3d\"' + a.getOptions().global.VMLRadialGradientURL + '\" size\\x3d\"' + A + \",\" + B + '\" origin\\x3d\"0.5,0.5\" position\\x3d\"' + G + \",\" + V + '\" color2\\x3d\"' + q + '\" ';\n"
                            "r()\n"
                        "};\n"
                        "d.added ? g() : d.onAdd = g;\n"
                        "g = D\n"
                    "} else g = F\n"
                "} else t.test(b) && \"IMG\" !== c.tagName ? (p = a.color(b), d[h + \"-opacitySetter\"](p.get(\"a\"), h, c), g = p.get(\"rgb\")) : (g = c.getElementsByTagName(h), g.length && (g[0].opacity = 1, g[0].type = \"solid\"), g = b);\n"
                "return g\n"
            "},\n"
            "prepVML: function(a) {\n"
                "var b = this.isIE8;\n"
                "a = a.join(\"\");\n"
                "b ? (a = a.replace(\"/\\x3e\", ' xmlns\\x3d\"urn:schemas-microsoft-com:vml\" /\\x3e'), a = -1 === a.indexOf('style\\x3d\"') ? a.replace(\"/\\x3e\", ' style\\x3d\"display:inline-block;behavior:url(#default#VML);\" /\\x3e') : a.replace('style\\x3d\"', 'style\\x3d\"display:inline-block;behavior:url(#default#VML);')) : a = a.replace(\"\\x3c\", \"\\x3chcv:\");\n"
                "return a\n"
            "},\n"
            "text: D.prototype.html,\n"
            "path: function(a) {\n"
                "var b = {\n"
                    "coordsize: \"10 10\"\n"
                "};\n"
                "c(a) ? b.d = a: z(a) && d(b, a);\n"
                "return this.createElement(\"shape\").attr(b)\n"
            "},\n"
            "circle: function(a, b, c) {\n"
                "var e = this.symbol(\"circle\");\n"
                "z(a) && (c = a.r, b = a.y, a = a.x);\n"
                "e.isCircle = !0;\n"
                "e.r = c;\n"
                "return e.attr({\n"
                    "x: a,\n"
                    "y: b\n"
                "})\n"
            "},\n"
            "g: function(a) {\n"
                "var b;\n"
                "a && (b = {\n"
                    "className: \"highcharts-\" + a,\n"
                    "\"class\": \"highcharts-\" + a\n"
                "});\n"
                "return this.createElement(\"div\").attr(b)\n"
            "},\n"
            "image: function(a, b, c, h, m) {\n"
                "var e = this.createElement(\"img\").attr({\n"
                    "src: a\n"
                "});\n"
                "1 < arguments.length && e.attr({\n"
                    "x: b,\n"
                    "y: c,\n"
                    "width: h,\n"
                    "height: m\n"
                "});\n"
                "return e\n"
            "},\n"
            "createElement: function(a) {\n"
                "return \"rect\" === a ? this.symbol(a) : D.prototype.createElement.call(this, a)\n"
            "},\n"
            "invertChild: function(a, b) {\n"
                "var c = this;\n"
                "b = b.style;\n"
                "var e = \"IMG\" === a.tagName && a.style;\n"
                "G(a, {\n"
                    "flip: \"x\",\n"
                    "left: h(b.width) - (e ? h(e.top) : 1),\n"
                    "top: h(b.height) - (e ? h(e.left) : 1),\n"
                    "rotation: -90\n"
                "});\n"
                "k(a.childNodes,\n"
                "function(b) {\n"
                    "c.invertChild(b, a)\n"
                "})\n"
            "},\n"
            "symbols: {\n"
                "arc: function(a, b, c, h, m) {\n"
                    "var e = m.start,\n"
                    "d = m.end,\n"
                    "p = m.r || c || h;\n"
                    "c = m.innerR;\n"
                    "h = Math.cos(e);\n"
                    "var t = Math.sin(e),\n"
                    "g = Math.cos(d),\n"
                    "F = Math.sin(d);\n"
                    "if (0 === d - e) return [\"x\"];\n"
                    "e = [\"wa\", a - p, b - p, a + p, b + p, a + p * h, b + p * t, a + p * g, b + p * F];\n"
                    "m.open && !c && e.push(\"e\", \"M\", a, b);\n"
                    "e.push(\"at\", a - c, b - c, a + c, b + c, a + c * g, b + c * F, a + c * h, b + c * t, \"x\", \"e\");\n"
                    "e.isArc = !0;\n"
                    "return e\n"
                "},\n"
                "circle: function(a, b, c, h, m) {\n"
                    "m && r(m.r) && (c = h = 2 * m.r);\n"
                    "m && m.isCircle && (a -= c / 2, b -= h / 2);\n"
                    "return [\"wa\", a, b, a + c, b + h, a + c, b + h / 2, a + c, b + h / 2, \"e\"]\n"
                "},\n"
                "rect: function(a, b, c, h, m) {\n"
                    "return D.prototype.symbols[r(m) && m.r ? \"callout\": \"square\"].call(0, a, b, c, h, m)\n"
                "}\n"
            "}\n"
        "},\n"
        "a.VMLRenderer = B = function() {\n"
            "this.init.apply(this, arguments)\n"
        "},\n"
        "B.prototype = b(D.prototype, A), a.Renderer = B);\n"
        "D.prototype.measureSpanWidth = function(a, b) {\n"
            "var c = q.createElement(\"span\");\n"
            "a = q.createTextNode(a);\n"
            "c.appendChild(a);\n"
            "G(c, b);\n"
            "this.box.appendChild(c);\n"
            "b = c.offsetWidth;\n"
            "l(c);\n"
            "return b\n"
        "}\n"
    "})(L); (function(a) {\n"
        "function B() {\n"
            "var k = a.defaultOptions.global,\n"
            "f = q.moment;\n"
            "if (k.timezone) {\n"
                "if (f) return function(a) {\n"
                    "return - f.tz(a, k.timezone).utcOffset()\n"
                "};\n"
                "a.error(25)\n"
            "}\n"
            "return k.useUTC && k.getTimezoneOffset\n"
        "}\n"
        "function A() {\n"
            "var k = a.defaultOptions.global,\n"
            "f, d = k.useUTC,\n"
            "c = d ? \"getUTC\": \"get\",\n"
            "n = d ? \"setUTC\": \"set\";\n"
            "a.Date = f = k.Date || q.Date;\n"
            "f.hcTimezoneOffset = d && k.timezoneOffset;\n"
            "f.hcGetTimezoneOffset = B();\n"
            "f.hcMakeTime = function(a, b, c, h, t, n) {\n"
                "var p;\n"
                "d ? (p = f.UTC.apply(0, arguments), p += r(p)) : p = (new f(a, b, l(c, 1), l(h, 0), l(t, 0), l(n, 0))).getTime();\n"
                "return p\n"
            "};\n"
            "G(\"Minutes Hours Day Date Month FullYear\".split(\" \"),\n"
            "function(a) {\n"
                "f[\"hcGet\" + a] = c + a\n"
            "});\n"
            "G(\"Milliseconds Seconds Minutes Hours Date Month FullYear\".split(\" \"),\n"
            "function(a) {\n"
                "f[\"hcSet\" + a] = n + a\n"
            "})\n"
        "}\n"
        "var H = a.color,\n"
        "G = a.each,\n"
        "r = a.getTZOffset,\n"
        "f = a.merge,\n"
        "l = a.pick,\n"
        "q = a.win;\n"
        "a.defaultOptions = {\n"
            "colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n"
            "symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n"
            "lang: {\n"
                "loading: \"Loading...\",\n"
                "months: \"January February March April May June July August September October November December\".split(\" \"),\n"
                "shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n"
                "weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n"
                "decimalPoint: \".\",\n"
                "numericSymbols: \"kMGTPE\".split(\"\"),\n"
                "resetZoom: \"Reset zoom\",\n"
                "resetZoomTitle: \"Reset zoom level 1:1\",\n"
                "thousandsSep: \" \"\n"
            "},\n"
            "global: {\n"
                "useUTC: !0,\n"
                "VMLRadialGradientURL: \"http://code.highcharts.com/5.0.10/gfx/vml-radial-gradient.png\"\n"
            "},\n"
            "chart: {\n"
                "borderRadius: 0,\n"
                "defaultSeriesType: \"line\",\n"
                "ignoreHiddenSeries: !0,\n"
                "spacing: [10, 10, 15, 10],\n"
                "resetZoomButton: {\n"
                    "theme: {\n"
                        "zIndex: 20\n"
                    "},\n"
                    "position: {\n"
                        "align: \"right\",\n"
                        "x: -10,\n"
                        "y: 10\n"
                    "}\n"
                "},\n"
                "width: null,\n"
                "height: null,\n"
                "borderColor: \"#335cad\",\n"
                "backgroundColor: \"#ffffff\",\n"
                "plotBorderColor: \"#cccccc\"\n"
            "},\n"
            "title: {\n"
                "text: \"Chart title\",\n"
                "align: \"center\",\n"
                "margin: 15,\n"
                "widthAdjust: -44\n"
            "},\n"
            "subtitle: {\n"
                "text: \"\",\n"
                "align: \"center\",\n"
                "widthAdjust: -44\n"
            "},\n"
            "plotOptions: {},\n"
            "labels: {\n"
                "style: {\n"
                    "position: \"absolute\",\n"
                    "color: \"#333333\"\n"
                "}\n"
            "},\n"
            "legend: {\n"
                "enabled: !0,\n"
                "align: \"center\",\n"
                "layout: \"horizontal\",\n"
                "labelFormatter: function() {\n"
                    "return this.name\n"
                "},\n"
                "borderColor: \"#999999\",\n"
                "borderRadius: 0,\n"
                "navigation: {\n"
                    "activeColor: \"#003399\",\n"
                    "inactiveColor: \"#cccccc\"\n"
                "},\n"
                "itemStyle: {\n"
                    "color: \"#333333\",\n"
                    "fontSize: \"12px\",\n"
                    "fontWeight: \"bold\"\n"
                "},\n"
                "itemHoverStyle: {\n"
                    "color: \"#000000\"\n"
                "},\n"
                "itemHiddenStyle: {\n"
                    "color: \"#cccccc\"\n"
                "},\n"
                "shadow: !1,\n"
                "itemCheckboxStyle: {\n"
                    "position: \"absolute\",\n"
                    "width: \"13px\",\n"
                    "height: \"13px\"\n"
                "},\n"
                "squareSymbol: !0,\n"
                "symbolPadding: 5,\n"
                "verticalAlign: \"bottom\",\n"
                "x: 0,\n"
                "y: 0,\n"
                "title: {\n"
                    "style: {\n"
                        "fontWeight: \"bold\"\n"
                    "}\n"
                "}\n"
            "},\n"
            "loading: {\n"
                "labelStyle: {\n"
                    "fontWeight: \"bold\",\n"
                    "position: \"relative\",\n"
                    "top: \"45%\"\n"
                "},\n"
                "style: {\n"
                    "position: \"absolute\",\n"
                    "backgroundColor: \"#ffffff\",\n"
                    "opacity: .5,\n"
                    "textAlign: \"center\"\n"
                "}\n"
            "},\n"
            "tooltip: {\n"
                "enabled: !0,\n"
                "animation: a.svg,\n"
                "borderRadius: 3,\n"
                "dateTimeLabelFormats: {\n"
                    "millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n"
                    "second: \"%A, %b %e, %H:%M:%S\",\n"
                    "minute: \"%A, %b %e, %H:%M\",\n"
                    "hour: \"%A, %b %e, %H:%M\",\n"
                    "day: \"%A, %b %e, %Y\",\n"
                    "week: \"Week from %A, %b %e, %Y\",\n"
                    "month: \"%B %Y\",\n"
                    "year: \"%Y\"\n"
                "},\n"
                "footerFormat: \"\",\n"
                "padding: 8,\n"
                "snap: a.isTouchDevice ? 25 : 10,\n"
                "backgroundColor: H(\"#f7f7f7\").setOpacity(.85).get(),\n"
                "borderWidth: 1,\n"
                "headerFormat: '\\x3cspan style\\x3d\"font-size: 10px\"\\x3e{point.key}\\x3c/span\\x3e\\x3cbr/\\x3e',\n"
                "pointFormat: '\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e {series.name}: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e',\n"
                "shadow: !0,\n"
                "style: {\n"
                    "color: \"#333333\",\n"
                    "cursor: \"default\",\n"
                    "fontSize: \"12px\",\n"
                    "pointerEvents: \"none\",\n"
                    "whiteSpace: \"nowrap\"\n"
                "}\n"
            "},\n"
            "credits: {\n"
                "enabled: !0,\n"
                "href: \"http://www.highcharts.com\",\n"
                "position: {\n"
                    "align: \"right\",\n"
                    "x: -10,\n"
                    "verticalAlign: \"bottom\",\n"
                    "y: -5\n"
                "},\n"
                "style: {\n"
                    "cursor: \"pointer\",\n"
                    "color: \"#999999\",\n"
                    "fontSize: \"9px\"\n"
                "},\n"
                "text: \"Highcharts.com\"\n"
            "}\n"
        "};\n"
        "a.setOptions = function(k) {\n"
            "a.defaultOptions = f(!0, a.defaultOptions, k);\n"
            "A();\n"
            "return a.defaultOptions\n"
        "};\n"
        "a.getOptions = function() {\n"
            "return a.defaultOptions\n"
        "};\n"
        "a.defaultPlotOptions = a.defaultOptions.plotOptions;\n"
        "A()\n"
    "})(L); (function(a) {\n"
        "var B = a.arrayMax,\n"
        "A = a.arrayMin,\n"
        "H = a.defined,\n"
        "G = a.destroyObjectProperties,\n"
        "r = a.each,\n"
        "f = a.erase,\n"
        "l = a.merge,\n"
        "q = a.pick;\n"
        "a.PlotLineOrBand = function(a, f) {\n"
            "this.axis = a;\n"
            "f && (this.options = f, this.id = f.id)\n"
        "};\n"
        "a.PlotLineOrBand.prototype = {\n"
            "render: function() {\n"
                "var a = this,\n"
                "f = a.axis,\n"
                "d = f.horiz,\n"
                "c = a.options,\n"
                "n = c.label,\n"
                "z = a.label,\n"
                "b = c.to,\n"
                "p = c.from,\n"
                "h = c.value,\n"
                "t = H(p) && H(b),\n"
                "D = H(h),\n"
                "w = a.svgElem,\n"
                "e = !w,\n"
                "x = [],\n"
                "C,\n"
                "E = c.color,\n"
                "m = q(c.zIndex, 0),\n"
                "y = c.events,\n"
                "x = {\n"
                    "\"class\": \"highcharts-plot-\" + (t ? \"band \": \"line \") + (c.className || \"\")\n"
                "},\n"
                "I = {},\n"
                "r = f.chart.renderer,\n"
                "J = t ? \"bands\": \"lines\",\n"
                "g = f.log2lin;\n"
                "f.isLog && (p = g(p), b = g(b), h = g(h));\n"
                "D ? (x = {\n"
                    "stroke: E,\n"
                    "\"stroke-width\": c.width\n"
                "},\n"
                "c.dashStyle && (x.dashstyle = c.dashStyle)) : t && (E && (x.fill = E), c.borderWidth && (x.stroke = c.borderColor, x[\"stroke-width\"] = c.borderWidth));\n"
                "I.zIndex = m;\n"
                "J += \"-\" + m; (E = f.plotLinesAndBandsGroups[J]) || (f.plotLinesAndBandsGroups[J] = E = r.g(\"plot-\" + J).attr(I).add());\n"
                "e && (a.svgElem = w = r.path().attr(x).add(E));\n"
                "if (D) x = f.getPlotLinePath(h, w.strokeWidth());\n"
                "else if (t) x = f.getPlotBandPath(p, b, c);\n"
                "else return;\n"
                "if (e && x && x.length) {\n"
                    "if (w.attr({\n"
                        "d: x\n"
                    "}), y) for (C in c = function(g) {\n"
                        "w.on(g,\n"
                        "function(b) {\n"
                            "y[g].apply(a, [b])\n"
                        "})\n"
                    "},\n"
                    "y) c(C)\n"
                "} else w && (x ? (w.show(), w.animate({\n"
                    "d: x\n"
                "})) : (w.hide(), z && (a.label = z = z.destroy())));\n"
                "n && H(n.text) && x && x.length && 0 < f.width && 0 < f.height && !x.flat ? (n = l({\n"
                    "align: d && t && \"center\",\n"
                    "x: d ? !t && 4 : 10,\n"
                    "verticalAlign: !d && t && \"middle\",\n"
                    "y: d ? t ? 16 : 10 : t ? 6 : -4,\n"
                    "rotation: d && !t && 90\n"
                "},\n"
                "n), this.renderLabel(n, x, t, m)) : z && z.hide();\n"
                "return a\n"
            "},\n"
            "renderLabel: function(a, f, d, c) {\n"
                "var n = this.label,\n"
                "k = this.axis.chart.renderer;\n"
                "n || (n = {\n"
                    "align: a.textAlign || a.align,\n"
                    "rotation: a.rotation,\n"
                    "\"class\": \"highcharts-plot-\" + (d ? \"band\": \"line\") + \"-label \" + (a.className || \"\")\n"
                "},\n"
                "n.zIndex = c, this.label = n = k.text(a.text, 0, 0, a.useHTML).attr(n).add(), n.css(a.style));\n"
                "c = [f[1], f[4], d ? f[6] : f[1]];\n"
                "f = [f[2], f[5], d ? f[7] : f[2]];\n"
                "d = A(c);\n"
                "k = A(f);\n"
                "n.align(a, !1, {\n"
                    "x: d,\n"
                    "y: k,\n"
                    "width: B(c) - d,\n"
                    "height: B(f) - k\n"
                "});\n"
                "n.show()\n"
            "},\n"
            "destroy: function() {\n"
                "f(this.axis.plotLinesAndBands, this);\n"
                "delete this.axis;\n"
                "G(this)\n"
            "}\n"
        "};\n"
        "a.AxisPlotLineOrBandExtension = {\n"
            "getPlotBandPath: function(a, f) {\n"
                "var d = this.getPlotLinePath(f, null, null, !0),\n"
                "c = this.getPlotLinePath(a, null, null, !0),\n"
                "n = this.horiz,\n"
                "k = 1;\n"
                "a = a < this.min && f < this.min || a > this.max && f > this.max;\n"
                "c && d ? (a && (c.flat = c.toString() === d.toString(), k = 0), c.push(n && d[4] === c[4] ? d[4] + k: d[4], n || d[5] !== c[5] ? d[5] : d[5] + k, n && d[1] === c[1] ? d[1] + k: d[1], n || d[2] !== c[2] ? d[2] : d[2] + k)) : c = null;\n"
                "return c\n"
            "},\n"
            "addPlotBand: function(a) {\n"
                "return this.addPlotBandOrLine(a, \"plotBands\")\n"
            "},\n"
            "addPlotLine: function(a) {\n"
                "return this.addPlotBandOrLine(a, \"plotLines\")\n"
            "},\n"
            "addPlotBandOrLine: function(f, q) {\n"
                "var d = (new a.PlotLineOrBand(this, f)).render(),\n"
                "c = this.userOptions;\n"
                "d && (q && (c[q] = c[q] || [], c[q].push(f)), this.plotLinesAndBands.push(d));\n"
                "return d\n"
            "},\n"
            "removePlotBandOrLine: function(a) {\n"
                "for (var k = this.plotLinesAndBands,\n"
                "d = this.options,\n"
                "c = this.userOptions,\n"
                "n = k.length; n--;) k[n].id === a && k[n].destroy();\n"
                "r([d.plotLines || [], c.plotLines || [], d.plotBands || [], c.plotBands || []],\n"
                "function(c) {\n"
                    "for (n = c.length; n--;) c[n].id === a && f(c, c[n])\n"
                "})\n"
            "}\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.correctFloat,\n"
        "A = a.defined,\n"
        "H = a.destroyObjectProperties,\n"
        "G = a.isNumber,\n"
        "r = a.merge,\n"
        "f = a.pick,\n"
        "l = a.deg2rad;\n"
        "a.Tick = function(a, f, l, d) {\n"
            "this.axis = a;\n"
            "this.pos = f;\n"
            "this.type = l || \"\";\n"
            "this.isNew = !0;\n"
            "l || d || this.addLabel()\n"
        "};\n"
        "a.Tick.prototype = {\n"
            "addLabel: function() {\n"
                "var a = this.axis,\n"
                "k = a.options,\n"
                "l = a.chart,\n"
                "d = a.categories,\n"
                "c = a.names,\n"
                "n = this.pos,\n"
                "z = k.labels,\n"
                "b = a.tickPositions,\n"
                "p = n === b[0],\n"
                "h = n === b[b.length - 1],\n"
                "c = d ? f(d[n], c[n], n) : n,\n"
                "d = this.label,\n"
                "b = b.info,\n"
                "t;\n"
                "a.isDatetimeAxis && b && (t = k.dateTimeLabelFormats[b.higherRanks[n] || b.unitName]);\n"
                "this.isFirst = p;\n"
                "this.isLast = h;\n"
                "k = a.labelFormatter.call({\n"
                    "axis: a,\n"
                    "chart: l,\n"
                    "isFirst: p,\n"
                    "isLast: h,\n"
                    "dateTimeLabelFormat: t,\n"
                    "value: a.isLog ? B(a.lin2log(c)) : c\n"
                "});\n"
                "A(d) ? d && d.attr({\n"
                    "text: k\n"
                "}) : (this.labelLength = (this.label = d = A(k) && z.enabled ? l.renderer.text(k, 0, 0, z.useHTML).css(r(z.style)).add(a.labelGroup) : null) && d.getBBox().width, this.rotation = 0)\n"
            "},\n"
            "getLabelSize: function() {\n"
                "return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\": \"width\"] : 0\n"
            "},\n"
            "handleOverflow: function(a) {\n"
                "var k = this.axis,\n"
                "q = a.x,\n"
                "d = k.chart.chartWidth,\n"
                "c = k.chart.spacing,\n"
                "n = f(k.labelLeft, Math.min(k.pos, c[3])),\n"
                "c = f(k.labelRight, Math.max(k.pos + k.len, d - c[1])),\n"
                "z = this.label,\n"
                "b = this.rotation,\n"
                "p = {\n"
                    "left: 0,\n"
                    "center: .5,\n"
                    "right: 1\n"
                "} [k.labelAlign],\n"
                "h = z.getBBox().width,\n"
                "t = k.getSlotWidth(),\n"
                "D = t,\n"
                "w = 1,\n"
                "e,\n"
                "x = {};\n"
                "if (b) 0 > b && q - p * h < n ? e = Math.round(q / Math.cos(b * l) - n) : 0 < b && q + p * h > c && (e = Math.round((d - q) / Math.cos(b * l)));\n"
                "else if (d = q + (1 - p) * h, q - p * h < n ? D = a.x + D * (1 - p) - n: d > c && (D = c - a.x + D * p, w = -1), D = Math.min(t, D), D < t && \"center\" === k.labelAlign && (a.x += w * (t - D - p * (t - Math.min(h, D)))), h > D || k.autoRotation && (z.styles || {}).width) e = D;\n"
                "e && (x.width = e, (k.options.labels.style || {}).textOverflow || (x.textOverflow = \"ellipsis\"), z.css(x))\n"
            "},\n"
            "getPosition: function(a, f, l, d) {\n"
                "var c = this.axis,\n"
                "n = c.chart,\n"
                "k = d && n.oldChartHeight || n.chartHeight;\n"
                "return {\n"
                    "x: a ? c.translate(f + l, null, null, d) + c.transB: c.left + c.offset + (c.opposite ? (d && n.oldChartWidth || n.chartWidth) - c.right - c.left: 0),\n"
                    "y: a ? k - c.bottom + c.offset - (c.opposite ? c.height: 0) : k - c.translate(f + l, null, null, d) - c.transB\n"
                "}\n"
            "},\n"
            "getLabelPosition: function(a, f, u, d, c, n, z, b) {\n"
                "var p = this.axis,\n"
                "h = p.transA,\n"
                "t = p.reversed,\n"
                "k = p.staggerLines,\n"
                "w = p.tickRotCorr || {\n"
                    "x: 0,\n"
                    "y: 0\n"
                "},\n"
                "e = c.y;\n"
                "A(e) || (e = 0 === p.side ? u.rotation ? -8 : -u.getBBox().height: 2 === p.side ? w.y + 8 : Math.cos(u.rotation * l) * (w.y - u.getBBox(!1, 0).height / 2));\n"
                "a = a + c.x + w.x - (n && d ? n * h * (t ? -1 : 1) : 0);\n"
                "f = f + e - (n && !d ? n * h * (t ? 1 : -1) : 0);\n"
                "k && (u = z / (b || 1) % k, p.opposite && (u = k - u - 1), f += p.labelOffset / k * u);\n"
                "return {\n"
                    "x: a,\n"
                    "y: Math.round(f)\n"
                "}\n"
            "},\n"
            "getMarkPath: function(a, f, l, d, c, n) {\n"
                "return n.crispLine([\"M\", a, f, \"L\", a + (c ? 0 : -l), f + (c ? l: 0)], d)\n"
            "},\n"
            "renderGridLine: function(a, f, l) {\n"
                "var d = this.axis,\n"
                "c = d.options,\n"
                "n = this.gridLine,\n"
                "k = {},\n"
                "b = this.pos,\n"
                "p = this.type,\n"
                "h = d.tickmarkOffset,\n"
                "t = d.chart.renderer,\n"
                "D = p ? p + \"Grid\": \"grid\",\n"
                "w = c[D + \"LineWidth\"],\n"
                "e = c[D + \"LineColor\"],\n"
                "c = c[D + \"LineDashStyle\"];\n"
                "n || (k.stroke = e, k[\"stroke-width\"] = w, c && (k.dashstyle = c), p || (k.zIndex = 1), a && (k.opacity = 0), this.gridLine = n = t.path().attr(k).addClass(\"highcharts-\" + (p ? p + \"-\": \"\") + \"grid-line\").add(d.gridGroup));\n"
                "if (!a && n && (a = d.getPlotLinePath(b + h, n.strokeWidth() * l, a, !0))) n[this.isNew ? \"attr\": \"animate\"]({\n"
                    "d: a,\n"
                    "opacity: f\n"
                "})\n"
            "},\n"
            "renderMark: function(a, k, l) {\n"
                "var d = this.axis,\n"
                "c = d.options,\n"
                "n = d.chart.renderer,\n"
                "q = this.type,\n"
                "b = q ? q + \"Tick\": \"tick\",\n"
                "p = d.tickSize(b),\n"
                "h = this.mark,\n"
                "t = !h,\n"
                "D = a.x;\n"
                "a = a.y;\n"
                "var w = f(c[b + \"Width\"], !q && d.isXAxis ? 1 : 0),\n"
                "c = c[b + \"Color\"];\n"
                "p && (d.opposite && (p[0] = -p[0]), t && (this.mark = h = n.path().addClass(\"highcharts-\" + (q ? q + \"-\": \"\") + \"tick\").add(d.axisGroup), h.attr({\n"
                    "stroke: c,\n"
                    "\"stroke-width\": w\n"
                "})), h[t ? \"attr\": \"animate\"]({\n"
                    "d: this.getMarkPath(D, a, p[0], h.strokeWidth() * l, d.horiz, n),\n"
                    "opacity: k\n"
                "}))\n"
            "},\n"
            "renderLabel: function(a, k, l, d) {\n"
                "var c = this.axis,\n"
                "n = c.horiz,\n"
                "q = c.options,\n"
                "b = this.label,\n"
                "p = q.labels,\n"
                "h = p.step,\n"
                "t = c.tickmarkOffset,\n"
                "D = !0,\n"
                "w = a.x;\n"
                "a = a.y;\n"
                "b && G(w) && (b.xy = a = this.getLabelPosition(w, a, b, n, p, t, d, h), this.isFirst && !this.isLast && !f(q.showFirstLabel, 1) || this.isLast && !this.isFirst && !f(q.showLastLabel, 1) ? D = !1 : !n || c.isRadial || p.step || p.rotation || k || 0 === l || this.handleOverflow(a), h && d % h && (D = !1), D && G(a.y) ? (a.opacity = l, b[this.isNew ? \"attr\": \"animate\"](a)) : b.attr(\"y\", -9999), this.isNew = !1)\n"
            "},\n"
            "render: function(a, k, l) {\n"
                "var d = this.axis,\n"
                "c = d.horiz,\n"
                "n = this.getPosition(c, this.pos, d.tickmarkOffset, k),\n"
                "q = n.x,\n"
                "b = n.y,\n"
                "d = c && q === d.pos + d.len || !c && b === d.pos ? -1 : 1;\n"
                "l = f(l, 1);\n"
                "this.isActive = !0;\n"
                "this.renderGridLine(k, l, d);\n"
                "this.renderMark(n, l, d);\n"
                "this.renderLabel(n, k, l, a)\n"
            "},\n"
            "destroy: function() {\n"
                "H(this, this.axis)\n"
            "}\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.animObject,\n"
        "H = a.arrayMax,\n"
        "G = a.arrayMin,\n"
        "r = a.AxisPlotLineOrBandExtension,\n"
        "f = a.color,\n"
        "l = a.correctFloat,\n"
        "q = a.defaultOptions,\n"
        "k = a.defined,\n"
        "u = a.deg2rad,\n"
        "d = a.destroyObjectProperties,\n"
        "c = a.each,\n"
        "n = a.extend,\n"
        "z = a.fireEvent,\n"
        "b = a.format,\n"
        "p = a.getMagnitude,\n"
        "h = a.grep,\n"
        "t = a.inArray,\n"
        "D = a.isArray,\n"
        "w = a.isNumber,\n"
        "e = a.isString,\n"
        "x = a.merge,\n"
        "C = a.normalizeTickInterval,\n"
        "E = a.pick,\n"
        "m = a.PlotLineOrBand,\n"
        "y = a.removeEvent,\n"
        "I = a.splat,\n"
        "K = a.syncTimeout,\n"
        "J = a.Tick;\n"
        "a.Axis = function() {\n"
            "this.init.apply(this, arguments)\n"
        "};\n"
        "a.Axis.prototype = {\n"
            "defaultOptions: {\n"
                "dateTimeLabelFormats: {\n"
                    "millisecond: \"%H:%M:%S.%L\",\n"
                    "second: \"%H:%M:%S\",\n"
                    "minute: \"%H:%M\",\n"
                    "hour: \"%H:%M\",\n"
                    "day: \"%e. %b\",\n"
                    "week: \"%e. %b\",\n"
                    "month: \"%b '%y\",\n"
                    "year: \"%Y\"\n"
                "},\n"
                "endOnTick: !1,\n"
                "labels: {\n"
                    "enabled: !0,\n"
                    "style: {\n"
                        "color: \"#666666\",\n"
                        "cursor: \"default\",\n"
                        "fontSize: \"11px\"\n"
                    "},\n"
                    "x: 0\n"
                "},\n"
                "minPadding: .01,\n"
                "maxPadding: .01,\n"
                "minorTickLength: 2,\n"
                "minorTickPosition: \"outside\",\n"
                "startOfWeek: 1,\n"
                "startOnTick: !1,\n"
                "tickLength: 10,\n"
                "tickmarkPlacement: \"between\",\n"
                "tickPixelInterval: 100,\n"
                "tickPosition: \"outside\",\n"
                "title: {\n"
                    "align: \"middle\",\n"
                    "style: {\n"
                        "color: \"#666666\"\n"
                    "}\n"
                "},\n"
                "type: \"linear\",\n"
                "minorGridLineColor: \"#f2f2f2\",\n"
                "minorGridLineWidth: 1,\n"
                "minorTickColor: \"#999999\",\n"
                "lineColor: \"#ccd6eb\",\n"
                "lineWidth: 1,\n"
                "gridLineColor: \"#e6e6e6\",\n"
                "tickColor: \"#ccd6eb\"\n"
            "},\n"
            "defaultYAxisOptions: {\n"
                "endOnTick: !0,\n"
                "tickPixelInterval: 72,\n"
                "showLastLabel: !0,\n"
                "labels: {\n"
                    "x: -8\n"
                "},\n"
                "maxPadding: .05,\n"
                "minPadding: .05,\n"
                "startOnTick: !0,\n"
                "title: {\n"
                    "rotation: 270,\n"
                    "text: \"Values\"\n"
                "},\n"
                "stackLabels: {\n"
                    "enabled: !1,\n"
                    "formatter: function() {\n"
                        "return a.numberFormat(this.total, -1)\n"
                    "},\n"
                    "style: {\n"
                        "fontSize: \"11px\",\n"
                        "fontWeight: \"bold\",\n"
                        "color: \"#000000\",\n"
                        "textOutline: \"1px contrast\"\n"
                    "}\n"
                "},\n"
                "gridLineWidth: 1,\n"
                "lineWidth: 0\n"
            "},\n"
            "defaultLeftAxisOptions: {\n"
                "labels: {\n"
                    "x: -15\n"
                "},\n"
                "title: {\n"
                    "rotation: 270\n"
                "}\n"
            "},\n"
            "defaultRightAxisOptions: {\n"
                "labels: {\n"
                    "x: 15\n"
                "},\n"
                "title: {\n"
                    "rotation: 90\n"
                "}\n"
            "},\n"
            "defaultBottomAxisOptions: {\n"
                "labels: {\n"
                    "autoRotation: [ - 45],\n"
                    "x: 0\n"
                "},\n"
                "title: {\n"
                    "rotation: 0\n"
                "}\n"
            "},\n"
            "defaultTopAxisOptions: {\n"
                "labels: {\n"
                    "autoRotation: [ - 45],\n"
                    "x: 0\n"
                "},\n"
                "title: {\n"
                    "rotation: 0\n"
                "}\n"
            "},\n"
            "init: function(a, b) {\n"
                "var g = b.isX;\n"
                "this.chart = a;\n"
                "this.horiz = a.inverted ? !g: g;\n"
                "this.isXAxis = g;\n"
                "this.coll = this.coll || (g ? \"xAxis\": \"yAxis\");\n"
                "this.opposite = b.opposite;\n"
                "this.side = b.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n"
                "this.setOptions(b);\n"
                "var c = this.options,\n"
                "e = c.type;\n"
                "this.labelFormatter = c.labels.formatter || this.defaultLabelFormatter;\n"
                "this.userOptions = b;\n"
                "this.minPixelPadding = 0;\n"
                "this.reversed = c.reversed;\n"
                "this.visible = !1 !== c.visible;\n"
                "this.zoomEnabled = !1 !== c.zoomEnabled;\n"
                "this.hasNames = \"category\" === e || !0 === c.categories;\n"
                "this.categories = c.categories || this.hasNames;\n"
                "this.names = this.names || [];\n"
                "this.plotLinesAndBandsGroups = {};\n"
                "this.isLog = \"logarithmic\" === e;\n"
                "this.isDatetimeAxis = \"datetime\" === e;\n"
                "this.positiveValuesOnly = this.isLog && !this.allowNegativeLog;\n"
                "this.isLinked = k(c.linkedTo);\n"
                "this.ticks = {};\n"
                "this.labelEdge = [];\n"
                "this.minorTicks = {};\n"
                "this.plotLinesAndBands = [];\n"
                "this.alternateBands = {};\n"
                "this.len = 0;\n"
                "this.minRange = this.userMinRange = c.minRange || c.maxZoom;\n"
                "this.range = c.range;\n"
                "this.offset = c.offset || 0;\n"
                "this.stacks = {};\n"
                "this.oldStacks = {};\n"
                "this.stacksTouched = 0;\n"
                "this.min = this.max = null;\n"
                "this.crosshair = E(c.crosshair, I(a.options.tooltip.crosshairs)[g ? 0 : 1], !1);\n"
                "var h;\n"
                "b = this.options.events; - 1 === t(this, a.axes) && (g ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this));\n"
                "this.series = this.series || [];\n"
                "a.inverted && g && void 0 === this.reversed && (this.reversed = !0);\n"
                "this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine;\n"
                "for (h in b) B(this, h, b[h]);\n"
                "this.lin2log = c.linearToLogConverter || this.lin2log;\n"
                "this.isLog && (this.val2lin = this.log2lin, this.lin2val = this.lin2log)\n"
            "},\n"
            "setOptions: function(a) {\n"
                "this.options = x(this.defaultOptions, \"yAxis\" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], x(q[this.coll], a))\n"
            "},\n"
            "defaultLabelFormatter: function() {\n"
                "var g = this.axis,\n"
                "c = this.value,\n"
                "e = g.categories,\n"
                "h = this.dateTimeLabelFormat,\n"
                "m = q.lang,\n"
                "d = m.numericSymbols,\n"
                "m = m.numericSymbolMagnitude || 1E3,\n"
                "v = d && d.length,\n"
                "p, t = g.options.labels.format,\n"
                "g = g.isLog ? Math.abs(c) : g.tickInterval;\n"
                "if (t) p = b(t, this);\n"
                "else if (e) p = c;\n"
                "else if (h) p = a.dateFormat(h, c);\n"
                "else if (v && 1E3 <= g) for (; v--&&void 0 === p;) e = Math.pow(m, v + 1),\n"
                "g >= e && 0 === 10 * c % e && null !== d[v] && 0 !== c && (p = a.numberFormat(c / e, -1) + d[v]);\n"
                "void 0 === p && (p = 1E4 <= Math.abs(c) ? a.numberFormat(c, -1) : a.numberFormat(c, -1, void 0, \"\"));\n"
                "return p\n"
            "},\n"
            "getSeriesExtremes: function() {\n"
                "var a = this,\n"
                "b = a.chart;\n"
                "a.hasVisibleSeries = !1;\n"
                "a.dataMin = a.dataMax = a.threshold = null;\n"
                "a.softThreshold = !a.isXAxis;\n"
                "a.buildStacks && a.buildStacks();\n"
                "c(a.series,\n"
                "function(g) {\n"
                    "if (g.visible || !b.options.chart.ignoreHiddenSeries) {\n"
                        "var c = g.options,\n"
                        "e = c.threshold,\n"
                        "m;\n"
                        "a.hasVisibleSeries = !0;\n"
                        "a.positiveValuesOnly && 0 >= e && (e = null);\n"
                        "if (a.isXAxis) c = g.xData,\n"
                        "c.length && (g = G(c), w(g) || g instanceof Date || (c = h(c,\n"
                        "function(a) {\n"
                            "return w(a)\n"
                        "}), g = G(c)), a.dataMin = Math.min(E(a.dataMin, c[0]), g), a.dataMax = Math.max(E(a.dataMax, c[0]), H(c)));\n"
                        "else if (g.getExtremes(), m = g.dataMax, g = g.dataMin, k(g) && k(m) && (a.dataMin = Math.min(E(a.dataMin, g), g), a.dataMax = Math.max(E(a.dataMax, m), m)), k(e) && (a.threshold = e), !c.softThreshold || a.positiveValuesOnly) a.softThreshold = !1\n"
                    "}\n"
                "})\n"
            "},\n"
            "translate: function(a, b, c, e, h, m) {\n"
                "var g = this.linkedParent || this,\n"
                "F = 1,\n"
                "p = 0,\n"
                "d = e ? g.oldTransA: g.transA;\n"
                "e = e ? g.oldMin: g.min;\n"
                "var t = g.minPixelPadding;\n"
                "h = (g.isOrdinal || g.isBroken || g.isLog && h) && g.lin2val;\n"
                "d || (d = g.transA);\n"
                "c && (F *= -1, p = g.len);\n"
                "g.reversed && (F *= -1, p -= F * (g.sector || g.len));\n"
                "b ? (a = (a * F + p - t) / d + e, h && (a = g.lin2val(a))) : (h && (a = g.val2lin(a)), a = F * (a - e) * d + p + F * t + (w(m) ? d * m: 0));\n"
                "return a\n"
            "},\n"
            "toPixels: function(a, b) {\n"
                "return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos)\n"
            "},\n"
            "toValue: function(a, b) {\n"
                "return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0)\n"
            "},\n"
            "getPlotLinePath: function(a, b, c, e, h) {\n"
                "var g = this.chart,\n"
                "m = this.left,\n"
                "F = this.top,\n"
                "p, d, t = c && g.oldChartHeight || g.chartHeight,\n"
                "f = c && g.oldChartWidth || g.chartWidth,\n"
                "n;\n"
                "p = this.transB;\n"
                "var y = function(a, b, g) {\n"
                    "if (a < b || a > g) e ? a = Math.min(Math.max(b, a), g) : n = !0;\n"
                    "return a\n"
                "};\n"
                "h = E(h, this.translate(a, null, null, c));\n"
                "a = c = Math.round(h + p);\n"
                "p = d = Math.round(t - h - p);\n"
                "w(h) ? this.horiz ? (p = F, d = t - this.bottom, a = c = y(a, m, m + this.width)) : (a = m, c = f - this.right, p = d = y(p, F, F + this.height)) : n = !0;\n"
                "return n && !e ? null: g.renderer.crispLine([\"M\", a, p, \"L\", c, d], b || 1)\n"
            "},\n"
            "getLinearTickPositions: function(a, b, c) {\n"
                "var g, e = l(Math.floor(b / a) * a);\n"
                "c = l(Math.ceil(c / a) * a);\n"
                "var h = [];\n"
                "if (this.single) return [b];\n"
                "for (b = e; b <= c;) {\n"
                    "h.push(b);\n"
                    "b = l(b + a);\n"
                    "if (b === g) break;\n"
                    "g = b\n"
                "}\n"
                "return h\n"
            "},\n"
            "getMinorTickPositions: function() {\n"
                "var a = this,\n"
                "b = a.options,\n"
                "e = a.tickPositions,\n"
                "h = a.minorTickInterval,\n"
                "m = [],\n"
                "p = a.pointRangePadding || 0,\n"
                "v = a.min - p,\n"
                "p = a.max + p,\n"
                "d = p - v;\n"
                "if (d && d / h < a.len / 3) if (a.isLog) c(this.paddedTicks,\n"
                "function(b, g, c) {\n"
                    "g && m.push.apply(m, a.getLogTickPositions(h, c[g - 1], c[g], !0))\n"
                "});\n"
                "else if (a.isDatetimeAxis && \"auto\" === b.minorTickInterval) m = m.concat(a.getTimeTicks(a.normalizeTimeTickInterval(h), v, p, b.startOfWeek));\n"
                "else for (b = v + (e[0] - v) % h; b <= p && b !== m[0]; b += h) m.push(b);\n"
                "0 !== m.length && a.trimTicks(m);\n"
                "return m\n"
            "},\n"
            "adjustForMinRange: function() {\n"
                "var a = this.options,\n"
                "b = this.min,\n"
                "e = this.max,\n"
                "h, m = this.dataMax - this.dataMin >= this.minRange,\n"
                "p, v, d, t, f, n;\n"
                "this.isXAxis && void 0 === this.minRange && !this.isLog && (k(a.min) || k(a.max) ? this.minRange = null: (c(this.series,\n"
                "function(a) {\n"
                    "t = a.xData;\n"
                    "for (v = f = a.xIncrement ? 1 : t.length - 1; 0 < v; v--) if (d = t[v] - t[v - 1], void 0 === p || d < p) p = d\n"
                "}), this.minRange = Math.min(5 * p, this.dataMax - this.dataMin)));\n"
                "e - b < this.minRange && (n = this.minRange, h = (n - e + b) / 2, h = [b - h, E(a.min, b - h)], m && (h[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), b = H(h), e = [b + n, E(a.max, b + n)], m && (e[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), e = G(e), e - b < n && (h[0] = e - n, h[1] = E(a.min, e - n), b = H(h)));\n"
                "this.min = b;\n"
                "this.max = e\n"
            "},\n"
            "getClosest: function() {\n"
                "var a;\n"
                "this.categories ? a = 1 : c(this.series,\n"
                "function(b) {\n"
                    "var g = b.closestPointRange,\n"
                    "c = b.visible || !b.chart.options.chart.ignoreHiddenSeries; ! b.noSharedTooltip && k(g) && c && (a = k(a) ? Math.min(a, g) : g)\n"
                "});\n"
                "return a\n"
            "},\n"
            "nameToX: function(a) {\n"
                "var b = D(this.categories),\n"
                "g = b ? this.categories: this.names,\n"
                "c = a.options.x,\n"
                "e;\n"
                "a.series.requireSorting = !1;\n"
                "k(c) || (c = !1 === this.options.uniqueNames ? a.series.autoIncrement() : t(a.name, g)); - 1 === c ? b || (e = g.length) : e = c;\n"
                "void 0 !== e && (this.names[e] = a.name);\n"
                "return e\n"
            "},\n"
            "updateNames: function() {\n"
                "var a = this;\n"
                "0 < this.names.length && (this.names.length = 0, this.minRange = void 0, c(this.series || [],\n"
                "function(b) {\n"
                    "b.xIncrement = null;\n"
                    "if (!b.points || b.isDirtyData) b.processData(),\n"
                    "b.generatePoints();\n"
                    "c(b.points,\n"
                    "function(g, c) {\n"
                        "var e;\n"
                        "g.options && (e = a.nameToX(g), void 0 !== e && e !== g.x && (g.x = e, b.xData[c] = e))\n"
                    "})\n"
                "}))\n"
            "},\n"
            "setAxisTranslation: function(a) {\n"
                "var b = this,\n"
                "g = b.max - b.min,\n"
                "h = b.axisPointRange || 0,\n"
                "m, p = 0,\n"
                "v = 0,\n"
                "d = b.linkedParent,\n"
                "t = !!b.categories,\n"
                "f = b.transA,\n"
                "n = b.isXAxis;\n"
                "if (n || t || h) m = b.getClosest(),\n"
                "d ? (p = d.minPointOffset, v = d.pointRangePadding) : c(b.series,\n"
                "function(a) {\n"
                    "var g = t ? 1 : n ? E(a.options.pointRange, m, 0) : b.axisPointRange || 0;\n"
                    "a = a.options.pointPlacement;\n"
                    "h = Math.max(h, g);\n"
                    "b.single || (p = Math.max(p, e(a) ? 0 : g / 2), v = Math.max(v, \"on\" === a ? 0 : g))\n"
                "}),\n"
                "d = b.ordinalSlope && m ? b.ordinalSlope / m: 1,\n"
                "b.minPointOffset = p *= d,\n"
                "b.pointRangePadding = v *= d,\n"
                "b.pointRange = Math.min(h, g),\n"
                "n && (b.closestPointRange = m);\n"
                "a && (b.oldTransA = f);\n"
                "b.translationSlope = b.transA = f = b.options.staticScale || b.len / (g + v || 1);\n"
                "b.transB = b.horiz ? b.left: b.bottom;\n"
                "b.minPixelPadding = f * p\n"
            "},\n"
            "minFromRange: function() {\n"
                "return this.max - this.range\n"
            "},\n"
            "setTickInterval: function(b) {\n"
                "var g = this,\n"
                "e = g.chart,\n"
                "h = g.options,\n"
                "m = g.isLog,\n"
                "d = g.log2lin,\n"
                "v = g.isDatetimeAxis,\n"
                "t = g.isXAxis,\n"
                "f = g.isLinked,\n"
                "n = h.maxPadding,\n"
                "y = h.minPadding,\n"
                "x = h.tickInterval,\n"
                "D = h.tickPixelInterval,\n"
                "I = g.categories,\n"
                "q = g.threshold,\n"
                "u = g.softThreshold,\n"
                "r, K, J, A;\n"
                "v || I || f || this.getTickAmount();\n"
                "J = E(g.userMin, h.min);\n"
                "A = E(g.userMax, h.max);\n"
                "f ? (g.linkedParent = e[g.coll][h.linkedTo], e = g.linkedParent.getExtremes(), g.min = E(e.min, e.dataMin), g.max = E(e.max, e.dataMax), h.type !== g.linkedParent.options.type && a.error(11, 1)) : (!u && k(q) && (g.dataMin >= q ? (r = q, y = 0) : g.dataMax <= q && (K = q, n = 0)), g.min = E(J, r, g.dataMin), g.max = E(A, K, g.dataMax));\n"
                "m && (g.positiveValuesOnly && !b && 0 >= Math.min(g.min, E(g.dataMin, g.min)) && a.error(10, 1), g.min = l(d(g.min), 15), g.max = l(d(g.max), 15));\n"
                "g.range && k(g.max) && (g.userMin = g.min = J = Math.max(g.min, g.minFromRange()), g.userMax = A = g.max, g.range = null);\n"
                "z(g, \"foundExtremes\");\n"
                "g.beforePadding && g.beforePadding();\n"
                "g.adjustForMinRange(); ! (I || g.axisPointRange || g.usePercentage || f) && k(g.min) && k(g.max) && (d = g.max - g.min) && (!k(J) && y && (g.min -= d * y), !k(A) && n && (g.max += d * n));\n"
                "w(h.softMin) && (g.min = Math.min(g.min, h.softMin));\n"
                "w(h.softMax) && (g.max = Math.max(g.max, h.softMax));\n"
                "w(h.floor) && (g.min = Math.max(g.min, h.floor));\n"
                "w(h.ceiling) && (g.max = Math.min(g.max, h.ceiling));\n"
                "u && k(g.dataMin) && (q = q || 0, !k(J) && g.min < q && g.dataMin >= q ? g.min = q: !k(A) && g.max > q && g.dataMax <= q && (g.max = q));\n"
                "g.tickInterval = g.min === g.max || void 0 === g.min || void 0 === g.max ? 1 : f && !x && D === g.linkedParent.options.tickPixelInterval ? x = g.linkedParent.tickInterval: E(x, this.tickAmount ? (g.max - g.min) / Math.max(this.tickAmount - 1, 1) : void 0, I ? 1 : (g.max - g.min) * D / Math.max(g.len, D));\n"
                "t && !b && c(g.series,\n"
                "function(a) {\n"
                    "a.processData(g.min !== g.oldMin || g.max !== g.oldMax)\n"
                "});\n"
                "g.setAxisTranslation(!0);\n"
                "g.beforeSetTickPositions && g.beforeSetTickPositions();\n"
                "g.postProcessTickInterval && (g.tickInterval = g.postProcessTickInterval(g.tickInterval));\n"
                "g.pointRange && !x && (g.tickInterval = Math.max(g.pointRange, g.tickInterval));\n"
                "b = E(h.minTickInterval, g.isDatetimeAxis && g.closestPointRange); ! x && g.tickInterval < b && (g.tickInterval = b);\n"
                "v || m || x || (g.tickInterval = C(g.tickInterval, null, p(g.tickInterval), E(h.allowDecimals, !(.5 < g.tickInterval && 5 > g.tickInterval && 1E3 < g.max && 9999 > g.max)), !!this.tickAmount));\n"
                "this.tickAmount || (g.tickInterval = g.unsquish());\n"
                "this.setTickPositions()\n"
            "},\n"
            "setTickPositions: function() {\n"
                "var a = this.options,\n"
                "b, c = a.tickPositions,\n"
                "e = a.tickPositioner,\n"
                "h = a.startOnTick,\n"
                "m = a.endOnTick;\n"
                "this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n"
                "this.minorTickInterval = \"auto\" === a.minorTickInterval && this.tickInterval ? this.tickInterval / 5 : a.minorTickInterval;\n"
                "this.single = this.min === this.max && k(this.min) && !this.tickAmount && !1 !== a.allowDecimals;\n"
                "this.tickPositions = b = c && c.slice(); ! b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()]), this.tickPositions = b, e && (e = e.apply(this, [this.min, this.max]))) && (this.tickPositions = b = e);\n"
                "this.paddedTicks = b.slice(0);\n"
                "this.trimTicks(b, h, m);\n"
                "this.isLinked || (this.single && (this.min -= .5, this.max += .5), c || e || this.adjustTickAmount())\n"
            "},\n"
            "trimTicks: function(a, b, c) {\n"
                "var g = a[0],\n"
                "e = a[a.length - 1],\n"
                "h = this.minPointOffset || 0;\n"
                "if (!this.isLinked) {\n"
                    "if (b && -Infinity !== g) this.min = g;\n"
                    "else for (; this.min - h > a[0];) a.shift();\n"
                    "if (c) this.max = e;\n"
                    "else for (; this.max + h < a[a.length - 1];) a.pop();\n"
                    "0 === a.length && k(g) && a.push((e + g) / 2)\n"
                "}\n"
            "},\n"
            "alignToOthers: function() {\n"
                "var a = {},\n"
                "b, e = this.options; ! 1 === this.chart.options.chart.alignTicks || !1 === e.alignTicks || this.isLog || c(this.chart[this.coll],\n"
                "function(g) {\n"
                    "var c = g.options,\n"
                    "c = [g.horiz ? c.left: c.top, c.width, c.height, c.pane].join();\n"
                    "g.series.length && (a[c] ? b = !0 : a[c] = 1)\n"
                "});\n"
                "return b\n"
            "},\n"
            "getTickAmount: function() {\n"
                "var a = this.options,\n"
                "b = a.tickAmount,\n"
                "c = a.tickPixelInterval; ! k(a.tickInterval) && this.len < c && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2); ! b && this.alignToOthers() && (b = Math.ceil(this.len / c) + 1);\n"
                "4 > b && (this.finalTickAmt = b, b = 5);\n"
                "this.tickAmount = b\n"
            "},\n"
            "adjustTickAmount: function() {\n"
                "var a = this.tickInterval,\n"
                "b = this.tickPositions,\n"
                "c = this.tickAmount,\n"
                "e = this.finalTickAmt,\n"
                "h = b && b.length;\n"
                "if (h < c) {\n"
                    "for (; b.length < c;) b.push(l(b[b.length - 1] + a));\n"
                    "this.transA *= (h - 1) / (c - 1);\n"
                    "this.max = b[b.length - 1]\n"
                "} else h > c && (this.tickInterval *= 2, this.setTickPositions());\n"
                "if (k(e)) {\n"
                    "for (a = c = b.length; a--;)(3 === e && 1 === a % 2 || 2 >= e && 0 < a && a < c - 1) && b.splice(a, 1);\n"
                    "this.finalTickAmt = void 0\n"
                "}\n"
            "},\n"
            "setScale: function() {\n"
                "var a, b;\n"
                "this.oldMin = this.min;\n"
                "this.oldMax = this.max;\n"
                "this.oldAxisLength = this.len;\n"
                "this.setAxisSize();\n"
                "b = this.len !== this.oldAxisLength;\n"
                "c(this.series,\n"
                "function(b) {\n"
                    "if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0\n"
                "});\n"
                "b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks()\n"
            "},\n"
            "setExtremes: function(a, b, e, h, m) {\n"
                "var g = this,\n"
                "p = g.chart;\n"
                "e = E(e, !0);\n"
                "c(g.series,\n"
                "function(a) {\n"
                    "delete a.kdTree\n"
                "});\n"
                "m = n(m, {\n"
                    "min: a,\n"
                    "max: b\n"
                "});\n"
                "z(g, \"setExtremes\", m,\n"
                "function() {\n"
                    "g.userMin = a;\n"
                    "g.userMax = b;\n"
                    "g.eventArgs = m;\n"
                    "e && p.redraw(h)\n"
                "})\n"
            "},\n"
            "zoom: function(a, b) {\n"
                "var g = this.dataMin,\n"
                "c = this.dataMax,\n"
                "e = this.options,\n"
                "h = Math.min(g, E(e.min, g)),\n"
                "e = Math.max(c, E(e.max, c));\n"
                "if (a !== this.min || b !== this.max) this.allowZoomOutside || (k(g) && (a < h && (a = h), a > e && (a = e)), k(c) && (b < h && (b = h), b > e && (b = e))),\n"
                "this.displayBtn = void 0 !== a || void 0 !== b,\n"
                "this.setExtremes(a, b, !1, void 0, {\n"
                    "trigger: \"zoom\"\n"
                "});\n"
                "return ! 0\n"
            "},\n"
            "setAxisSize: function() {\n"
                "var a = this.chart,\n"
                "b = this.options,\n"
                "c = b.offsets || [0, 0, 0, 0],\n"
                "e = this.horiz,\n"
                "h = E(b.width, a.plotWidth - c[3] + c[1]),\n"
                "m = E(b.height, a.plotHeight - c[0] + c[2]),\n"
                "p = E(b.top, a.plotTop + c[0]),\n"
                "b = E(b.left, a.plotLeft + c[3]),\n"
                "c = /%$/;\n"
                "c.test(m) && (m = Math.round(parseFloat(m) / 100 * a.plotHeight));\n"
                "c.test(p) && (p = Math.round(parseFloat(p) / 100 * a.plotHeight + a.plotTop));\n"
                "this.left = b;\n"
                "this.top = p;\n"
                "this.width = h;\n"
                "this.height = m;\n"
                "this.bottom = a.chartHeight - m - p;\n"
                "this.right = a.chartWidth - h - b;\n"
                "this.len = Math.max(e ? h: m, 0);\n"
                "this.pos = e ? b: p\n"
            "},\n"
            "getExtremes: function() {\n"
                "var a = this.isLog,\n"
                "b = this.lin2log;\n"
                "return {\n"
                    "min: a ? l(b(this.min)) : this.min,\n"
                    "max: a ? l(b(this.max)) : this.max,\n"
                    "dataMin: this.dataMin,\n"
                    "dataMax: this.dataMax,\n"
                    "userMin: this.userMin,\n"
                    "userMax: this.userMax\n"
                "}\n"
            "},\n"
            "getThreshold: function(a) {\n"
                "var b = this.isLog,\n"
                "g = this.lin2log,\n"
                "c = b ? g(this.min) : this.min,\n"
                "b = b ? g(this.max) : this.max;\n"
                "null === a ? a = c: c > a ? a = c: b < a && (a = b);\n"
                "return this.translate(a, 0, 1, 0, 1)\n"
            "},\n"
            "autoLabelAlign: function(a) {\n"
                "a = (E(a, 0) - 90 * this.side + 720) % 360;\n"
                "return 15 < a && 165 > a ? \"right\": 195 < a && 345 > a ? \"left\": \"center\"\n"
            "},\n"
            "tickSize: function(a) {\n"
                "var b = this.options,\n"
                "g = b[a + \"Length\"],\n"
                "c = E(b[a + \"Width\"], \"tick\" === a && this.isXAxis ? 1 : 0);\n"
                "if (c && g) return \"inside\" === b[a + \"Position\"] && (g = -g),\n"
                "[g, c]\n"
            "},\n"
            "labelMetrics: function() {\n"
                "return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[0] && this.ticks[0].label)\n"
            "},\n"
            "unsquish: function() {\n"
                "var a = this.options.labels,\n"
                "b = this.horiz,\n"
                "e = this.tickInterval,\n"
                "h = e,\n"
                "m = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e),\n"
                "p,\n"
                "d = a.rotation,\n"
                "t = this.labelMetrics(),\n"
                "f,\n"
                "n = Number.MAX_VALUE,\n"
                "y,\n"
                "w = function(a) {\n"
                    "a /= m || 1;\n"
                    "a = 1 < a ? Math.ceil(a) : 1;\n"
                    "return a * e\n"
                "};\n"
                "b ? (y = !a.staggerLines && !a.step && (k(d) ? [d] : m < E(a.autoRotationLimit, 80) && a.autoRotation)) && c(y,\n"
                "function(a) {\n"
                    "var b;\n"
                    "if (a === d || a && -90 <= a && 90 >= a) f = w(Math.abs(t.h / Math.sin(u * a))),\n"
                    "b = f + Math.abs(a / 360),\n"
                    "b < n && (n = b, p = a, h = f)\n"
                "}) : a.step || (h = w(t.h));\n"
                "this.autoRotation = y;\n"
                "this.labelRotation = E(p, d);\n"
                "return h\n"
            "},\n"
            "getSlotWidth: function() {\n"
                "var a = this.chart,\n"
                "b = this.horiz,\n"
                "c = this.options.labels,\n"
                "e = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n"
                "h = a.margin[3];\n"
                "return b && 2 > (c.step || 0) && !c.rotation && (this.staggerLines || 1) * this.len / e || !b && (h && h - a.spacing[3] || .33 * a.chartWidth)\n"
            "},\n"
            "renderUnsquish: function() {\n"
                "var a = this.chart,\n"
                "b = a.renderer,\n"
                "h = this.tickPositions,\n"
                "m = this.ticks,\n"
                "p = this.options.labels,\n"
                "d = this.horiz,\n"
                "v = this.getSlotWidth(),\n"
                "t = Math.max(1, Math.round(v - 2 * (p.padding || 5))),\n"
                "f = {},\n"
                "n = this.labelMetrics(),\n"
                "y = p.style && p.style.textOverflow,\n"
                "k,\n"
                "w = 0,\n"
                "D,\n"
                "l;\n"
                "e(p.rotation) || (f.rotation = p.rotation || 0);\n"
                "c(h,\n"
                "function(a) { (a = m[a]) && a.labelLength > w && (w = a.labelLength)\n"
                "});\n"
                "this.maxLabelLength = w;\n"
                "if (this.autoRotation) w > t && w > n.h ? f.rotation = this.labelRotation: this.labelRotation = 0;\n"
                "else if (v && (k = {\n"
                    "width: t + \"px\"\n"
                "},\n"
                "!y)) for (k.textOverflow = \"clip\", D = h.length; ! d && D--;) if (l = h[D], t = m[l].label) t.styles && \"ellipsis\" === t.styles.textOverflow ? t.css({\n"
                    "textOverflow: \"clip\"\n"
                "}) : m[l].labelLength > v && t.css({\n"
                    "width: v + \"px\"\n"
                "}),\n"
                "t.getBBox().height > this.len / h.length - (n.h - n.f) && (t.specCss = {\n"
                    "textOverflow: \"ellipsis\"\n"
                "});\n"
                "f.rotation && (k = {\n"
                    "width: (w > .5 * a.chartHeight ? .33 * a.chartHeight: a.chartHeight) + \"px\"\n"
                "},\n"
                "y || (k.textOverflow = \"ellipsis\"));\n"
                "if (this.labelAlign = p.align || this.autoLabelAlign(this.labelRotation)) f.align = this.labelAlign;\n"
                "c(h,\n"
                "function(a) {\n"
                    "var b = (a = m[a]) && a.label;\n"
                    "b && (b.attr(f), k && b.css(x(k, b.specCss)), delete b.specCss, a.rotation = f.rotation)\n"
                "});\n"
                "this.tickRotCorr = b.rotCorr(n.b, this.labelRotation || 0, 0 !== this.side)\n"
            "},\n"
            "hasData: function() {\n"
                "return this.hasVisibleSeries || k(this.min) && k(this.max) && !!this.tickPositions\n"
            "},\n"
            "addTitle: function(a) {\n"
                "var b = this.chart.renderer,\n"
                "c = this.horiz,\n"
                "g = this.opposite,\n"
                "e = this.options.title,\n"
                "h;\n"
                "this.axisTitle || ((h = e.textAlign) || (h = (c ? {\n"
                    "low: \"left\",\n"
                    "middle: \"center\",\n"
                    "high: \"right\"\n"
                "}: {\n"
                    "low: g ? \"right\": \"left\",\n"
                    "middle: \"center\",\n"
                    "high: g ? \"left\": \"right\"\n"
                "})[e.align]), this.axisTitle = b.text(e.text, 0, 0, e.useHTML).attr({\n"
                    "zIndex: 7,\n"
                    "rotation: e.rotation || 0,\n"
                    "align: h\n"
                "}).addClass(\"highcharts-axis-title\").css(e.style).add(this.axisGroup), this.axisTitle.isNew = !0);\n"
                "this.axisTitle[a ? \"show\": \"hide\"](!0)\n"
            "},\n"
            "generateTick: function(a) {\n"
                "var b = this.ticks;\n"
                "b[a] ? b[a].addLabel() : b[a] = new J(this, a)\n"
            "},\n"
            "getOffset: function() {\n"
                "var a = this,\n"
                "b = a.chart,\n"
                "e = b.renderer,\n"
                "h = a.options,\n"
                "m = a.tickPositions,\n"
                "p = a.ticks,\n"
                "d = a.horiz,\n"
                "t = a.side,\n"
                "f = b.inverted ? [1, 0, 3, 2][t] : t,\n"
                "n,\n"
                "y,\n"
                "w = 0,\n"
                "x,\n"
                "D = 0,\n"
                "l = h.title,\n"
                "C = h.labels,\n"
                "q = 0,\n"
                "I = b.axisOffset,\n"
                "b = b.clipOffset,\n"
                "u = [ - 1, 1, 1, -1][t],\n"
                "z,\n"
                "r = h.className,\n"
                "K = a.axisParent,\n"
                "J = this.tickSize(\"tick\");\n"
                "n = a.hasData();\n"
                "a.showAxis = y = n || E(h.showEmpty, !0);\n"
                "a.staggerLines = a.horiz && C.staggerLines;\n"
                "a.axisGroup || (a.gridGroup = e.g(\"grid\").attr({\n"
                    "zIndex: h.gridZIndex || 1\n"
                "}).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (r || \"\")).add(K), a.axisGroup = e.g(\"axis\").attr({\n"
                    "zIndex: h.zIndex || 2\n"
                "}).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (r || \"\")).add(K), a.labelGroup = e.g(\"axis-labels\").attr({\n"
                    "zIndex: C.zIndex || 7\n"
                "}).addClass(\"highcharts-\" + a.coll.toLowerCase() + \"-labels \" + (r || \"\")).add(K));\n"
                "if (n || a.isLinked) c(m,\n"
                "function(b, c) {\n"
                    "a.generateTick(b, c)\n"
                "}),\n"
                "a.renderUnsquish(),\n"
                "!1 === C.reserveSpace || 0 !== t && 2 !== t && {\n"
                    "1 : \"left\",\n"
                    "3 : \"right\"\n"
                "} [t] !== a.labelAlign && \"center\" !== a.labelAlign || c(m,\n"
                "function(a) {\n"
                    "q = Math.max(p[a].getLabelSize(), q)\n"
                "}),\n"
                "a.staggerLines && (q *= a.staggerLines, a.labelOffset = q * (a.opposite ? -1 : 1));\n"
                "else for (z in p) p[z].destroy(),\n"
                "delete p[z];\n"
                "l && l.text && !1 !== l.enabled && (a.addTitle(y), y && (w = a.axisTitle.getBBox()[d ? \"height\": \"width\"], x = l.offset, D = k(x) ? 0 : E(l.margin, d ? 5 : 10)));\n"
                "a.renderLine();\n"
                "a.offset = u * E(h.offset, I[t]);\n"
                "a.tickRotCorr = a.tickRotCorr || {\n"
                    "x: 0,\n"
                    "y: 0\n"
                "};\n"
                "e = 0 === t ? -a.labelMetrics().h: 2 === t ? a.tickRotCorr.y: 0;\n"
                "D = Math.abs(q) + D;\n"
                "q && (D = D - e + u * (d ? E(C.y, a.tickRotCorr.y + 8 * u) : C.x));\n"
                "a.axisTitleMargin = E(x, D);\n"
                "I[t] = Math.max(I[t], a.axisTitleMargin + w + u * a.offset, D, n && m.length && J ? J[0] + u * a.offset: 0);\n"
                "h = h.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);\n"
                "b[f] = Math.max(b[f], h)\n"
            "},\n"
            "getLinePath: function(a) {\n"
                "var b = this.chart,\n"
                "c = this.opposite,\n"
                "g = this.offset,\n"
                "e = this.horiz,\n"
                "h = this.left + (c ? this.width: 0) + g,\n"
                "g = b.chartHeight - this.bottom - (c ? this.height: 0) + g;\n"
                "c && (a *= -1);\n"
                "return b.renderer.crispLine([\"M\", e ? this.left: h, e ? g: this.top, \"L\", e ? b.chartWidth - this.right: h, e ? g: b.chartHeight - this.bottom], a)\n"
            "},\n"
            "renderLine: function() {\n"
                "this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.axisLine.attr({\n"
                    "stroke: this.options.lineColor,\n"
                    "\"stroke-width\": this.options.lineWidth,\n"
                    "zIndex: 7\n"
                "}))\n"
            "},\n"
            "getTitlePosition: function() {\n"
                "var a = this.horiz,\n"
                "b = this.left,\n"
                "c = this.top,\n"
                "e = this.len,\n"
                "h = this.options.title,\n"
                "m = a ? b: c,\n"
                "p = this.opposite,\n"
                "d = this.offset,\n"
                "t = h.x || 0,\n"
                "f = h.y || 0,\n"
                "n = this.chart.renderer.fontMetrics(h.style && h.style.fontSize, this.axisTitle).f,\n"
                "e = {\n"
                    "low: m + (a ? 0 : e),\n"
                    "middle: m + e / 2,\n"
                    "high: m + (a ? e: 0)\n"
                "} [h.align],\n"
                "b = (a ? c + this.height: b) + (a ? 1 : -1) * (p ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? n: 0);\n"
                "return {\n"
                    "x: a ? e + t: b + (p ? this.width: 0) + d + t,\n"
                    "y: a ? b + f - (p ? this.height: 0) + d: e + f\n"
                "}\n"
            "},\n"
            "renderMinorTick: function(a) {\n"
                "var b = this.chart.hasRendered && w(this.oldMin),\n"
                "c = this.minorTicks;\n"
                "c[a] || (c[a] = new J(this, a, \"minor\"));\n"
                "b && c[a].isNew && c[a].render(null, !0);\n"
                "c[a].render(null, !1, 1)\n"
            "},\n"
            "renderTick: function(a, b) {\n"
                "var c = this.isLinked,\n"
                "g = this.ticks,\n"
                "e = this.chart.hasRendered && w(this.oldMin);\n"
                "if (!c || a >= this.min && a <= this.max) g[a] || (g[a] = new J(this, a)),\n"
                "e && g[a].isNew && g[a].render(b, !0, .1),\n"
                "g[a].render(b)\n"
            "},\n"
            "render: function() {\n"
                "var a = this,\n"
                "b = a.chart,\n"
                "e = a.options,\n"
                "h = a.isLog,\n"
                "p = a.lin2log,\n"
                "d = a.isLinked,\n"
                "t = a.tickPositions,\n"
                "f = a.axisTitle,\n"
                "n = a.ticks,\n"
                "y = a.minorTicks,\n"
                "k = a.alternateBands,\n"
                "w = e.stackLabels,\n"
                "x = e.alternateGridColor,\n"
                "D = a.tickmarkOffset,\n"
                "l = a.axisLine,\n"
                "C = a.showAxis,\n"
                "q = A(b.renderer.globalAnimation),\n"
                "I,\n"
                "E;\n"
                "a.labelEdge.length = 0;\n"
                "a.overlap = !1;\n"
                "c([n, y, k],\n"
                "function(a) {\n"
                    "for (var b in a) a[b].isActive = !1\n"
                "});\n"
                "if (a.hasData() || d) a.minorTickInterval && !a.categories && c(a.getMinorTickPositions(),\n"
                "function(b) {\n"
                    "a.renderMinorTick(b)\n"
                "}),\n"
                "t.length && (c(t,\n"
                "function(b, c) {\n"
                    "a.renderTick(b, c)\n"
                "}), D && (0 === a.min || a.single) && (n[ - 1] || (n[ - 1] = new J(a, -1, null, !0)), n[ - 1].render( - 1))),\n"
                "x && c(t,\n"
                "function(c, e) {\n"
                    "E = void 0 !== t[e + 1] ? t[e + 1] + D: a.max - D;\n"
                    "0 === e % 2 && c < a.max && E <= a.max + (b.polar ? -D: D) && (k[c] || (k[c] = new m(a)), I = c + D, k[c].options = {\n"
                        "from: h ? p(I) : I,\n"
                        "to: h ? p(E) : E,\n"
                        "color: x\n"
                    "},\n"
                    "k[c].render(), k[c].isActive = !0)\n"
                "}),\n"
                "a._addedPlotLB || (c((e.plotLines || []).concat(e.plotBands || []),\n"
                "function(b) {\n"
                    "a.addPlotBandOrLine(b)\n"
                "}), a._addedPlotLB = !0);\n"
                "c([n, y, k],\n"
                "function(a) {\n"
                    "var c, e, g = [],\n"
                    "h = q.duration;\n"
                    "for (c in a) a[c].isActive || (a[c].render(c, !1, 0), a[c].isActive = !1, g.push(c));\n"
                    "K(function() {\n"
                        "for (e = g.length; e--;) a[g[e]] && !a[g[e]].isActive && (a[g[e]].destroy(), delete a[g[e]])\n"
                    "},\n"
                    "a !== k && b.hasRendered && h ? h: 0)\n"
                "});\n"
                "l && (l[l.isPlaced ? \"animate\": \"attr\"]({\n"
                    "d: this.getLinePath(l.strokeWidth())\n"
                "}), l.isPlaced = !0, l[C ? \"show\": \"hide\"](!0));\n"
                "f && C && (f[f.isNew ? \"attr\": \"animate\"](a.getTitlePosition()), f.isNew = !1);\n"
                "w && w.enabled && a.renderStackTotals();\n"
                "a.isDirty = !1\n"
            "},\n"
            "redraw: function() {\n"
                "this.visible && (this.render(), c(this.plotLinesAndBands,\n"
                "function(a) {\n"
                    "a.render()\n"
                "}));\n"
                "c(this.series,\n"
                "function(a) {\n"
                    "a.isDirty = !0\n"
                "})\n"
            "},\n"
            "keepProps: \"extKey hcEvents names series userMax userMin\".split(\" \"),\n"
            "destroy: function(a) {\n"
                "var b = this,\n"
                "e = b.stacks,\n"
                "g, h = b.plotLinesAndBands,\n"
                "m, p;\n"
                "a || y(b);\n"
                "for (g in e) d(e[g]),\n"
                "e[g] = null;\n"
                "c([b.ticks, b.minorTicks, b.alternateBands],\n"
                "function(a) {\n"
                    "d(a)\n"
                "});\n"
                "if (h) for (a = h.length; a--;) h[a].destroy();\n"
                "c(\"stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross\".split(\" \"),\n"
                "function(a) {\n"
                    "b[a] && (b[a] = b[a].destroy())\n"
                "});\n"
                "for (m in b.plotLinesAndBandsGroups) b.plotLinesAndBandsGroups[m] = b.plotLinesAndBandsGroups[m].destroy();\n"
                "for (p in b) b.hasOwnProperty(p) && -1 === t(p, b.keepProps) && delete b[p]\n"
            "},\n"
            "drawCrosshair: function(a, b) {\n"
                "var c, e = this.crosshair,\n"
                "g = E(e.snap, !0),\n"
                "h,\n"
                "m = this.cross;\n"
                "a || (a = this.cross && this.cross.e);\n"
                "this.crosshair && !1 !== (k(b) || !g) ? (g ? k(b) && (h = this.isXAxis ? b.plotX: this.len - b.plotY) : h = a && (this.horiz ? a.chartX - this.pos: this.len - a.chartY + this.pos), k(h) && (c = this.getPlotLinePath(b && (this.isXAxis ? b.x: E(b.stackY, b.y)), null, null, null, h) || null), k(c) ? (b = this.categories && !this.isRadial, m || (this.cross = m = this.chart.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (b ? \"category \": \"thin \") + e.className).attr({\n"
                    "zIndex: E(e.zIndex, 2)\n"
                "}).add(), m.attr({\n"
                    "stroke: e.color || (b ? f(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n"
                    "\"stroke-width\": E(e.width, 1)\n"
                "}), e.dashStyle && m.attr({\n"
                    "dashstyle: e.dashStyle\n"
                "})), m.show().attr({\n"
                    "d: c\n"
                "}), b && !e.width && m.attr({\n"
                    "\"stroke-width\": this.transA\n"
                "}), this.cross.e = a) : this.hideCrosshair()) : this.hideCrosshair()\n"
            "},\n"
            "hideCrosshair: function() {\n"
                "this.cross && this.cross.hide()\n"
            "}\n"
        "};\n"
        "n(a.Axis.prototype, r)\n"
    "})(L); (function(a) {\n"
        "var B = a.Axis,\n"
        "A = a.Date,\n"
        "H = a.dateFormat,\n"
        "G = a.defaultOptions,\n"
        "r = a.defined,\n"
        "f = a.each,\n"
        "l = a.extend,\n"
        "q = a.getMagnitude,\n"
        "k = a.getTZOffset,\n"
        "u = a.normalizeTickInterval,\n"
        "d = a.pick,\n"
        "c = a.timeUnits;\n"
        "B.prototype.getTimeTicks = function(a, q, b, p) {\n"
            "var h = [],\n"
            "t = {},\n"
            "n = G.global.useUTC,\n"
            "w,\n"
            "e = new A(q - Math.abs(k(q))),\n"
            "x = A.hcMakeTime,\n"
            "C = a.unitRange,\n"
            "E = a.count,\n"
            "m;\n"
            "if (r(q)) {\n"
                "e[A.hcSetMilliseconds](C >= c.second ? 0 : E * Math.floor(e.getMilliseconds() / E));\n"
                "if (C >= c.second) e[A.hcSetSeconds](C >= c.minute ? 0 : E * Math.floor(e.getSeconds() / E));\n"
                "if (C >= c.minute) e[A.hcSetMinutes](C >= c.hour ? 0 : E * Math.floor(e[A.hcGetMinutes]() / E));\n"
                "if (C >= c.hour) e[A.hcSetHours](C >= c.day ? 0 : E * Math.floor(e[A.hcGetHours]() / E));\n"
                "if (C >= c.day) e[A.hcSetDate](C >= c.month ? 1 : E * Math.floor(e[A.hcGetDate]() / E));\n"
                "C >= c.month && (e[A.hcSetMonth](C >= c.year ? 0 : E * Math.floor(e[A.hcGetMonth]() / E)), w = e[A.hcGetFullYear]());\n"
                "if (C >= c.year) e[A.hcSetFullYear](w - w % E);\n"
                "if (C === c.week) e[A.hcSetDate](e[A.hcGetDate]() - e[A.hcGetDay]() + d(p, 1));\n"
                "w = e[A.hcGetFullYear]();\n"
                "p = e[A.hcGetMonth]();\n"
                "var y = e[A.hcGetDate](),\n"
                "I = e[A.hcGetHours]();\n"
                "if (A.hcTimezoneOffset || A.hcGetTimezoneOffset) m = (!n || !!A.hcGetTimezoneOffset) && (b - q > 4 * c.month || k(q) !== k(b)),\n"
                "e = e.getTime(),\n"
                "e = new A(e + k(e));\n"
                "n = e.getTime();\n"
                "for (q = 1; n < b;) h.push(n),\n"
                "n = C === c.year ? x(w + q * E, 0) : C === c.month ? x(w, p + q * E) : !m || C !== c.day && C !== c.week ? m && C === c.hour ? x(w, p, y, I + q * E) : n + C * E: x(w, p, y + q * E * (C === c.day ? 1 : 7)),\n"
                "q++;\n"
                "h.push(n);\n"
                "C <= c.hour && 1E4 > h.length && f(h,\n"
                "function(a) {\n"
                    "0 === a % 18E5 && \"000000000\" === H(\"%H%M%S%L\", a) && (t[a] = \"day\")\n"
                "})\n"
            "}\n"
            "h.info = l(a, {\n"
                "higherRanks: t,\n"
                "totalRange: C * E\n"
            "});\n"
            "return h\n"
        "};\n"
        "B.prototype.normalizeTimeTickInterval = function(a, d) {\n"
            "var b = d || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n"
            "d = b[b.length - 1];\n"
            "var p = c[d[0]],\n"
            "h = d[1],\n"
            "t;\n"
            "for (t = 0; t < b.length && !(d = b[t], p = c[d[0]], h = d[1], b[t + 1] && a <= (p * h[h.length - 1] + c[b[t + 1][0]]) / 2); t++);\n"
            "p === c.year && a < 5 * p && (h = [1, 2, 5]);\n"
            "a = u(a / p, h, \"year\" === d[0] ? Math.max(q(a / p), 1) : 1);\n"
            "return {\n"
                "unitRange: p,\n"
                "count: a,\n"
                "unitName: d[0]\n"
            "}\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.Axis,\n"
        "A = a.getMagnitude,\n"
        "H = a.map,\n"
        "G = a.normalizeTickInterval,\n"
        "r = a.pick;\n"
        "B.prototype.getLogTickPositions = function(a, l, q, k) {\n"
            "var f = this.options,\n"
            "d = this.len,\n"
            "c = this.lin2log,\n"
            "n = this.log2lin,\n"
            "z = [];\n"
            "k || (this._minorAutoInterval = null);\n"
            "if (.5 <= a) a = Math.round(a),\n"
            "z = this.getLinearTickPositions(a, l, q);\n"
            "else if (.08 <= a) for (var d = Math.floor(l), b, p, h, t, D, f = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; d < q + 1 && !D; d++) for (p = f.length, b = 0; b < p && !D; b++) h = n(c(d) * f[b]),\n"
            "h > l && (!k || t <= q) && void 0 !== t && z.push(t),\n"
            "t > q && (D = !0),\n"
            "t = h;\n"
            "else l = c(l),\n"
            "q = c(q),\n"
            "a = f[k ? \"minorTickInterval\": \"tickInterval\"],\n"
            "a = r(\"auto\" === a ? null: a, this._minorAutoInterval, f.tickPixelInterval / (k ? 5 : 1) * (q - l) / ((k ? d / this.tickPositions.length: d) || 1)),\n"
            "a = G(a, null, A(a)),\n"
            "z = H(this.getLinearTickPositions(a, l, q), n),\n"
            "k || (this._minorAutoInterval = a / 5);\n"
            "k || (this.tickInterval = a);\n"
            "return z\n"
        "};\n"
        "B.prototype.log2lin = function(a) {\n"
            "return Math.log(a) / Math.LN10\n"
        "};\n"
        "B.prototype.lin2log = function(a) {\n"
            "return Math.pow(10, a)\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.dateFormat,\n"
        "A = a.each,\n"
        "H = a.extend,\n"
        "G = a.format,\n"
        "r = a.isNumber,\n"
        "f = a.map,\n"
        "l = a.merge,\n"
        "q = a.pick,\n"
        "k = a.splat,\n"
        "u = a.syncTimeout,\n"
        "d = a.timeUnits;\n"
        "a.Tooltip = function() {\n"
            "this.init.apply(this, arguments)\n"
        "};\n"
        "a.Tooltip.prototype = {\n"
            "init: function(a, d) {\n"
                "this.chart = a;\n"
                "this.options = d;\n"
                "this.crosshairs = [];\n"
                "this.now = {\n"
                    "x: 0,\n"
                    "y: 0\n"
                "};\n"
                "this.isHidden = !0;\n"
                "this.split = d.split && !a.inverted;\n"
                "this.shared = d.shared || this.split\n"
            "},\n"
            "cleanSplit: function(a) {\n"
                "A(this.chart.series,\n"
                "function(c) {\n"
                    "var d = c && c.tt;\n"
                    "d && (!d.isActive || a ? c.tt = d.destroy() : d.isActive = !1)\n"
                "})\n"
            "},\n"
            "getLabel: function() {\n"
                "var a = this.chart.renderer,\n"
                "d = this.options;\n"
                "this.label || (this.split ? this.label = a.g(\"tooltip\") : (this.label = a.label(\"\", 0, 0, d.shape || \"callout\", null, null, d.useHTML, null, \"tooltip\").attr({\n"
                    "padding: d.padding,\n"
                    "r: d.borderRadius\n"
                "}), this.label.attr({\n"
                    "fill: d.backgroundColor,\n"
                    "\"stroke-width\": d.borderWidth\n"
                "}).css(d.style).shadow(d.shadow)), this.label.attr({\n"
                    "zIndex: 8\n"
                "}).add());\n"
                "return this.label\n"
            "},\n"
            "update: function(a) {\n"
                "this.destroy();\n"
                "this.init(this.chart, l(!0, this.options, a))\n"
            "},\n"
            "destroy: function() {\n"
                "this.label && (this.label = this.label.destroy());\n"
                "this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n"
                "clearTimeout(this.hideTimer);\n"
                "clearTimeout(this.tooltipTimeout)\n"
            "},\n"
            "move: function(a, d, f, b) {\n"
                "var c = this,\n"
                "h = c.now,\n"
                "t = !1 !== c.options.animation && !c.isHidden && (1 < Math.abs(a - h.x) || 1 < Math.abs(d - h.y)),\n"
                "n = c.followPointer || 1 < c.len;\n"
                "H(h, {\n"
                    "x: t ? (2 * h.x + a) / 3 : a,\n"
                    "y: t ? (h.y + d) / 2 : d,\n"
                    "anchorX: n ? void 0 : t ? (2 * h.anchorX + f) / 3 : f,\n"
                    "anchorY: n ? void 0 : t ? (h.anchorY + b) / 2 : b\n"
                "});\n"
                "c.getLabel().attr(h);\n"
                "t && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {\n"
                    "c && c.move(a, d, f, b)\n"
                "},\n"
                "32))\n"
            "},\n"
            "hide: function(a) {\n"
                "var c = this;\n"
                "clearTimeout(this.hideTimer);\n"
                "a = q(a, this.options.hideDelay, 500);\n"
                "this.isHidden || (this.hideTimer = u(function() {\n"
                    "c.getLabel()[a ? \"fadeOut\": \"hide\"]();\n"
                    "c.isHidden = !0\n"
                "},\n"
                "a))\n"
            "},\n"
            "getAnchor: function(a, d) {\n"
                "var c, b = this.chart,\n"
                "p = b.inverted,\n"
                "h = b.plotTop,\n"
                "t = b.plotLeft,\n"
                "n = 0,\n"
                "w = 0,\n"
                "e, x;\n"
                "a = k(a);\n"
                "c = a[0].tooltipPos;\n"
                "this.followPointer && d && (void 0 === d.chartX && (d = b.pointer.normalize(d)), c = [d.chartX - b.plotLeft, d.chartY - h]);\n"
                "c || (A(a,\n"
                "function(a) {\n"
                    "e = a.series.yAxis;\n"
                    "x = a.series.xAxis;\n"
                    "n += a.plotX + (!p && x ? x.left - t: 0);\n"
                    "w += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!p && e ? e.top - h: 0)\n"
                "}), n /= a.length, w /= a.length, c = [p ? b.plotWidth - w: n, this.shared && !p && 1 < a.length && d ? d.chartY - h: p ? b.plotHeight - n: w]);\n"
                "return f(c, Math.round)\n"
            "},\n"
            "getPosition: function(a, d, f) {\n"
                "var b = this.chart,\n"
                "c = this.distance,\n"
                "h = {},\n"
                "t = f.h || 0,\n"
                "n, k = [\"y\", b.chartHeight, d, f.plotY + b.plotTop, b.plotTop, b.plotTop + b.plotHeight],\n"
                "e = [\"x\", b.chartWidth, a, f.plotX + b.plotLeft, b.plotLeft, b.plotLeft + b.plotWidth],\n"
                "x = !this.followPointer && q(f.ttBelow, !b.inverted === !!f.negative),\n"
                "l = function(a, b, e, g, m, d) {\n"
                    "var p = e < g - c,\n"
                    "f = g + c + e < b,\n"
                    "n = g - c - e;\n"
                    "g += c;\n"
                    "if (x && f) h[a] = g;\n"
                    "else if (!x && p) h[a] = n;\n"
                    "else if (p) h[a] = Math.min(d - e, 0 > n - t ? n: n - t);\n"
                    "else if (f) h[a] = Math.max(m, g + t + e > b ? g: g + t);\n"
                    "else return ! 1\n"
                "},\n"
                "E = function(a, b, e, g) {\n"
                    "var m;\n"
                    "g < c || g > b - c ? m = !1 : h[a] = g < e / 2 ? 1 : g > b - e / 2 ? b - e - 2 : g - e / 2;\n"
                    "return m\n"
                "},\n"
                "m = function(a) {\n"
                    "var b = k;\n"
                    "k = e;\n"
                    "e = b;\n"
                    "n = a\n"
                "},\n"
                "y = function() { ! 1 !== l.apply(0, k) ? !1 !== E.apply(0, e) || n || (m(!0), y()) : n ? h.x = h.y = 0 : (m(!0), y())\n"
                "}; (b.inverted || 1 < this.len) && m();\n"
                "y();\n"
                "return h\n"
            "},\n"
            "defaultFormatter: function(a) {\n"
                "var c = this.points || k(this),\n"
                "d;\n"
                "d = [a.tooltipFooterHeaderFormatter(c[0])];\n"
                "d = d.concat(a.bodyFormatter(c));\n"
                "d.push(a.tooltipFooterHeaderFormatter(c[0], !0));\n"
                "return d\n"
            "},\n"
            "refresh: function(a, d) {\n"
                "var c, b = this.options,\n"
                "p, h = a,\n"
                "t, f = {},\n"
                "n = [];\n"
                "c = b.formatter || this.defaultFormatter;\n"
                "var f = this.shared,\n"
                "e;\n"
                "clearTimeout(this.hideTimer);\n"
                "this.followPointer = k(h)[0].series.tooltipOptions.followPointer;\n"
                "t = this.getAnchor(h, d);\n"
                "d = t[0];\n"
                "p = t[1]; ! f || h.series && h.series.noSharedTooltip ? f = h.getLabelConfig() : (A(h,\n"
                "function(a) {\n"
                    "a.setState(\"hover\");\n"
                    "n.push(a.getLabelConfig())\n"
                "}), f = {\n"
                    "x: h[0].category,\n"
                    "y: h[0].y\n"
                "},\n"
                "f.points = n, h = h[0]);\n"
                "this.len = n.length;\n"
                "f = c.call(f, this);\n"
                "e = h.series;\n"
                "this.distance = q(e.tooltipOptions.distance, 16); ! 1 === f ? this.hide() : (c = this.getLabel(), this.isHidden && c.attr({\n"
                    "opacity: 1\n"
                "}).show(), this.split ? this.renderSplit(f, a) : (c.attr({\n"
                    "text: f && f.join ? f.join(\"\") : f\n"
                "}), c.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + q(h.colorIndex, e.colorIndex)), c.attr({\n"
                    "stroke: b.borderColor || h.color || e.color || \"#666666\"\n"
                "}), this.updatePosition({\n"
                    "plotX: d,\n"
                    "plotY: p,\n"
                    "negative: h.negative,\n"
                    "ttBelow: h.ttBelow,\n"
                    "h: t[2] || 0\n"
                "})), this.isHidden = !1)\n"
            "},\n"
            "renderSplit: function(c, d) {\n"
                "var f = this,\n"
                "b = [],\n"
                "p = this.chart,\n"
                "h = p.renderer,\n"
                "t = !0,\n"
                "n = this.options,\n"
                "k,\n"
                "e = this.getLabel();\n"
                "A(c.slice(0, d.length + 1),\n"
                "function(a, c) {\n"
                    "c = d[c - 1] || {\n"
                        "isHeader: !0,\n"
                        "plotX: d[0].plotX\n"
                    "};\n"
                    "var w = c.series || f,\n"
                    "m = w.tt,\n"
                    "y = c.series || {},\n"
                    "x = \"highcharts-color-\" + q(c.colorIndex, y.colorIndex, \"none\");\n"
                    "m || (w.tt = m = h.label(null, null, null, \"callout\").addClass(\"highcharts-tooltip-box \" + x).attr({\n"
                        "padding: n.padding,\n"
                        "r: n.borderRadius,\n"
                        "fill: n.backgroundColor,\n"
                        "stroke: c.color || y.color || \"#333333\",\n"
                        "\"stroke-width\": n.borderWidth\n"
                    "}).add(e));\n"
                    "m.isActive = !0;\n"
                    "m.attr({\n"
                        "text: a\n"
                    "});\n"
                    "m.css(n.style);\n"
                    "a = m.getBBox();\n"
                    "y = a.width + m.strokeWidth();\n"
                    "c.isHeader ? (k = a.height, y = Math.max(0, Math.min(c.plotX + p.plotLeft - y / 2, p.chartWidth - y))) : y = c.plotX + p.plotLeft - q(n.distance, 16) - y;\n"
                    "0 > y && (t = !1);\n"
                    "a = (c.series && c.series.yAxis && c.series.yAxis.pos) + (c.plotY || 0);\n"
                    "a -= p.plotTop;\n"
                    "b.push({\n"
                        "target: c.isHeader ? p.plotHeight + k: a,\n"
                        "rank: c.isHeader ? 1 : 0,\n"
                        "size: w.tt.getBBox().height + 1,\n"
                        "point: c,\n"
                        "x: y,\n"
                        "tt: m\n"
                    "})\n"
                "});\n"
                "this.cleanSplit();\n"
                "a.distribute(b, p.plotHeight + k);\n"
                "A(b,\n"
                "function(a) {\n"
                    "var b = a.point,\n"
                    "c = b.series;\n"
                    "a.tt.attr({\n"
                        "visibility: void 0 === a.pos ? \"hidden\": \"inherit\",\n"
                        "x: t || b.isHeader ? a.x: b.plotX + p.plotLeft + q(n.distance, 16),\n"
                        "y: a.pos + p.plotTop,\n"
                        "anchorX: b.isHeader ? b.plotX + p.plotLeft: b.plotX + c.xAxis.pos,\n"
                        "anchorY: b.isHeader ? a.pos + p.plotTop - 15 : b.plotY + c.yAxis.pos\n"
                    "})\n"
                "})\n"
            "},\n"
            "updatePosition: function(a) {\n"
                "var c = this.chart,\n"
                "d = this.getLabel(),\n"
                "d = (this.options.positioner || this.getPosition).call(this, d.width, d.height, a);\n"
                "this.move(Math.round(d.x), Math.round(d.y || 0), a.plotX + c.plotLeft, a.plotY + c.plotTop)\n"
            "},\n"
            "getDateFormat: function(a, f, k, b) {\n"
                "var c = B(\"%m-%d %H:%M:%S.%L\", f),\n"
                "h,\n"
                "t,\n"
                "n = {\n"
                    "millisecond: 15,\n"
                    "second: 12,\n"
                    "minute: 9,\n"
                    "hour: 6,\n"
                    "day: 3\n"
                "},\n"
                "w = \"millisecond\";\n"
                "for (t in d) {\n"
                    "if (a === d.week && +B(\"%w\", f) === k && \"00:00:00.000\" === c.substr(6)) {\n"
                        "t = \"week\";\n"
                        "break\n"
                    "}\n"
                    "if (d[t] > a) {\n"
                        "t = w;\n"
                        "break\n"
                    "}\n"
                    "if (n[t] && c.substr(n[t]) !== \"01-01 00:00:00.000\".substr(n[t])) break;\n"
                    "\"week\" !== t && (w = t)\n"
                "}\n"
                "t && (h = b[t]);\n"
                "return h\n"
            "},\n"
            "getXDateFormat: function(a, d, f) {\n"
                "d = d.dateTimeLabelFormats;\n"
                "var b = f && f.closestPointRange;\n"
                "return (b ? this.getDateFormat(b, a.x, f.options.startOfWeek, d) : d.day) || d.year\n"
            "},\n"
            "tooltipFooterHeaderFormatter: function(a, d) {\n"
                "var c = d ? \"footer\": \"header\";\n"
                "d = a.series;\n"
                "var b = d.tooltipOptions,\n"
                "p = b.xDateFormat,\n"
                "h = d.xAxis,\n"
                "t = h && \"datetime\" === h.options.type && r(a.key),\n"
                "c = b[c + \"Format\"];\n"
                "t && !p && (p = this.getXDateFormat(a, b, h));\n"
                "t && p && (c = c.replace(\"{point.key}\", \"{point.key:\" + p + \"}\"));\n"
                "return G(c, {\n"
                    "point: a,\n"
                    "series: d\n"
                "})\n"
            "},\n"
            "bodyFormatter: function(a) {\n"
                "return f(a,\n"
                "function(a) {\n"
                    "var c = a.series.tooltipOptions;\n"
                    "return (c.pointFormatter || a.point.tooltipFormatter).call(a.point, c.pointFormat)\n"
                "})\n"
            "}\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.attr,\n"
        "H = a.charts,\n"
        "G = a.color,\n"
        "r = a.css,\n"
        "f = a.defined,\n"
        "l = a.doc,\n"
        "q = a.each,\n"
        "k = a.extend,\n"
        "u = a.fireEvent,\n"
        "d = a.offset,\n"
        "c = a.pick,\n"
        "n = a.removeEvent,\n"
        "z = a.splat,\n"
        "b = a.Tooltip,\n"
        "p = a.win;\n"
        "a.Pointer = function(a, b) {\n"
            "this.init(a, b)\n"
        "};\n"
        "a.Pointer.prototype = {\n"
            "init: function(a, d) {\n"
                "this.options = d;\n"
                "this.chart = a;\n"
                "this.runChartClick = d.chart.events && !!d.chart.events.click;\n"
                "this.pinchDown = [];\n"
                "this.lastValidTouch = {};\n"
                "b && d.tooltip.enabled && (a.tooltip = new b(a, d.tooltip), this.followTouchMove = c(d.tooltip.followTouchMove, !0));\n"
                "this.setDOMEvents()\n"
            "},\n"
            "zoomOption: function(a) {\n"
                "var b = this.chart,\n"
                "h = b.options.chart,\n"
                "d = h.zoomType || \"\",\n"
                "b = b.inverted;\n"
                "/touch/.test(a.type) && (d = c(h.pinchType, d));\n"
                "this.zoomX = a = /x/.test(d);\n"
                "this.zoomY = d = /y/.test(d);\n"
                "this.zoomHor = a && !b || d && b;\n"
                "this.zoomVert = d && !b || a && b;\n"
                "this.hasZoom = a || d\n"
            "},\n"
            "normalize: function(a, b) {\n"
                "var c, h;\n"
                "a = a || p.event;\n"
                "a.target || (a.target = a.srcElement);\n"
                "h = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;\n"
                "b || (this.chartPosition = b = d(this.chart.container));\n"
                "void 0 === h.pageX ? (c = Math.max(a.x, a.clientX - b.left), b = a.y) : (c = h.pageX - b.left, b = h.pageY - b.top);\n"
                "return k(a, {\n"
                    "chartX: Math.round(c),\n"
                    "chartY: Math.round(b)\n"
                "})\n"
            "},\n"
            "getCoordinates: function(a) {\n"
                "var b = {\n"
                    "xAxis: [],\n"
                    "yAxis: []\n"
                "};\n"
                "q(this.chart.axes,\n"
                "function(c) {\n"
                    "b[c.isXAxis ? \"xAxis\": \"yAxis\"].push({\n"
                        "axis: c,\n"
                        "value: c.toValue(a[c.horiz ? \"chartX\": \"chartY\"])\n"
                    "})\n"
                "});\n"
                "return b\n"
            "},\n"
            "getKDPoints: function(a, b, d) {\n"
                "var h = [],\n"
                "e,\n"
                "p,\n"
                "f;\n"
                "q(a,\n"
                "function(a) {\n"
                    "e = a.noSharedTooltip && b;\n"
                    "p = !b && a.directTouch;\n"
                    "a.visible && !p && c(a.options.enableMouseTracking, !0) && (f = a.searchPoint(d, !e && 0 > a.options.findNearestPointBy.indexOf(\"y\"))) && f.series && h.push(f)\n"
                "});\n"
                "h.sort(function(a, c) {\n"
                    "var e = a.distX - c.distX,\n"
                    "h = a.dist - c.dist,\n"
                    "m = (c.series.group && c.series.group.zIndex) - (a.series.group && a.series.group.zIndex);\n"
                    "return 0 !== e && b ? e: 0 !== h ? h: 0 !== m ? m: a.series.index > c.series.index ? -1 : 1\n"
                "});\n"
                "if (b && h[0] && !h[0].series.noSharedTooltip) for (a = h.length; a--;)(h[a].x !== h[0].x || h[a].series.noSharedTooltip) && h.splice(a, 1);\n"
                "return h\n"
            "},\n"
            "getPointFromEvent: function(a) {\n"
                "a = a.target;\n"
                "for (var b; a && !b;) b = a.point,\n"
                "a = a.parentNode;\n"
                "return b\n"
            "},\n"
            "getHoverData: function(b, d, p, f, e, n) {\n"
                "var h = b,\n"
                "t = d,\n"
                "m;\n"
                "f ? e ? (m = [], q(p,\n"
                "function(a) {\n"
                    "var b = a.noSharedTooltip && e,\n"
                    "d = !e && a.directTouch;\n"
                    "a.visible && !b && !d && c(a.options.enableMouseTracking, !0) && (a = a.searchKDTree({\n"
                        "clientX: h.clientX,\n"
                        "plotY: h.plotY\n"
                    "},\n"
                    "!b && 1 === a.kdDimensions)) && a.series && m.push(a)\n"
                "}), 0 === m.length && (m = [h])) : m = [h] : t && !t.stickyTracking ? (e || (p = [t]), m = this.getKDPoints(p, e, n), h = a.find(m,\n"
                "function(a) {\n"
                    "return a.series === t\n"
                "})) : (b = a.grep(p,\n"
                "function(a) {\n"
                    "return a.stickyTracking\n"
                "}), m = this.getKDPoints(b, e, n), t = (h = m[0]) && h.series, e && (m = this.getKDPoints(p, e, n)));\n"
                "m.sort(function(a, b) {\n"
                    "return a.series.index - b.series.index\n"
                "});\n"
                "return {\n"
                    "hoverPoint: h,\n"
                    "hoverSeries: t,\n"
                    "hoverPoints: m\n"
                "}\n"
            "},\n"
            "runPointActions: function(b, d) {\n"
                "var h = this.chart,\n"
                "p = h.tooltip,\n"
                "e = p ? p.shared: !1,\n"
                "f = d || h.hoverPoint,\n"
                "t = f && f.series || h.hoverSeries;\n"
                "d = this.getHoverData(f, t, h.series, !!d || !e && t && t.directTouch, e, b);\n"
                "var n, m, f = d.hoverPoint;\n"
                "n = (t = d.hoverSeries) && t.tooltipOptions.followPointer;\n"
                "m = (e = e && f && !f.series.noSharedTooltip) ? d.hoverPoints: f ? [f] : [];\n"
                "if (f && (f !== h.hoverPoint || p && p.isHidden)) {\n"
                    "q(h.hoverPoints || [],\n"
                    "function(b) { - 1 === a.inArray(b, m) && b.setState()\n"
                    "});\n"
                    "q(m || [],\n"
                    "function(a) {\n"
                        "a.setState(\"hover\")\n"
                    "});\n"
                    "if (h.hoverSeries !== t) t.onMouseOver();\n"
                    "t && !t.directTouch && (h.hoverPoint && h.hoverPoint.firePointEvent(\"mouseOut\"), f.firePointEvent(\"mouseOver\"));\n"
                    "h.hoverPoints = m;\n"
                    "h.hoverPoint = f;\n"
                    "p && p.refresh(e ? m: f, b)\n"
                "} else n && p && !p.isHidden && (f = p.getAnchor([{}], b), p.updatePosition({\n"
                    "plotX: f[0],\n"
                    "plotY: f[1]\n"
                "}));\n"
                "this.unDocMouseMove || (this.unDocMouseMove = B(l, \"mousemove\",\n"
                "function(b) {\n"
                    "var c = H[a.hoverChartIndex];\n"
                    "if (c) c.pointer.onDocumentMouseMove(b)\n"
                "}));\n"
                "q(h.axes,\n"
                "function(a) {\n"
                    "c(a.crosshair.snap, !0) ? q(m,\n"
                    "function(c) {\n"
                        "c.series[a.coll] === a && a.drawCrosshair(b, c)\n"
                    "}) : a.drawCrosshair(b)\n"
                "})\n"
            "},\n"
            "reset: function(a, b) {\n"
                "var c = this.chart,\n"
                "h = c.hoverSeries,\n"
                "e = c.hoverPoint,\n"
                "d = c.hoverPoints,\n"
                "p = c.tooltip,\n"
                "f = p && p.shared ? d: e;\n"
                "a && f && q(z(f),\n"
                "function(b) {\n"
                    "b.series.isCartesian && void 0 === b.plotX && (a = !1)\n"
                "});\n"
                "if (a) p && f && (p.refresh(f), e && (e.setState(e.state, !0), q(c.axes,\n"
                "function(a) {\n"
                    "a.crosshair && a.drawCrosshair(null, e)\n"
                "})));\n"
                "else {\n"
                    "if (e) e.onMouseOut();\n"
                    "d && q(d,\n"
                    "function(a) {\n"
                        "a.setState()\n"
                    "});\n"
                    "if (h) h.onMouseOut();\n"
                    "p && p.hide(b);\n"
                    "this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n"
                    "q(c.axes,\n"
                    "function(a) {\n"
                        "a.hideCrosshair()\n"
                    "});\n"
                    "this.hoverX = c.hoverPoints = c.hoverPoint = null\n"
                "}\n"
            "},\n"
            "scaleGroups: function(a, b) {\n"
                "var c = this.chart,\n"
                "h;\n"
                "q(c.series,\n"
                "function(e) {\n"
                    "h = a || e.getPlotBox();\n"
                    "e.xAxis && e.xAxis.zoomEnabled && e.group && (e.group.attr(h), e.markerGroup && (e.markerGroup.attr(h), e.markerGroup.clip(b ? c.clipRect: null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(h))\n"
                "});\n"
                "c.clipRect.attr(b || c.clipBox)\n"
            "},\n"
            "dragStart: function(a) {\n"
                "var b = this.chart;\n"
                "b.mouseIsDown = a.type;\n"
                "b.cancelClick = !1;\n"
                "b.mouseDownX = this.mouseDownX = a.chartX;\n"
                "b.mouseDownY = this.mouseDownY = a.chartY\n"
            "},\n"
            "drag: function(a) {\n"
                "var b = this.chart,\n"
                "c = b.options.chart,\n"
                "h = a.chartX,\n"
                "e = a.chartY,\n"
                "d = this.zoomHor,\n"
                "p = this.zoomVert,\n"
                "f = b.plotLeft,\n"
                "m = b.plotTop,\n"
                "n = b.plotWidth,\n"
                "k = b.plotHeight,\n"
                "l, q = this.selectionMarker,\n"
                "g = this.mouseDownX,\n"
                "u = this.mouseDownY,\n"
                "r = c.panKey && a[c.panKey + \"Key\"];\n"
                "q && q.touch || (h < f ? h = f: h > f + n && (h = f + n), e < m ? e = m: e > m + k && (e = m + k), this.hasDragged = Math.sqrt(Math.pow(g - h, 2) + Math.pow(u - e, 2)), 10 < this.hasDragged && (l = b.isInsidePlot(g - f, u - m), b.hasCartesianSeries && (this.zoomX || this.zoomY) && l && !r && !q && (this.selectionMarker = q = b.renderer.rect(f, m, d ? 1 : n, p ? 1 : k, 0).attr({\n"
                    "fill: c.selectionMarkerFill || G(\"#335cad\").setOpacity(.25).get(),\n"
                    "\"class\": \"highcharts-selection-marker\",\n"
                    "zIndex: 7\n"
                "}).add()), q && d && (h -= g, q.attr({\n"
                    "width: Math.abs(h),\n"
                    "x: (0 < h ? 0 : h) + g\n"
                "})), q && p && (h = e - u, q.attr({\n"
                    "height: Math.abs(h),\n"
                    "y: (0 < h ? 0 : h) + u\n"
                "})), l && !q && c.panning && b.pan(a, c.panning)))\n"
            "},\n"
            "drop: function(a) {\n"
                "var b = this,\n"
                "c = this.chart,\n"
                "h = this.hasPinched;\n"
                "if (this.selectionMarker) {\n"
                    "var e = {\n"
                        "originalEvent: a,\n"
                        "xAxis: [],\n"
                        "yAxis: []\n"
                    "},\n"
                    "d = this.selectionMarker,\n"
                    "p = d.attr ? d.attr(\"x\") : d.x,\n"
                    "n = d.attr ? d.attr(\"y\") : d.y,\n"
                    "m = d.attr ? d.attr(\"width\") : d.width,\n"
                    "y = d.attr ? d.attr(\"height\") : d.height,\n"
                    "l;\n"
                    "if (this.hasDragged || h) q(c.axes,\n"
                    "function(c) {\n"
                        "if (c.zoomEnabled && f(c.min) && (h || b[{\n"
                            "xAxis: \"zoomX\",\n"
                            "yAxis: \"zoomY\"\n"
                        "} [c.coll]])) {\n"
                            "var d = c.horiz,\n"
                            "g = \"touchend\" === a.type ? c.minPixelPadding: 0,\n"
                            "t = c.toValue((d ? p: n) + g),\n"
                            "d = c.toValue((d ? p + m: n + y) - g);\n"
                            "e[c.coll].push({\n"
                                "axis: c,\n"
                                "min: Math.min(t, d),\n"
                                "max: Math.max(t, d)\n"
                            "});\n"
                            "l = !0\n"
                        "}\n"
                    "}),\n"
                    "l && u(c, \"selection\", e,\n"
                    "function(a) {\n"
                        "c.zoom(k(a, h ? {\n"
                            "animation: !1\n"
                        "}: null))\n"
                    "});\n"
                    "this.selectionMarker = this.selectionMarker.destroy();\n"
                    "h && this.scaleGroups()\n"
                "}\n"
                "c && (r(c.container, {\n"
                    "cursor: c._cursor\n"
                "}), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [])\n"
            "},\n"
            "onContainerMouseDown: function(a) {\n"
                "a = this.normalize(a);\n"
                "this.zoomOption(a);\n"
                "a.preventDefault && a.preventDefault();\n"
                "this.dragStart(a)\n"
            "},\n"
            "onDocumentMouseUp: function(b) {\n"
                "H[a.hoverChartIndex] && H[a.hoverChartIndex].pointer.drop(b)\n"
            "},\n"
            "onDocumentMouseMove: function(a) {\n"
                "var b = this.chart,\n"
                "c = this.chartPosition;\n"
                "a = this.normalize(a, c); ! c || this.inClass(a.target, \"highcharts-tracker\") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset()\n"
            "},\n"
            "onContainerMouseLeave: function(b) {\n"
                "var c = H[a.hoverChartIndex];\n"
                "c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null)\n"
            "},\n"
            "onContainerMouseMove: function(b) {\n"
                "var c = this.chart;\n"
                "f(a.hoverChartIndex) && H[a.hoverChartIndex] && H[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);\n"
                "b = this.normalize(b);\n"
                "b.returnValue = !1;\n"
                "\"mousedown\" === c.mouseIsDown && this.drag(b); ! this.inClass(b.target, \"highcharts-tracker\") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b)\n"
            "},\n"
            "inClass: function(a, b) {\n"
                "for (var c; a;) {\n"
                    "if (c = A(a, \"class\")) {\n"
                        "if ( - 1 !== c.indexOf(b)) return ! 0;\n"
                        "if ( - 1 !== c.indexOf(\"highcharts-container\")) return ! 1\n"
                    "}\n"
                    "a = a.parentNode\n"
                "}\n"
            "},\n"
            "onTrackerMouseOut: function(a) {\n"
                "var b = this.chart.hoverSeries;\n"
                "a = a.relatedTarget || a.toElement;\n"
                "if (! (!b || !a || b.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + b.index) && this.inClass(a, \"highcharts-tracker\"))) b.onMouseOut()\n"
            "},\n"
            "onContainerClick: function(a) {\n"
                "var b = this.chart,\n"
                "c = b.hoverPoint,\n"
                "h = b.plotLeft,\n"
                "e = b.plotTop;\n"
                "a = this.normalize(a);\n"
                "b.cancelClick || (c && this.inClass(a.target, \"highcharts-tracker\") ? (u(c.series, \"click\", k(a, {\n"
                    "point: c\n"
                "})), b.hoverPoint && c.firePointEvent(\"click\", a)) : (k(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - h, a.chartY - e) && u(b, \"click\", a)))\n"
            "},\n"
            "setDOMEvents: function() {\n"
                "var b = this,\n"
                "c = b.chart.container;\n"
                "c.onmousedown = function(a) {\n"
                    "b.onContainerMouseDown(a)\n"
                "};\n"
                "c.onmousemove = function(a) {\n"
                    "b.onContainerMouseMove(a)\n"
                "};\n"
                "c.onclick = function(a) {\n"
                    "b.onContainerClick(a)\n"
                "};\n"
                "B(c, \"mouseleave\", b.onContainerMouseLeave);\n"
                "1 === a.chartCount && B(l, \"mouseup\", b.onDocumentMouseUp);\n"
                "a.hasTouch && (c.ontouchstart = function(a) {\n"
                    "b.onContainerTouchStart(a)\n"
                "},\n"
                "c.ontouchmove = function(a) {\n"
                    "b.onContainerTouchMove(a)\n"
                "},\n"
                "1 === a.chartCount && B(l, \"touchend\", b.onDocumentTouchEnd))\n"
            "},\n"
            "destroy: function() {\n"
                "var b;\n"
                "this.unDocMouseMove && this.unDocMouseMove();\n"
                "n(this.chart.container, \"mouseleave\", this.onContainerMouseLeave);\n"
                "a.chartCount || (n(l, \"mouseup\", this.onDocumentMouseUp), n(l, \"touchend\", this.onDocumentTouchEnd));\n"
                "clearInterval(this.tooltipTimeout);\n"
                "for (b in this) this[b] = null\n"
            "}\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.charts,\n"
        "A = a.each,\n"
        "H = a.extend,\n"
        "G = a.map,\n"
        "r = a.noop,\n"
        "f = a.pick;\n"
        "H(a.Pointer.prototype, {\n"
            "pinchTranslate: function(a, f, k, u, d, c) {\n"
                "this.zoomHor && this.pinchTranslateDirection(!0, a, f, k, u, d, c);\n"
                "this.zoomVert && this.pinchTranslateDirection(!1, a, f, k, u, d, c)\n"
            "},\n"
            "pinchTranslateDirection: function(a, f, k, u, d, c, n, r) {\n"
                "var b = this.chart,\n"
                "p = a ? \"x\": \"y\",\n"
                "h = a ? \"X\": \"Y\",\n"
                "t = \"chart\" + h,\n"
                "l = a ? \"width\": \"height\",\n"
                "w = b[\"plot\" + (a ? \"Left\": \"Top\")],\n"
                "e,\n"
                "q,\n"
                "C = r || 1,\n"
                "E = b.inverted,\n"
                "m = b.bounds[a ? \"h\": \"v\"],\n"
                "y = 1 === f.length,\n"
                "I = f[0][t],\n"
                "K = k[0][t],\n"
                "J = !y && f[1][t],\n"
                "g = !y && k[1][t],\n"
                "z;\n"
                "k = function() { ! y && 20 < Math.abs(I - J) && (C = r || Math.abs(K - g) / Math.abs(I - J));\n"
                    "q = (w - K) / C + I;\n"
                    "e = b[\"plot\" + (a ? \"Width\": \"Height\")] / C\n"
                "};\n"
                "k();\n"
                "f = q;\n"
                "f < m.min ? (f = m.min, z = !0) : f + e > m.max && (f = m.max - e, z = !0);\n"
                "z ? (K -= .8 * (K - n[p][0]), y || (g -= .8 * (g - n[p][1])), k()) : n[p] = [K, g];\n"
                "E || (c[p] = q - w, c[l] = e);\n"
                "c = E ? 1 / C: C;\n"
                "d[l] = e;\n"
                "d[p] = f;\n"
                "u[E ? a ? \"scaleY\": \"scaleX\": \"scale\" + h] = C;\n"
                "u[\"translate\" + h] = c * w + (K - c * I)\n"
            "},\n"
            "pinch: function(a) {\n"
                "var l = this,\n"
                "k = l.chart,\n"
                "u = l.pinchDown,\n"
                "d = a.touches,\n"
                "c = d.length,\n"
                "n = l.lastValidTouch,\n"
                "z = l.hasZoom,\n"
                "b = l.selectionMarker,\n"
                "p = {},\n"
                "h = 1 === c && (l.inClass(a.target, \"highcharts-tracker\") && k.runTrackerClick || l.runChartClick),\n"
                "t = {};\n"
                "1 < c && (l.initiated = !0);\n"
                "z && l.initiated && !h && a.preventDefault();\n"
                "G(d,\n"
                "function(a) {\n"
                    "return l.normalize(a)\n"
                "});\n"
                "\"touchstart\" === a.type ? (A(d,\n"
                "function(a, b) {\n"
                    "u[b] = {\n"
                        "chartX: a.chartX,\n"
                        "chartY: a.chartY\n"
                    "}\n"
                "}), n.x = [u[0].chartX, u[1] && u[1].chartX], n.y = [u[0].chartY, u[1] && u[1].chartY], A(k.axes,\n"
                "function(a) {\n"
                    "if (a.zoomEnabled) {\n"
                        "var b = k.bounds[a.horiz ? \"h\": \"v\"],\n"
                        "c = a.minPixelPadding,\n"
                        "h = a.toPixels(f(a.options.min, a.dataMin)),\n"
                        "d = a.toPixels(f(a.options.max, a.dataMax)),\n"
                        "p = Math.max(h, d);\n"
                        "b.min = Math.min(a.pos, Math.min(h, d) - c);\n"
                        "b.max = Math.max(a.pos + a.len, p + c)\n"
                    "}\n"
                "}), l.res = !0) : l.followTouchMove && 1 === c ? this.runPointActions(l.normalize(a)) : u.length && (b || (l.selectionMarker = b = H({\n"
                    "destroy: r,\n"
                    "touch: !0\n"
                "},\n"
                "k.plotBox)), l.pinchTranslate(u, d, p, b, t, n), l.hasPinched = z, l.scaleGroups(p, t), l.res && (l.res = !1, this.reset(!1, 0)))\n"
            "},\n"
            "touch: function(l, q) {\n"
                "var k = this.chart,\n"
                "u, d;\n"
                "if (k.index !== a.hoverChartIndex) this.onContainerMouseLeave({\n"
                    "relatedTarget: !0\n"
                "});\n"
                "a.hoverChartIndex = k.index;\n"
                "1 === l.touches.length ? (l = this.normalize(l), (d = k.isInsidePlot(l.chartX - k.plotLeft, l.chartY - k.plotTop)) && !k.openMenu ? (q && this.runPointActions(l), \"touchmove\" === l.type && (q = this.pinchDown, u = q[0] ? 4 <= Math.sqrt(Math.pow(q[0].chartX - l.chartX, 2) + Math.pow(q[0].chartY - l.chartY, 2)) : !1), f(u, !0) && this.pinch(l)) : q && this.reset()) : 2 === l.touches.length && this.pinch(l)\n"
            "},\n"
            "onContainerTouchStart: function(a) {\n"
                "this.zoomOption(a);\n"
                "this.touch(a, !0)\n"
            "},\n"
            "onContainerTouchMove: function(a) {\n"
                "this.touch(a)\n"
            "},\n"
            "onDocumentTouchEnd: function(f) {\n"
                "B[a.hoverChartIndex] && B[a.hoverChartIndex].pointer.drop(f)\n"
            "}\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.charts,\n"
        "H = a.css,\n"
        "G = a.doc,\n"
        "r = a.extend,\n"
        "f = a.noop,\n"
        "l = a.Pointer,\n"
        "q = a.removeEvent,\n"
        "k = a.win,\n"
        "u = a.wrap;\n"
        "if (k.PointerEvent || k.MSPointerEvent) {\n"
            "var d = {},\n"
            "c = !!k.PointerEvent,\n"
            "n = function() {\n"
                "var a, c = [];\n"
                "c.item = function(a) {\n"
                    "return this[a]\n"
                "};\n"
                "for (a in d) d.hasOwnProperty(a) && c.push({\n"
                    "pageX: d[a].pageX,\n"
                    "pageY: d[a].pageY,\n"
                    "target: d[a].target\n"
                "});\n"
                "return c\n"
            "},\n"
            "z = function(b, c, h, d) {\n"
                "\"touch\" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !A[a.hoverChartIndex] || (d(b), d = A[a.hoverChartIndex].pointer, d[c]({\n"
                    "type: h,\n"
                    "target: b.currentTarget,\n"
                    "preventDefault: f,\n"
                    "touches: n()\n"
                "}))\n"
            "};\n"
            "r(l.prototype, {\n"
                "onContainerPointerDown: function(a) {\n"
                    "z(a, \"onContainerTouchStart\", \"touchstart\",\n"
                    "function(a) {\n"
                        "d[a.pointerId] = {\n"
                            "pageX: a.pageX,\n"
                            "pageY: a.pageY,\n"
                            "target: a.currentTarget\n"
                        "}\n"
                    "})\n"
                "},\n"
                "onContainerPointerMove: function(a) {\n"
                    "z(a, \"onContainerTouchMove\", \"touchmove\",\n"
                    "function(a) {\n"
                        "d[a.pointerId] = {\n"
                            "pageX: a.pageX,\n"
                            "pageY: a.pageY\n"
                        "};\n"
                        "d[a.pointerId].target || (d[a.pointerId].target = a.currentTarget)\n"
                    "})\n"
                "},\n"
                "onDocumentPointerUp: function(a) {\n"
                    "z(a, \"onDocumentTouchEnd\", \"touchend\",\n"
                    "function(a) {\n"
                        "delete d[a.pointerId]\n"
                    "})\n"
                "},\n"
                "batchMSEvents: function(a) {\n"
                    "a(this.chart.container, c ? \"pointerdown\": \"MSPointerDown\", this.onContainerPointerDown);\n"
                    "a(this.chart.container, c ? \"pointermove\": \"MSPointerMove\", this.onContainerPointerMove);\n"
                    "a(G, c ? \"pointerup\": \"MSPointerUp\", this.onDocumentPointerUp)\n"
                "}\n"
            "});\n"
            "u(l.prototype, \"init\",\n"
            "function(a, c, h) {\n"
                "a.call(this, c, h);\n"
                "this.hasZoom && H(c.container, {\n"
                    "\"-ms-touch-action\": \"none\",\n"
                    "\"touch-action\": \"none\"\n"
                "})\n"
            "});\n"
            "u(l.prototype, \"setDOMEvents\",\n"
            "function(a) {\n"
                "a.apply(this); (this.hasZoom || this.followTouchMove) && this.batchMSEvents(B)\n"
            "});\n"
            "u(l.prototype, \"destroy\",\n"
            "function(a) {\n"
                "this.batchMSEvents(q);\n"
                "a.call(this)\n"
            "})\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B, A = a.addEvent,\n"
        "H = a.css,\n"
        "G = a.discardElement,\n"
        "r = a.defined,\n"
        "f = a.each,\n"
        "l = a.isFirefox,\n"
        "q = a.marginNames,\n"
        "k = a.merge,\n"
        "u = a.pick,\n"
        "d = a.setAnimation,\n"
        "c = a.stableSort,\n"
        "n = a.win,\n"
        "z = a.wrap;\n"
        "B = a.Legend = function(a, c) {\n"
            "this.init(a, c)\n"
        "};\n"
        "B.prototype = {\n"
            "init: function(a, c) {\n"
                "this.chart = a;\n"
                "this.setOptions(c);\n"
                "c.enabled && (this.render(), A(this.chart, \"endResize\",\n"
                "function() {\n"
                    "this.legend.positionCheckboxes()\n"
                "}))\n"
            "},\n"
            "setOptions: function(a) {\n"
                "var b = u(a.padding, 8);\n"
                "this.options = a;\n"
                "this.itemStyle = a.itemStyle;\n"
                "this.itemHiddenStyle = k(this.itemStyle, a.itemHiddenStyle);\n"
                "this.itemMarginTop = a.itemMarginTop || 0;\n"
                "this.padding = b;\n"
                "this.initialItemY = b - 5;\n"
                "this.itemHeight = this.maxItemWidth = 0;\n"
                "this.symbolWidth = u(a.symbolWidth, 16);\n"
                "this.pages = []\n"
            "},\n"
            "update: function(a, c) {\n"
                "var b = this.chart;\n"
                "this.setOptions(k(!0, this.options, a));\n"
                "this.destroy();\n"
                "b.isDirtyLegend = b.isDirtyBox = !0;\n"
                "u(c, !0) && b.redraw()\n"
            "},\n"
            "colorizeItem: function(a, c) {\n"
                "a.legendGroup[c ? \"removeClass\": \"addClass\"](\"highcharts-legend-item-hidden\");\n"
                "var b = this.options,\n"
                "d = a.legendItem,\n"
                "f = a.legendLine,\n"
                "p = a.legendSymbol,\n"
                "e = this.itemHiddenStyle.color,\n"
                "b = c ? b.itemStyle.color: e,\n"
                "n = c ? a.color || e: e,\n"
                "k = a.options && a.options.marker,\n"
                "l = {\n"
                    "fill: n\n"
                "},\n"
                "m;\n"
                "d && d.css({\n"
                    "fill: b,\n"
                    "color: b\n"
                "});\n"
                "f && f.attr({\n"
                    "stroke: n\n"
                "});\n"
                "if (p) {\n"
                    "if (k && p.isMarker && (l = a.pointAttribs(), !c)) for (m in l) l[m] = e;\n"
                    "p.attr(l)\n"
                "}\n"
            "},\n"
            "positionItem: function(a) {\n"
                "var b = this.options,\n"
                "c = b.symbolPadding,\n"
                "b = !b.rtl,\n"
                "d = a._legendItemPos,\n"
                "f = d[0],\n"
                "d = d[1],\n"
                "n = a.checkbox; (a = a.legendGroup) && a.element && a.translate(b ? f: this.legendWidth - f - 2 * c - 4, d);\n"
                "n && (n.x = f, n.y = d)\n"
            "},\n"
            "destroyItem: function(a) {\n"
                "var b = a.checkbox;\n"
                "f([\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"],\n"
                "function(b) {\n"
                    "a[b] && (a[b] = a[b].destroy())\n"
                "});\n"
                "b && G(a.checkbox)\n"
            "},\n"
            "destroy: function() {\n"
                "function a(a) {\n"
                    "this[a] && (this[a] = this[a].destroy())\n"
                "}\n"
                "f(this.getAllItems(),\n"
                "function(b) {\n"
                    "f([\"legendItem\", \"legendGroup\"], a, b)\n"
                "});\n"
                "f(\"clipRect up down pager nav box title group\".split(\" \"), a, this);\n"
                "this.display = null\n"
            "},\n"
            "positionCheckboxes: function(a) {\n"
                "var b = this.group && this.group.alignAttr,\n"
                "c, d = this.clipHeight || this.legendHeight,\n"
                "n = this.titleHeight;\n"
                "b && (c = b.translateY, f(this.allItems,\n"
                "function(h) {\n"
                    "var e = h.checkbox,\n"
                    "f;\n"
                    "e && (f = c + n + e.y + (a || 0) + 3, H(e, {\n"
                        "left: b.translateX + h.checkboxOffset + e.x - 20 + \"px\",\n"
                        "top: f + \"px\",\n"
                        "display: f > c - 6 && f < c + d - 6 ? \"\": \"none\"\n"
                    "}))\n"
                "}))\n"
            "},\n"
            "renderTitle: function() {\n"
                "var a = this.padding,\n"
                "c = this.options.title,\n"
                "h = 0;\n"
                "c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, null, null, null, null, null, \"legend-title\").attr({\n"
                    "zIndex: 1\n"
                "}).css(c.style).add(this.group)), a = this.title.getBBox(), h = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n"
                    "translateY: h\n"
                "}));\n"
                "this.titleHeight = h\n"
            "},\n"
            "setText: function(b) {\n"
                "var c = this.options;\n"
                "b.legendItem.attr({\n"
                    "text: c.labelFormat ? a.format(c.labelFormat, b) : c.labelFormatter.call(b)\n"
                "})\n"
            "},\n"
            "renderItem: function(a) {\n"
                "var b = this.chart,\n"
                "c = b.renderer,\n"
                "d = this.options,\n"
                "f = \"horizontal\" === d.layout,\n"
                "n = this.symbolWidth,\n"
                "e = d.symbolPadding,\n"
                "l = this.itemStyle,\n"
                "q = this.itemHiddenStyle,\n"
                "r = this.padding,\n"
                "m = f ? u(d.itemDistance, 20) : 0,\n"
                "y = !d.rtl,\n"
                "I = d.width,\n"
                "K = d.itemMarginBottom || 0,\n"
                "J = this.itemMarginTop,\n"
                "g = a.legendItem,\n"
                "z = !a.series,\n"
                "Q = !z && a.series.drawLegendSymbol ? a.series: a,\n"
                "A = Q.options,\n"
                "A = this.createCheckboxForItem && A && A.showCheckbox,\n"
                "B = d.useHTML,\n"
                "H = a.options.className;\n"
                "g || (a.legendGroup = c.g(\"legend-item\").addClass(\"highcharts-\" + Q.type + \"-series highcharts-color-\" + a.colorIndex + (H ? \" \" + H: \"\") + (z ? \" highcharts-series-\" + a.index: \"\")).attr({\n"
                    "zIndex: 1\n"
                "}).add(this.scrollGroup), a.legendItem = g = c.text(\"\", y ? n + e: -e, this.baseline || 0, B).css(k(a.visible ? l: q)).attr({\n"
                    "align: y ? \"left\": \"right\",\n"
                    "zIndex: 2\n"
                "}).add(a.legendGroup), this.baseline || (l = l.fontSize, this.fontMetrics = c.fontMetrics(l, g), this.baseline = this.fontMetrics.f + 3 + J, g.attr(\"y\", this.baseline)), this.symbolHeight = d.symbolHeight || this.fontMetrics.f, Q.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, g, B), A && this.createCheckboxForItem(a));\n"
                "this.colorizeItem(a, a.visible);\n"
                "this.setText(a);\n"
                "c = g.getBBox();\n"
                "n = a.checkboxOffset = d.itemWidth || a.legendItemWidth || n + e + c.width + m + (A ? 20 : 0);\n"
                "this.itemHeight = e = Math.round(a.legendItemHeight || c.height || this.symbolHeight);\n"
                "f && this.itemX - r + n > (I || b.spacingBox.width - 2 * r - d.x) && (this.itemX = r, this.itemY += J + this.lastLineHeight + K, this.lastLineHeight = 0);\n"
                "this.maxItemWidth = Math.max(this.maxItemWidth, n);\n"
                "this.lastItemY = J + this.itemY + K;\n"
                "this.lastLineHeight = Math.max(e, this.lastLineHeight);\n"
                "a._legendItemPos = [this.itemX, this.itemY];\n"
                "f ? this.itemX += n: (this.itemY += J + e + K, this.lastLineHeight = e);\n"
                "this.offsetWidth = I || Math.max((f ? this.itemX - r - m: n) + r, this.offsetWidth)\n"
            "},\n"
            "getAllItems: function() {\n"
                "var a = [];\n"
                "f(this.chart.series,\n"
                "function(b) {\n"
                    "var c = b && b.options;\n"
                    "b && u(c.showInLegend, r(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === c.legendType ? b.data: b)))\n"
                "});\n"
                "return a\n"
            "},\n"
            "adjustMargins: function(a, c) {\n"
                "var b = this.chart,\n"
                "d = this.options,\n"
                "p = d.align.charAt(0) + d.verticalAlign.charAt(0) + d.layout.charAt(0);\n"
                "d.floating || f([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/],\n"
                "function(h, e) {\n"
                    "h.test(p) && !r(a[e]) && (b[q[e]] = Math.max(b[q[e]], b.legend[(e + 1) % 2 ? \"legendHeight\": \"legendWidth\"] + [1, -1, -1, 1][e] * d[e % 2 ? \"x\": \"y\"] + u(d.margin, 12) + c[e]))\n"
                "})\n"
            "},\n"
            "render: function() {\n"
                "var a = this,\n"
                "d = a.chart,\n"
                "h = d.renderer,\n"
                "n = a.group,\n"
                "l, q, e, x, u = a.box,\n"
                "r = a.options,\n"
                "m = a.padding;\n"
                "a.itemX = m;\n"
                "a.itemY = a.initialItemY;\n"
                "a.offsetWidth = 0;\n"
                "a.lastItemY = 0;\n"
                "n || (a.group = n = h.g(\"legend\").attr({\n"
                    "zIndex: 7\n"
                "}).add(), a.contentGroup = h.g().attr({\n"
                    "zIndex: 1\n"
                "}).add(n), a.scrollGroup = h.g().add(a.contentGroup));\n"
                "a.renderTitle();\n"
                "l = a.getAllItems();\n"
                "c(l,\n"
                "function(a, b) {\n"
                    "return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0)\n"
                "});\n"
                "r.reversed && l.reverse();\n"
                "a.allItems = l;\n"
                "a.display = q = !!l.length;\n"
                "a.lastLineHeight = 0;\n"
                "f(l,\n"
                "function(b) {\n"
                    "a.renderItem(b)\n"
                "});\n"
                "e = (r.width || a.offsetWidth) + m;\n"
                "x = a.lastItemY + a.lastLineHeight + a.titleHeight;\n"
                "x = a.handleOverflow(x);\n"
                "x += m;\n"
                "u || (a.box = u = h.rect().addClass(\"highcharts-legend-box\").attr({\n"
                    "r: r.borderRadius\n"
                "}).add(n), u.isNew = !0);\n"
                "u.attr({\n"
                    "stroke: r.borderColor,\n"
                    "\"stroke-width\": r.borderWidth || 0,\n"
                    "fill: r.backgroundColor || \"none\"\n"
                "}).shadow(r.shadow);\n"
                "0 < e && 0 < x && (u[u.isNew ? \"attr\": \"animate\"](u.crisp({\n"
                    "x: 0,\n"
                    "y: 0,\n"
                    "width: e,\n"
                    "height: x\n"
                "},\n"
                "u.strokeWidth())), u.isNew = !1);\n"
                "u[q ? \"show\": \"hide\"]();\n"
                "a.legendWidth = e;\n"
                "a.legendHeight = x;\n"
                "f(l,\n"
                "function(b) {\n"
                    "a.positionItem(b)\n"
                "});\n"
                "q && n.align(k(r, {\n"
                    "width: e,\n"
                    "height: x\n"
                "}), !0, \"spacingBox\");\n"
                "d.isResizing || this.positionCheckboxes()\n"
            "},\n"
            "handleOverflow: function(a) {\n"
                "var b = this,\n"
                "c = this.chart,\n"
                "d = c.renderer,\n"
                "n = this.options,\n"
                "k = n.y,\n"
                "e = this.padding,\n"
                "c = c.spacingBox.height + (\"top\" === n.verticalAlign ? -k: k) - e,\n"
                "k = n.maxHeight,\n"
                "l,\n"
                "q = this.clipRect,\n"
                "r = n.navigation,\n"
                "m = u(r.animation, !0),\n"
                "y = r.arrowSize || 12,\n"
                "I = this.nav,\n"
                "K = this.pages,\n"
                "J,\n"
                "g = this.allItems,\n"
                "z = function(a) {\n"
                    "a ? q.attr({\n"
                        "height: a\n"
                    "}) : q && (b.clipRect = q.destroy(), b.contentGroup.clip());\n"
                    "b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + e + \"px,9999px,\" + (e + a) + \"px,0)\": \"auto\")\n"
                "};\n"
                "\"horizontal\" !== n.layout || \"middle\" === n.verticalAlign || n.floating || (c /= 2);\n"
                "k && (c = Math.min(c, k));\n"
                "K.length = 0;\n"
                "a > c && !1 !== r.enabled ? (this.clipHeight = l = Math.max(c - 20 - this.titleHeight - e, 0), this.currentPage = u(this.currentPage, 1), this.fullHeight = a, f(g,\n"
                "function(a, b) {\n"
                    "var c = a._legendItemPos[1];\n"
                    "a = Math.round(a.legendItem.getBBox().height);\n"
                    "var e = K.length;\n"
                    "if (!e || c - K[e - 1] > l && (J || c) !== K[e - 1]) K.push(J || c),\n"
                    "e++;\n"
                    "b === g.length - 1 && c + a - K[e - 1] > l && K.push(c);\n"
                    "c !== J && (J = c)\n"
                "}), q || (q = b.clipRect = d.clipRect(0, e, 9999, 0), b.contentGroup.clip(q)), z(l), I || (this.nav = I = d.g().attr({\n"
                    "zIndex: 1\n"
                "}).add(this.group), this.up = d.symbol(\"triangle\", 0, 0, y, y).on(\"click\",\n"
                "function() {\n"
                    "b.scroll( - 1, m)\n"
                "}).add(I), this.pager = d.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\").css(r.style).add(I), this.down = d.symbol(\"triangle-down\", 0, 0, y, y).on(\"click\",\n"
                "function() {\n"
                    "b.scroll(1, m)\n"
                "}).add(I)), b.scroll(0), a = c) : I && (z(), this.nav = I.destroy(), this.scrollGroup.attr({\n"
                    "translateY: 1\n"
                "}), this.clipHeight = 0);\n"
                "return a\n"
            "},\n"
            "scroll: function(a, c) {\n"
                "var b = this.pages,\n"
                "f = b.length;\n"
                "a = this.currentPage + a;\n"
                "var p = this.clipHeight,\n"
                "n = this.options.navigation,\n"
                "e = this.pager,\n"
                "k = this.padding;\n"
                "a > f && (a = f);\n"
                "0 < a && (void 0 !== c && d(c, this.chart), this.nav.attr({\n"
                    "translateX: k,\n"
                    "translateY: p + this.padding + 7 + this.titleHeight,\n"
                    "visibility: \"visible\"\n"
                "}), this.up.attr({\n"
                    "\"class\": 1 === a ? \"highcharts-legend-nav-inactive\": \"highcharts-legend-nav-active\"\n"
                "}), e.attr({\n"
                    "text: a + \"/\" + f\n"
                "}), this.down.attr({\n"
                    "x: 18 + this.pager.getBBox().width,\n"
                    "\"class\": a === f ? \"highcharts-legend-nav-inactive\": \"highcharts-legend-nav-active\"\n"
                "}), this.up.attr({\n"
                    "fill: 1 === a ? n.inactiveColor: n.activeColor\n"
                "}).css({\n"
                    "cursor: 1 === a ? \"default\": \"pointer\"\n"
                "}), this.down.attr({\n"
                    "fill: a === f ? n.inactiveColor: n.activeColor\n"
                "}).css({\n"
                    "cursor: a === f ? \"default\": \"pointer\"\n"
                "}), c = -b[a - 1] + this.initialItemY, this.scrollGroup.animate({\n"
                    "translateY: c\n"
                "}), this.currentPage = a, this.positionCheckboxes(c))\n"
            "}\n"
        "};\n"
        "a.LegendSymbolMixin = {\n"
            "drawRectangle: function(a, c) {\n"
                "var b = a.symbolHeight,\n"
                "d = a.options.squareSymbol;\n"
                "c.legendSymbol = this.chart.renderer.rect(d ? (a.symbolWidth - b) / 2 : 0, a.baseline - b + 1, d ? b: a.symbolWidth, b, u(a.options.symbolRadius, b / 2)).addClass(\"highcharts-point\").attr({\n"
                    "zIndex: 3\n"
                "}).add(c.legendGroup)\n"
            "},\n"
            "drawLineMarker: function(a) {\n"
                "var b = this.options,\n"
                "c = b.marker,\n"
                "d = a.symbolWidth,\n"
                "f = a.symbolHeight,\n"
                "n = f / 2,\n"
                "e = this.chart.renderer,\n"
                "l = this.legendGroup;\n"
                "a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n"
                "var q;\n"
                "q = {\n"
                    "\"stroke-width\": b.lineWidth || 0\n"
                "};\n"
                "b.dashStyle && (q.dashstyle = b.dashStyle);\n"
                "this.legendLine = e.path([\"M\", 0, a, \"L\", d, a]).addClass(\"highcharts-graph\").attr(q).add(l);\n"
                "c && !1 !== c.enabled && (b = Math.min(u(c.radius, n), n), 0 === this.symbol.indexOf(\"url\") && (c = k(c, {\n"
                    "width: f,\n"
                    "height: f\n"
                "}), b = 0), this.legendSymbol = c = e.symbol(this.symbol, d / 2 - b, a - b, 2 * b, 2 * b, c).addClass(\"highcharts-point\").add(l), c.isMarker = !0)\n"
            "}\n"
        "}; (/Trident\\/7\\.0/.test(n.navigator.userAgent) || l) && z(B.prototype, \"positionItem\",\n"
        "function(a, c) {\n"
            "var b = this,\n"
            "d = function() {\n"
                "c._legendItemPos && a.call(b, c)\n"
            "};\n"
            "d();\n"
            "setTimeout(d)\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.animate,\n"
        "H = a.animObject,\n"
        "G = a.attr,\n"
        "r = a.doc,\n"
        "f = a.Axis,\n"
        "l = a.createElement,\n"
        "q = a.defaultOptions,\n"
        "k = a.discardElement,\n"
        "u = a.charts,\n"
        "d = a.css,\n"
        "c = a.defined,\n"
        "n = a.each,\n"
        "z = a.extend,\n"
        "b = a.find,\n"
        "p = a.fireEvent,\n"
        "h = a.getStyle,\n"
        "t = a.grep,\n"
        "D = a.isNumber,\n"
        "w = a.isObject,\n"
        "e = a.isString,\n"
        "x = a.Legend,\n"
        "C = a.marginNames,\n"
        "E = a.merge,\n"
        "m = a.Pointer,\n"
        "y = a.pick,\n"
        "I = a.pInt,\n"
        "K = a.removeEvent,\n"
        "J = a.seriesTypes,\n"
        "g = a.splat,\n"
        "F = a.svg,\n"
        "Q = a.syncTimeout,\n"
        "N = a.win,\n"
        "P = a.Renderer,\n"
        "O = a.Chart = function() {\n"
            "this.getArgs.apply(this, arguments)\n"
        "};\n"
        "a.chart = function(a, b, c) {\n"
            "return new O(a, b, c)\n"
        "};\n"
        "O.prototype = {\n"
            "callbacks: [],\n"
            "getArgs: function() {\n"
                "var a = [].slice.call(arguments);\n"
                "if (e(a[0]) || a[0].nodeName) this.renderTo = a.shift();\n"
                "this.init(a[0], a[1])\n"
            "},\n"
            "init: function(b, c) {\n"
                "var e, g = b.series;\n"
                "b.series = null;\n"
                "e = E(q, b);\n"
                "e.series = b.series = g;\n"
                "this.userOptions = b;\n"
                "b = e.chart;\n"
                "g = b.events;\n"
                "this.margin = [];\n"
                "this.spacing = [];\n"
                "this.bounds = {\n"
                    "h: {},\n"
                    "v: {}\n"
                "};\n"
                "this.callback = c;\n"
                "this.isResizing = 0;\n"
                "this.options = e;\n"
                "this.axes = [];\n"
                "this.series = [];\n"
                "this.hasCartesianSeries = b.showAxes;\n"
                "var d;\n"
                "this.index = u.length;\n"
                "u.push(this);\n"
                "a.chartCount++;\n"
                "if (g) for (d in g) B(this, d, g[d]);\n"
                "this.xAxis = [];\n"
                "this.yAxis = [];\n"
                "this.pointCount = this.colorCounter = this.symbolCounter = 0;\n"
                "this.firstRender()\n"
            "},\n"
            "initSeries: function(b) {\n"
                "var c = this.options.chart; (c = J[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0);\n"
                "c = new c;\n"
                "c.init(this, b);\n"
                "return c\n"
            "},\n"
            "orderSeries: function(a) {\n"
                "var b = this.series;\n"
                "for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].name || \"Series \" + (b[a].index + 1))\n"
            "},\n"
            "isInsidePlot: function(a, b, c) {\n"
                "var e = c ? b: a;\n"
                "a = c ? a: b;\n"
                "return 0 <= e && e <= this.plotWidth && 0 <= a && a <= this.plotHeight\n"
            "},\n"
            "redraw: function(b) {\n"
                "var c = this.axes,\n"
                "e = this.series,\n"
                "g = this.pointer,\n"
                "d = this.legend,\n"
                "m = this.isDirtyLegend,\n"
                "h, f, v = this.hasCartesianSeries,\n"
                "k = this.isDirtyBox,\n"
                "y, l = this.renderer,\n"
                "t = l.isHidden(),\n"
                "q = [];\n"
                "this.setResponsive && this.setResponsive(!1);\n"
                "a.setAnimation(b, this);\n"
                "t && this.cloneRenderTo();\n"
                "this.layOutTitles();\n"
                "for (b = e.length; b--;) if (y = e[b], y.options.stacking && (h = !0, y.isDirty)) {\n"
                    "f = !0;\n"
                    "break\n"
                "}\n"
                "if (f) for (b = e.length; b--;) y = e[b],\n"
                "y.options.stacking && (y.isDirty = !0);\n"
                "n(e,\n"
                "function(a) {\n"
                    "a.isDirty && \"point\" === a.options.legendType && (a.updateTotals && a.updateTotals(), m = !0);\n"
                    "a.isDirtyData && p(a, \"updatedData\")\n"
                "});\n"
                "m && d.options.enabled && (d.render(), this.isDirtyLegend = !1);\n"
                "h && this.getStacks();\n"
                "v && n(c,\n"
                "function(a) {\n"
                    "a.updateNames();\n"
                    "a.setScale()\n"
                "});\n"
                "this.getMargins();\n"
                "v && (n(c,\n"
                "function(a) {\n"
                    "a.isDirty && (k = !0)\n"
                "}), n(c,\n"
                "function(a) {\n"
                    "var b = a.min + \",\" + a.max;\n"
                    "a.extKey !== b && (a.extKey = b, q.push(function() {\n"
                        "p(a, \"afterSetExtremes\", z(a.eventArgs, a.getExtremes()));\n"
                        "delete a.eventArgs\n"
                    "})); (k || h) && a.redraw()\n"
                "}));\n"
                "k && this.drawChartBox();\n"
                "p(this, \"predraw\");\n"
                "n(e,\n"
                "function(a) { (k || a.isDirty) && a.visible && a.redraw();\n"
                    "a.isDirtyData = !1\n"
                "});\n"
                "g && g.reset(!0);\n"
                "l.draw();\n"
                "p(this, \"redraw\");\n"
                "p(this, \"render\");\n"
                "t && this.cloneRenderTo(!0);\n"
                "n(q,\n"
                "function(a) {\n"
                    "a.call()\n"
                "})\n"
            "},\n"
            "get: function(a) {\n"
                "function c(b) {\n"
                    "return b.id === a || b.options && b.options.id === a\n"
                "}\n"
                "var e, g = this.series,\n"
                "d;\n"
                "e = b(this.axes, c) || b(this.series, c);\n"
                "for (d = 0; ! e && d < g.length; d++) e = b(g[d].points || [], c);\n"
                "return e\n"
            "},\n"
            "getAxes: function() {\n"
                "var a = this,\n"
                "b = this.options,\n"
                "c = b.xAxis = g(b.xAxis || {}),\n"
                "b = b.yAxis = g(b.yAxis || {});\n"
                "n(c,\n"
                "function(a, b) {\n"
                    "a.index = b;\n"
                    "a.isX = !0\n"
                "});\n"
                "n(b,\n"
                "function(a, b) {\n"
                    "a.index = b\n"
                "});\n"
                "c = c.concat(b);\n"
                "n(c,\n"
                "function(b) {\n"
                    "new f(a, b)\n"
                "})\n"
            "},\n"
            "getSelectedPoints: function() {\n"
                "var a = [];\n"
                "n(this.series,\n"
                "function(b) {\n"
                    "a = a.concat(t(b.points || [],\n"
                    "function(a) {\n"
                        "return a.selected\n"
                    "}))\n"
                "});\n"
                "return a\n"
            "},\n"
            "getSelectedSeries: function() {\n"
                "return t(this.series,\n"
                "function(a) {\n"
                    "return a.selected\n"
                "})\n"
            "},\n"
            "setTitle: function(a, b, c) {\n"
                "var e = this,\n"
                "g = e.options,\n"
                "d;\n"
                "d = g.title = E({\n"
                    "style: {\n"
                        "color: \"#333333\",\n"
                        "fontSize: g.isStock ? \"16px\": \"18px\"\n"
                    "}\n"
                "},\n"
                "g.title, a);\n"
                "g = g.subtitle = E({\n"
                    "style: {\n"
                        "color: \"#666666\"\n"
                    "}\n"
                "},\n"
                "g.subtitle, b);\n"
                "n([[\"title\", a, d], [\"subtitle\", b, g]],\n"
                "function(a, b) {\n"
                    "var c = a[0],\n"
                    "g = e[c],\n"
                    "d = a[1];\n"
                    "a = a[2];\n"
                    "g && d && (e[c] = g = g.destroy());\n"
                    "a && a.text && !g && (e[c] = e.renderer.text(a.text, 0, 0, a.useHTML).attr({\n"
                        "align: a.align,\n"
                        "\"class\": \"highcharts-\" + c,\n"
                        "zIndex: a.zIndex || 4\n"
                    "}).add(), e[c].update = function(a) {\n"
                        "e.setTitle(!b && a, b && a)\n"
                    "},\n"
                    "e[c].css(a.style))\n"
                "});\n"
                "e.layOutTitles(c)\n"
            "},\n"
            "layOutTitles: function(a) {\n"
                "var b = 0,\n"
                "c, e = this.renderer,\n"
                "g = this.spacingBox;\n"
                "n([\"title\", \"subtitle\"],\n"
                "function(a) {\n"
                    "var c = this[a],\n"
                    "d = this.options[a],\n"
                    "m;\n"
                    "c && (m = d.style.fontSize, m = e.fontMetrics(m, c).b, c.css({\n"
                        "width: (d.width || g.width + d.widthAdjust) + \"px\"\n"
                    "}).align(z({\n"
                        "y: b + m + (\"title\" === a ? -3 : 2)\n"
                    "},\n"
                    "d), !1, \"spacingBox\"), d.floating || d.verticalAlign || (b = Math.ceil(b + c.getBBox(d.useHTML).height)))\n"
                "},\n"
                "this);\n"
                "c = this.titleOffset !== b;\n"
                "this.titleOffset = b; ! this.isDirtyBox && c && (this.isDirtyBox = c, this.hasRendered && y(a, !0) && this.isDirtyBox && this.redraw())\n"
            "},\n"
            "getChartSize: function() {\n"
                "var b = this.options.chart,\n"
                "e = b.width,\n"
                "b = b.height,\n"
                "g = this.renderToClone || this.renderTo;\n"
                "c(e) || (this.containerWidth = h(g, \"width\"));\n"
                "c(b) || (this.containerHeight = h(g, \"height\"));\n"
                "this.chartWidth = Math.max(0, e || this.containerWidth || 600);\n"
                "this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || this.containerHeight || 400)\n"
            "},\n"
            "cloneRenderTo: function(a) {\n"
                "var b = this.renderToClone,\n"
                "c = this.container;\n"
                "if (a) {\n"
                    "if (b) {\n"
                        "for (; b.childNodes.length;) this.renderTo.appendChild(b.firstChild);\n"
                        "k(b);\n"
                        "delete this.renderToClone\n"
                    "}\n"
                "} else c && c.parentNode === this.renderTo && this.renderTo.removeChild(c),\n"
                "this.renderToClone = b = this.renderTo.cloneNode(0),\n"
                "d(b, {\n"
                    "position: \"absolute\",\n"
                    "top: \"-9999px\",\n"
                    "display: \"block\"\n"
                "}),\n"
                "b.style.setProperty && b.style.setProperty(\"display\", \"block\", \"important\"),\n"
                "r.body.appendChild(b),\n"
                "c && b.appendChild(c)\n"
            "},\n"
            "setClassName: function(a) {\n"
                "this.container.className = \"highcharts-container \" + (a || \"\")\n"
            "},\n"
            "getContainer: function() {\n"
                "var b, c = this.options,\n"
                "g = c.chart,\n"
                "d, m;\n"
                "b = this.renderTo;\n"
                "var h = a.uniqueKey(),\n"
                "f;\n"
                "b || (this.renderTo = b = g.renderTo);\n"
                "e(b) && (this.renderTo = b = r.getElementById(b));\n"
                "b || a.error(13, !0);\n"
                "d = I(G(b, \"data-highcharts-chart\"));\n"
                "D(d) && u[d] && u[d].hasRendered && u[d].destroy();\n"
                "G(b, \"data-highcharts-chart\", this.index);\n"
                "b.innerHTML = \"\";\n"
                "g.skipClone || b.offsetWidth || this.cloneRenderTo();\n"
                "this.getChartSize();\n"
                "d = this.chartWidth;\n"
                "m = this.chartHeight;\n"
                "f = z({\n"
                    "position: \"relative\",\n"
                    "overflow: \"hidden\",\n"
                    "width: d + \"px\",\n"
                    "height: m + \"px\",\n"
                    "textAlign: \"left\",\n"
                    "lineHeight: \"normal\",\n"
                    "zIndex: 0,\n"
                    "\"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\"\n"
                "},\n"
                "g.style);\n"
                "this.container = b = l(\"div\", {\n"
                    "id: h\n"
                "},\n"
                "f, this.renderToClone || b);\n"
                "this._cursor = b.style.cursor;\n"
                "this.renderer = new(a[g.renderer] || P)(b, d, m, null, g.forExport, c.exporting && c.exporting.allowHTML);\n"
                "this.setClassName(g.className);\n"
                "this.renderer.setStyle(g.style);\n"
                "this.renderer.chartIndex = this.index\n"
            "},\n"
            "getMargins: function(a) {\n"
                "var b = this.spacing,\n"
                "e = this.margin,\n"
                "g = this.titleOffset;\n"
                "this.resetMargins();\n"
                "g && !c(e[0]) && (this.plotTop = Math.max(this.plotTop, g + this.options.title.margin + b[0]));\n"
                "this.legend.display && this.legend.adjustMargins(e, b);\n"
                "this.extraMargin && (this[this.extraMargin.type] = (this[this.extraMargin.type] || 0) + this.extraMargin.value);\n"
                "this.extraTopMargin && (this.plotTop += this.extraTopMargin);\n"
                "a || this.getAxisMargins()\n"
            "},\n"
            "getAxisMargins: function() {\n"
                "var a = this,\n"
                "b = a.axisOffset = [0, 0, 0, 0],\n"
                "e = a.margin;\n"
                "a.hasCartesianSeries && n(a.axes,\n"
                "function(a) {\n"
                    "a.visible && a.getOffset()\n"
                "});\n"
                "n(C,\n"
                "function(g, d) {\n"
                    "c(e[d]) || (a[g] += b[d])\n"
                "});\n"
                "a.setChartSize()\n"
            "},\n"
            "reflow: function(a) {\n"
                "var b = this,\n"
                "e = b.options.chart,\n"
                "g = b.renderTo,\n"
                "d = c(e.width),\n"
                "m = e.width || h(g, \"width\"),\n"
                "e = e.height || h(g, \"height\"),\n"
                "g = a ? a.target: N;\n"
                "if (!d && !b.isPrinting && m && e && (g === N || g === r)) {\n"
                    "if (m !== b.containerWidth || e !== b.containerHeight) clearTimeout(b.reflowTimeout),\n"
                    "b.reflowTimeout = Q(function() {\n"
                        "b.container && b.setSize(void 0, void 0, !1)\n"
                    "},\n"
                    "a ? 100 : 0);\n"
                    "b.containerWidth = m;\n"
                    "b.containerHeight = e\n"
                "}\n"
            "},\n"
            "initReflow: function() {\n"
                "var a = this,\n"
                "b;\n"
                "b = B(N, \"resize\",\n"
                "function(b) {\n"
                    "a.reflow(b)\n"
                "});\n"
                "B(a, \"destroy\", b)\n"
            "},\n"
            "setSize: function(b, c, e) {\n"
                "var g = this,\n"
                "m = g.renderer;\n"
                "g.isResizing += 1;\n"
                "a.setAnimation(e, g);\n"
                "g.oldChartHeight = g.chartHeight;\n"
                "g.oldChartWidth = g.chartWidth;\n"
                "void 0 !== b && (g.options.chart.width = b);\n"
                "void 0 !== c && (g.options.chart.height = c);\n"
                "g.getChartSize();\n"
                "b = m.globalAnimation; (b ? A: d)(g.container, {\n"
                    "width: g.chartWidth + \"px\",\n"
                    "height: g.chartHeight + \"px\"\n"
                "},\n"
                "b);\n"
                "g.setChartSize(!0);\n"
                "m.setSize(g.chartWidth, g.chartHeight, e);\n"
                "n(g.axes,\n"
                "function(a) {\n"
                    "a.isDirty = !0;\n"
                    "a.setScale()\n"
                "});\n"
                "g.isDirtyLegend = !0;\n"
                "g.isDirtyBox = !0;\n"
                "g.layOutTitles();\n"
                "g.getMargins();\n"
                "g.redraw(e);\n"
                "g.oldChartHeight = null;\n"
                "p(g, \"resize\");\n"
                "Q(function() {\n"
                    "g && p(g, \"endResize\", null,\n"
                    "function() {--g.isResizing\n"
                    "})\n"
                "},\n"
                "H(b).duration)\n"
            "},\n"
            "setChartSize: function(a) {\n"
                "var b = this.inverted,\n"
                "c = this.renderer,\n"
                "e = this.chartWidth,\n"
                "g = this.chartHeight,\n"
                "d = this.options.chart,\n"
                "m = this.spacing,\n"
                "h = this.clipOffset,\n"
                "f, p, k, y;\n"
                "this.plotLeft = f = Math.round(this.plotLeft);\n"
                "this.plotTop = p = Math.round(this.plotTop);\n"
                "this.plotWidth = k = Math.max(0, Math.round(e - f - this.marginRight));\n"
                "this.plotHeight = y = Math.max(0, Math.round(g - p - this.marginBottom));\n"
                "this.plotSizeX = b ? y: k;\n"
                "this.plotSizeY = b ? k: y;\n"
                "this.plotBorderWidth = d.plotBorderWidth || 0;\n"
                "this.spacingBox = c.spacingBox = {\n"
                    "x: m[3],\n"
                    "y: m[0],\n"
                    "width: e - m[3] - m[1],\n"
                    "height: g - m[0] - m[2]\n"
                "};\n"
                "this.plotBox = c.plotBox = {\n"
                    "x: f,\n"
                    "y: p,\n"
                    "width: k,\n"
                    "height: y\n"
                "};\n"
                "e = 2 * Math.floor(this.plotBorderWidth / 2);\n"
                "b = Math.ceil(Math.max(e, h[3]) / 2);\n"
                "c = Math.ceil(Math.max(e, h[0]) / 2);\n"
                "this.clipBox = {\n"
                    "x: b,\n"
                    "y: c,\n"
                    "width: Math.floor(this.plotSizeX - Math.max(e, h[1]) / 2 - b),\n"
                    "height: Math.max(0, Math.floor(this.plotSizeY - Math.max(e, h[2]) / 2 - c))\n"
                "};\n"
                "a || n(this.axes,\n"
                "function(a) {\n"
                    "a.setAxisSize();\n"
                    "a.setAxisTranslation()\n"
                "})\n"
            "},\n"
            "resetMargins: function() {\n"
                "var a = this,\n"
                "b = a.options.chart;\n"
                "n([\"margin\", \"spacing\"],\n"
                "function(c) {\n"
                    "var e = b[c],\n"
                    "g = w(e) ? e: [e, e, e, e];\n"
                    "n([\"Top\", \"Right\", \"Bottom\", \"Left\"],\n"
                    "function(e, d) {\n"
                        "a[c][d] = y(b[c + e], g[d])\n"
                    "})\n"
                "});\n"
                "n(C,\n"
                "function(b, c) {\n"
                    "a[b] = y(a.margin[c], a.spacing[c])\n"
                "});\n"
                "a.axisOffset = [0, 0, 0, 0];\n"
                "a.clipOffset = [0, 0, 0, 0]\n"
            "},\n"
            "drawChartBox: function() {\n"
                "var a = this.options.chart,\n"
                "b = this.renderer,\n"
                "c = this.chartWidth,\n"
                "e = this.chartHeight,\n"
                "g = this.chartBackground,\n"
                "d = this.plotBackground,\n"
                "m = this.plotBorder,\n"
                "h, f = this.plotBGImage,\n"
                "n = a.backgroundColor,\n"
                "p = a.plotBackgroundColor,\n"
                "k = a.plotBackgroundImage,\n"
                "y, l = this.plotLeft,\n"
                "t = this.plotTop,\n"
                "q = this.plotWidth,\n"
                "u = this.plotHeight,\n"
                "x = this.plotBox,\n"
                "r = this.clipRect,\n"
                "w = this.clipBox,\n"
                "I = \"animate\";\n"
                "g || (this.chartBackground = g = b.rect().addClass(\"highcharts-background\").add(), I = \"attr\");\n"
                "h = a.borderWidth || 0;\n"
                "y = h + (a.shadow ? 8 : 0);\n"
                "n = {\n"
                    "fill: n || \"none\"\n"
                "};\n"
                "if (h || g[\"stroke-width\"]) n.stroke = a.borderColor,\n"
                "n[\"stroke-width\"] = h;\n"
                "g.attr(n).shadow(a.shadow);\n"
                "g[I]({\n"
                    "x: y / 2,\n"
                    "y: y / 2,\n"
                    "width: c - y - h % 2,\n"
                    "height: e - y - h % 2,\n"
                    "r: a.borderRadius\n"
                "});\n"
                "I = \"animate\";\n"
                "d || (I = \"attr\", this.plotBackground = d = b.rect().addClass(\"highcharts-plot-background\").add());\n"
                "d[I](x);\n"
                "d.attr({\n"
                    "fill: p || \"none\"\n"
                "}).shadow(a.plotShadow);\n"
                "k && (f ? f.animate(x) : this.plotBGImage = b.image(k, l, t, q, u).add());\n"
                "r ? r.animate({\n"
                    "width: w.width,\n"
                    "height: w.height\n"
                "}) : this.clipRect = b.clipRect(w);\n"
                "I = \"animate\";\n"
                "m || (I = \"attr\", this.plotBorder = m = b.rect().addClass(\"highcharts-plot-border\").attr({\n"
                    "zIndex: 1\n"
                "}).add());\n"
                "m.attr({\n"
                    "stroke: a.plotBorderColor,\n"
                    "\"stroke-width\": a.plotBorderWidth || 0,\n"
                    "fill: \"none\"\n"
                "});\n"
                "m[I](m.crisp({\n"
                    "x: l,\n"
                    "y: t,\n"
                    "width: q,\n"
                    "height: u\n"
                "},\n"
                "-m.strokeWidth()));\n"
                "this.isDirtyBox = !1\n"
            "},\n"
            "propFromSeries: function() {\n"
                "var a = this,\n"
                "b = a.options.chart,\n"
                "c, e = a.options.series,\n"
                "g, d;\n"
                "n([\"inverted\", \"angular\", \"polar\"],\n"
                "function(m) {\n"
                    "c = J[b.type || b.defaultSeriesType];\n"
                    "d = b[m] || c && c.prototype[m];\n"
                    "for (g = e && e.length; ! d && g--;)(c = J[e[g].type]) && c.prototype[m] && (d = !0);\n"
                    "a[m] = d\n"
                "})\n"
            "},\n"
            "linkSeries: function() {\n"
                "var a = this,\n"
                "b = a.series;\n"
                "n(b,\n"
                "function(a) {\n"
                    "a.linkedSeries.length = 0\n"
                "});\n"
                "n(b,\n"
                "function(b) {\n"
                    "var c = b.options.linkedTo;\n"
                    "e(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, b.visible = y(b.options.visible, c.options.visible, b.visible))\n"
                "})\n"
            "},\n"
            "renderSeries: function() {\n"
                "n(this.series,\n"
                "function(a) {\n"
                    "a.translate();\n"
                    "a.render()\n"
                "})\n"
            "},\n"
            "renderLabels: function() {\n"
                "var a = this,\n"
                "b = a.options.labels;\n"
                "b.items && n(b.items,\n"
                "function(c) {\n"
                    "var e = z(b.style, c.style),\n"
                    "g = I(e.left) + a.plotLeft,\n"
                    "d = I(e.top) + a.plotTop + 12;\n"
                    "delete e.left;\n"
                    "delete e.top;\n"
                    "a.renderer.text(c.html, g, d).attr({\n"
                        "zIndex: 2\n"
                    "}).css(e).add()\n"
                "})\n"
            "},\n"
            "render: function() {\n"
                "var a = this.axes,\n"
                "b = this.renderer,\n"
                "c = this.options,\n"
                "e, g, d;\n"
                "this.setTitle();\n"
                "this.legend = new x(this, c.legend);\n"
                "this.getStacks && this.getStacks();\n"
                "this.getMargins(!0);\n"
                "this.setChartSize();\n"
                "c = this.plotWidth;\n"
                "e = this.plotHeight -= 21;\n"
                "n(a,\n"
                "function(a) {\n"
                    "a.setScale()\n"
                "});\n"
                "this.getAxisMargins();\n"
                "g = 1.1 < c / this.plotWidth;\n"
                "d = 1.05 < e / this.plotHeight;\n"
                "if (g || d) n(a,\n"
                "function(a) { (a.horiz && g || !a.horiz && d) && a.setTickInterval(!0)\n"
                "}),\n"
                "this.getMargins();\n"
                "this.drawChartBox();\n"
                "this.hasCartesianSeries && n(a,\n"
                "function(a) {\n"
                    "a.visible && a.render()\n"
                "});\n"
                "this.seriesGroup || (this.seriesGroup = b.g(\"series-group\").attr({\n"
                    "zIndex: 3\n"
                "}).add());\n"
                "this.renderSeries();\n"
                "this.renderLabels();\n"
                "this.addCredits();\n"
                "this.setResponsive && this.setResponsive();\n"
                "this.hasRendered = !0\n"
            "},\n"
            "addCredits: function(a) {\n"
                "var b = this;\n"
                "a = E(!0, this.options.credits, a);\n"
                "a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\",\n"
                "function() {\n"
                    "a.href && (N.location.href = a.href)\n"
                "}).attr({\n"
                    "align: a.position.align,\n"
                    "zIndex: 8\n"
                "}).css(a.style).add().align(a.position), this.credits.update = function(a) {\n"
                    "b.credits = b.credits.destroy();\n"
                    "b.addCredits(a)\n"
                "})\n"
            "},\n"
            "destroy: function() {\n"
                "var b = this,\n"
                "c = b.axes,\n"
                "e = b.series,\n"
                "g = b.container,\n"
                "d, m = g && g.parentNode;\n"
                "p(b, \"destroy\");\n"
                "u[b.index] = void 0;\n"
                "a.chartCount--;\n"
                "b.renderTo.removeAttribute(\"data-highcharts-chart\");\n"
                "K(b);\n"
                "for (d = c.length; d--;) c[d] = c[d].destroy();\n"
                "this.scroller && this.scroller.destroy && this.scroller.destroy();\n"
                "for (d = e.length; d--;) e[d] = e[d].destroy();\n"
                "n(\"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \"),\n"
                "function(a) {\n"
                    "var c = b[a];\n"
                    "c && c.destroy && (b[a] = c.destroy())\n"
                "});\n"
                "g && (g.innerHTML = \"\", K(g), m && k(g));\n"
                "for (d in b) delete b[d]\n"
            "},\n"
            "isReadyToRender: function() {\n"
                "var a = this;\n"
                "return F || N != N.top || \"complete\" === r.readyState ? !0 : (r.attachEvent(\"onreadystatechange\",\n"
                "function() {\n"
                    "r.detachEvent(\"onreadystatechange\", a.firstRender);\n"
                    "\"complete\" === r.readyState && a.firstRender()\n"
                "}), !1)\n"
            "},\n"
            "firstRender: function() {\n"
                "var a = this,\n"
                "b = a.options;\n"
                "if (a.isReadyToRender()) {\n"
                    "a.getContainer();\n"
                    "p(a, \"init\");\n"
                    "a.resetMargins();\n"
                    "a.setChartSize();\n"
                    "a.propFromSeries();\n"
                    "a.getAxes();\n"
                    "n(b.series || [],\n"
                    "function(b) {\n"
                        "a.initSeries(b)\n"
                    "});\n"
                    "a.linkSeries();\n"
                    "p(a, \"beforeRender\");\n"
                    "m && (a.pointer = new m(a, b));\n"
                    "a.render();\n"
                    "if (!a.renderer.imgCount && a.onload) a.onload();\n"
                    "a.cloneRenderTo(!0)\n"
                "}\n"
            "},\n"
            "onload: function() {\n"
                "n([this.callback].concat(this.callbacks),\n"
                "function(a) {\n"
                    "a && void 0 !== this.index && a.apply(this, [this])\n"
                "},\n"
                "this);\n"
                "p(this, \"load\");\n"
                "p(this, \"render\");\n"
                "c(this.index) && !1 !== this.options.chart.reflow && this.initReflow();\n"
                "this.onload = null\n"
            "}\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B, A = a.each,\n"
        "H = a.extend,\n"
        "G = a.erase,\n"
        "r = a.fireEvent,\n"
        "f = a.format,\n"
        "l = a.isArray,\n"
        "q = a.isNumber,\n"
        "k = a.pick,\n"
        "u = a.removeEvent;\n"
        "B = a.Point = function() {};\n"
        "B.prototype = {\n"
            "init: function(a, c, f) {\n"
                "this.series = a;\n"
                "this.color = a.color;\n"
                "this.applyOptions(c, f);\n"
                "a.options.colorByPoint ? (c = a.options.colors || a.chart.options.colors, this.color = this.color || c[a.colorCounter], c = c.length, f = a.colorCounter, a.colorCounter++, a.colorCounter === c && (a.colorCounter = 0)) : f = a.colorIndex;\n"
                "this.colorIndex = k(this.colorIndex, f);\n"
                "a.chart.pointCount++;\n"
                "return this\n"
            "},\n"
            "applyOptions: function(a, c) {\n"
                "var d = this.series,\n"
                "f = d.options.pointValKey || d.pointValKey;\n"
                "a = B.prototype.optionsToObject.call(this, a);\n"
                "H(this, a);\n"
                "this.options = this.options ? H(this.options, a) : a;\n"
                "a.group && delete this.group;\n"
                "f && (this.y = this[f]);\n"
                "this.isNull = k(this.isValid && !this.isValid(), null === this.x || !q(this.y, !0));\n"
                "this.selected && (this.state = \"select\");\n"
                "\"name\" in this && void 0 === c && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));\n"
                "void 0 === this.x && d && (this.x = void 0 === c ? d.autoIncrement(this) : c);\n"
                "return this\n"
            "},\n"
            "optionsToObject: function(a) {\n"
                "var c = {},\n"
                "d = this.series,\n"
                "f = d.options.keys,\n"
                "b = f || d.pointArrayMap || [\"y\"],\n"
                "p = b.length,\n"
                "h = 0,\n"
                "k = 0;\n"
                "if (q(a) || null === a) c[b[0]] = a;\n"
                "else if (l(a)) for (!f && a.length > p && (d = typeof a[0], \"string\" === d ? c.name = a[0] : \"number\" === d && (c.x = a[0]), h++); k < p;) f && void 0 === a[h] || (c[b[k]] = a[h]),\n"
                "h++,\n"
                "k++;\n"
                "else \"object\" === typeof a && (c = a, a.dataLabels && (d._hasPointLabels = !0), a.marker && (d._hasPointMarkers = !0));\n"
                "return c\n"
            "},\n"
            "getClassName: function() {\n"
                "return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\": \"\") + (this.negative ? \" highcharts-negative\": \"\") + (this.isNull ? \" highcharts-null-point\": \"\") + (void 0 !== this.colorIndex ? \" highcharts-color-\" + this.colorIndex: \"\") + (this.options.className ? \" \" + this.options.className: \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\")\n"
            "},\n"
            "getZone: function() {\n"
                "var a = this.series,\n"
                "c = a.zones,\n"
                "a = a.zoneAxis || \"y\",\n"
                "f = 0,\n"
                "k;\n"
                "for (k = c[f]; this[a] >= k.value;) k = c[++f];\n"
                "k && k.color && !this.options.color && (this.color = k.color);\n"
                "return k\n"
            "},\n"
            "destroy: function() {\n"
                "var a = this.series.chart,\n"
                "c = a.hoverPoints,\n"
                "f;\n"
                "a.pointCount--;\n"
                "c && (this.setState(), G(c, this), c.length || (a.hoverPoints = null));\n"
                "if (this === a.hoverPoint) this.onMouseOut();\n"
                "if (this.graphic || this.dataLabel) u(this),\n"
                "this.destroyElements();\n"
                "this.legendItem && a.legend.destroyItem(this);\n"
                "for (f in this) this[f] = null\n"
            "},\n"
            "destroyElements: function() {\n"
                "for (var a = [\"graphic\", \"dataLabel\", \"dataLabelUpper\", \"connector\", \"shadowGroup\"], c, f = 6; f--;) c = a[f],\n"
                "this[c] && (this[c] = this[c].destroy())\n"
            "},\n"
            "getLabelConfig: function() {\n"
                "return {\n"
                    "x: this.category,\n"
                    "y: this.y,\n"
                    "color: this.color,\n"
                    "colorIndex: this.colorIndex,\n"
                    "key: this.name || this.category,\n"
                    "series: this.series,\n"
                    "point: this,\n"
                    "percentage: this.percentage,\n"
                    "total: this.total || this.stackTotal\n"
                "}\n"
            "},\n"
            "tooltipFormatter: function(a) {\n"
                "var c = this.series,\n"
                "d = c.tooltipOptions,\n"
                "l = k(d.valueDecimals, \"\"),\n"
                "b = d.valuePrefix || \"\",\n"
                "p = d.valueSuffix || \"\";\n"
                "A(c.pointArrayMap || [\"y\"],\n"
                "function(c) {\n"
                    "c = \"{point.\" + c;\n"
                    "if (b || p) a = a.replace(c + \"}\", b + c + \"}\" + p);\n"
                    "a = a.replace(c + \"}\", c + \":,.\" + l + \"f}\")\n"
                "});\n"
                "return f(a, {\n"
                    "point: this,\n"
                    "series: this.series\n"
                "})\n"
            "},\n"
            "firePointEvent: function(a, c, f) {\n"
                "var d = this,\n"
                "b = this.series.options; (b.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents();\n"
                "\"click\" === a && b.allowPointSelect && (f = function(a) {\n"
                    "d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey)\n"
                "});\n"
                "r(this, a, c, f)\n"
            "},\n"
            "visible: !0\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.animObject,\n"
        "H = a.arrayMax,\n"
        "G = a.arrayMin,\n"
        "r = a.correctFloat,\n"
        "f = a.Date,\n"
        "l = a.defaultOptions,\n"
        "q = a.defaultPlotOptions,\n"
        "k = a.defined,\n"
        "u = a.each,\n"
        "d = a.erase,\n"
        "c = a.extend,\n"
        "n = a.fireEvent,\n"
        "z = a.grep,\n"
        "b = a.isArray,\n"
        "p = a.isNumber,\n"
        "h = a.isString,\n"
        "t = a.merge,\n"
        "D = a.pick,\n"
        "w = a.removeEvent,\n"
        "e = a.splat,\n"
        "x = a.SVGElement,\n"
        "C = a.syncTimeout,\n"
        "E = a.win;\n"
        "a.Series = a.seriesType(\"line\", null, {\n"
            "lineWidth: 2,\n"
            "allowPointSelect: !1,\n"
            "showCheckbox: !1,\n"
            "animation: {\n"
                "duration: 1E3\n"
            "},\n"
            "events: {},\n"
            "marker: {\n"
                "lineWidth: 0,\n"
                "lineColor: \"#ffffff\",\n"
                "radius: 4,\n"
                "states: {\n"
                    "hover: {\n"
                        "animation: {\n"
                            "duration: 50\n"
                        "},\n"
                        "enabled: !0,\n"
                        "radiusPlus: 2,\n"
                        "lineWidthPlus: 1\n"
                    "},\n"
                    "select: {\n"
                        "fillColor: \"#cccccc\",\n"
                        "lineColor: \"#000000\",\n"
                        "lineWidth: 2\n"
                    "}\n"
                "}\n"
            "},\n"
            "point: {\n"
                "events: {}\n"
            "},\n"
            "dataLabels: {\n"
                "align: \"center\",\n"
                "formatter: function() {\n"
                    "return null === this.y ? \"\": a.numberFormat(this.y, -1)\n"
                "},\n"
                "style: {\n"
                    "fontSize: \"11px\",\n"
                    "fontWeight: \"bold\",\n"
                    "color: \"contrast\",\n"
                    "textOutline: \"1px contrast\"\n"
                "},\n"
                "verticalAlign: \"bottom\",\n"
                "x: 0,\n"
                "y: 0,\n"
                "padding: 5\n"
            "},\n"
            "cropThreshold: 300,\n"
            "pointRange: 0,\n"
            "softThreshold: !0,\n"
            "states: {\n"
                "hover: {\n"
                    "animation: {\n"
                        "duration: 50\n"
                    "},\n"
                    "lineWidthPlus: 1,\n"
                    "marker: {},\n"
                    "halo: {\n"
                        "size: 10,\n"
                        "opacity: .25\n"
                    "}\n"
                "},\n"
                "select: {\n"
                    "marker: {}\n"
                "}\n"
            "},\n"
            "stickyTracking: !0,\n"
            "turboThreshold: 1E3,\n"
            "findNearestPointBy: \"x\"\n"
        "},\n"
        "{\n"
            "isCartesian: !0,\n"
            "pointClass: a.Point,\n"
            "sorted: !0,\n"
            "requireSorting: !0,\n"
            "directTouch: !1,\n"
            "axisTypes: [\"xAxis\", \"yAxis\"],\n"
            "colorCounter: 0,\n"
            "parallelArrays: [\"x\", \"y\"],\n"
            "coll: \"series\",\n"
            "init: function(a, b) {\n"
                "var e = this,\n"
                "d, m, g = a.series,\n"
                "h;\n"
                "e.chart = a;\n"
                "e.options = b = e.setOptions(b);\n"
                "e.linkedSeries = [];\n"
                "e.bindAxes();\n"
                "c(e, {\n"
                    "name: b.name,\n"
                    "state: \"\",\n"
                    "visible: !1 !== b.visible,\n"
                    "selected: !0 === b.selected\n"
                "});\n"
                "m = b.events;\n"
                "for (d in m) B(e, d, m[d]);\n"
                "if (m && m.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;\n"
                "e.getColor();\n"
                "e.getSymbol();\n"
                "u(e.parallelArrays,\n"
                "function(a) {\n"
                    "e[a + \"Data\"] = []\n"
                "});\n"
                "e.setData(b.data, !1);\n"
                "e.isCartesian && (a.hasCartesianSeries = !0);\n"
                "g.length && (h = g[g.length - 1]);\n"
                "e._i = D(h && h._i, -1) + 1;\n"
                "a.orderSeries(this.insert(g))\n"
            "},\n"
            "insert: function(a) {\n"
                "var b = this.options.index,\n"
                "c;\n"
                "if (p(b)) {\n"
                    "for (c = a.length; c--;) if (b >= D(a[c].options.index, a[c]._i)) {\n"
                        "a.splice(c + 1, 0, this);\n"
                        "break\n"
                    "} - 1 === c && a.unshift(this);\n"
                    "c += 1\n"
                "} else a.push(this);\n"
                "return D(c, a.length - 1)\n"
            "},\n"
            "bindAxes: function() {\n"
                "var b = this,\n"
                "c = b.options,\n"
                "e = b.chart,\n"
                "d;\n"
                "u(b.axisTypes || [],\n"
                "function(m) {\n"
                    "u(e[m],\n"
                    "function(a) {\n"
                        "d = a.options;\n"
                        "if (c[m] === d.index || void 0 !== c[m] && c[m] === d.id || void 0 === c[m] && 0 === d.index) b.insert(a.series),\n"
                        "b[m] = a,\n"
                        "a.isDirty = !0\n"
                    "});\n"
                    "b[m] || b.optionalAxis === m || a.error(18, !0)\n"
                "})\n"
            "},\n"
            "updateParallelArrays: function(a, b) {\n"
                "var c = a.series,\n"
                "e = arguments,\n"
                "d = p(b) ?\n"
                "function(e) {\n"
                    "var g = \"y\" === e && c.toYData ? c.toYData(a) : a[e];\n"
                    "c[e + \"Data\"][b] = g\n"
                "}: function(a) {\n"
                    "Array.prototype[b].apply(c[a + \"Data\"], Array.prototype.slice.call(e, 2))\n"
                "};\n"
                "u(c.parallelArrays, d)\n"
            "},\n"
            "autoIncrement: function() {\n"
                "var a = this.options,\n"
                "b = this.xIncrement,\n"
                "c, e = a.pointIntervalUnit,\n"
                "b = D(b, a.pointStart, 0);\n"
                "this.pointInterval = c = D(this.pointInterval, a.pointInterval, 1);\n"
                "e && (a = new f(b), \"day\" === e ? a = +a[f.hcSetDate](a[f.hcGetDate]() + c) : \"month\" === e ? a = +a[f.hcSetMonth](a[f.hcGetMonth]() + c) : \"year\" === e && (a = +a[f.hcSetFullYear](a[f.hcGetFullYear]() + c)), c = a - b);\n"
                "this.xIncrement = b + c;\n"
                "return b\n"
            "},\n"
            "setOptions: function(a) {\n"
                "var b = this.chart,\n"
                "c = b.options.plotOptions,\n"
                "b = b.userOptions || {},\n"
                "e = b.plotOptions || {},\n"
                "d = c[this.type];\n"
                "this.userOptions = a;\n"
                "c = t(d, c.series, a);\n"
                "this.tooltipOptions = t(l.tooltip, l.plotOptions[this.type].tooltip, b.tooltip, e.series && e.series.tooltip, e[this.type] && e[this.type].tooltip, a.tooltip);\n"
                "this.stickyTracking = D(a.stickyTracking, e[this.type] && e[this.type].stickyTracking, e.series && e.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : c.stickyTracking);\n"
                "null === d.marker && delete c.marker;\n"
                "this.zoneAxis = c.zoneAxis;\n"
                "a = this.zones = (c.zones || []).slice(); ! c.negativeColor && !c.negativeFillColor || c.zones || a.push({\n"
                    "value: c[this.zoneAxis + \"Threshold\"] || c.threshold || 0,\n"
                    "className: \"highcharts-negative\",\n"
                    "color: c.negativeColor,\n"
                    "fillColor: c.negativeFillColor\n"
                "});\n"
                "a.length && k(a[a.length - 1].value) && a.push({\n"
                    "color: this.color,\n"
                    "fillColor: this.fillColor\n"
                "});\n"
                "return c\n"
            "},\n"
            "getCyclic: function(a, b, c) {\n"
                "var e, d = this.chart,\n"
                "g = this.userOptions,\n"
                "m = a + \"Index\",\n"
                "h = a + \"Counter\",\n"
                "f = c ? c.length: D(d.options.chart[a + \"Count\"], d[a + \"Count\"]);\n"
                "b || (e = D(g[m], g[\"_\" + m]), k(e) || (d.series.length || (d[h] = 0), g[\"_\" + m] = e = d[h] % f, d[h] += 1), c && (b = c[e]));\n"
                "void 0 !== e && (this[m] = e);\n"
                "this[a] = b\n"
            "},\n"
            "getColor: function() {\n"
                "this.options.colorByPoint ? this.options.color = null: this.getCyclic(\"color\", this.options.color || q[this.type].color, this.chart.options.colors)\n"
            "},\n"
            "getSymbol: function() {\n"
                "this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols)\n"
            "},\n"
            "drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker,\n"
            "setData: function(c, e, d, f) {\n"
                "var m = this,\n"
                "g = m.points,\n"
                "k = g && g.length || 0,\n"
                "n, l = m.options,\n"
                "y = m.chart,\n"
                "t = null,\n"
                "q = m.xAxis,\n"
                "x = l.turboThreshold,\n"
                "r = this.xData,\n"
                "w = this.yData,\n"
                "C = (n = m.pointArrayMap) && n.length;\n"
                "c = c || [];\n"
                "n = c.length;\n"
                "e = D(e, !0);\n"
                "if (!1 !== f && n && k === n && !m.cropped && !m.hasGroupedData && m.visible) u(c,\n"
                "function(a, b) {\n"
                    "g[b].update && a !== l.data[b] && g[b].update(a, !1, null, !1)\n"
                "});\n"
                "else {\n"
                    "m.xIncrement = null;\n"
                    "m.colorCounter = 0;\n"
                    "u(this.parallelArrays,\n"
                    "function(a) {\n"
                        "m[a + \"Data\"].length = 0\n"
                    "});\n"
                    "if (x && n > x) {\n"
                        "for (d = 0; null === t && d < n;) t = c[d],\n"
                        "d++;\n"
                        "if (p(t)) for (d = 0; d < n; d++) r[d] = this.autoIncrement(),\n"
                        "w[d] = c[d];\n"
                        "else if (b(t)) if (C) for (d = 0; d < n; d++) t = c[d],\n"
                        "r[d] = t[0],\n"
                        "w[d] = t.slice(1, C + 1);\n"
                        "else for (d = 0; d < n; d++) t = c[d],\n"
                        "r[d] = t[0],\n"
                        "w[d] = t[1];\n"
                        "else a.error(12)\n"
                    "} else for (d = 0; d < n; d++) void 0 !== c[d] && (t = {\n"
                        "series: m\n"
                    "},\n"
                    "m.pointClass.prototype.applyOptions.apply(t, [c[d]]), m.updateParallelArrays(t, d));\n"
                    "h(w[0]) && a.error(14, !0);\n"
                    "m.data = [];\n"
                    "m.options.data = m.userOptions.data = c;\n"
                    "for (d = k; d--;) g[d] && g[d].destroy && g[d].destroy();\n"
                    "q && (q.minRange = q.userMinRange);\n"
                    "m.isDirty = y.isDirtyBox = !0;\n"
                    "m.isDirtyData = !!g;\n"
                    "d = !1\n"
                "}\n"
                "\"point\" === l.legendType && (this.processData(), this.generatePoints());\n"
                "e && y.redraw(d)\n"
            "},\n"
            "processData: function(b) {\n"
                "var c = this.xData,\n"
                "e = this.yData,\n"
                "d = c.length,\n"
                "m;\n"
                "m = 0;\n"
                "var g, h, f = this.xAxis,\n"
                "p, k = this.options;\n"
                "p = k.cropThreshold;\n"
                "var n = this.getExtremesFromAll || k.getExtremesFromAll,\n"
                "l = this.isCartesian,\n"
                "k = f && f.val2lin,\n"
                "t = f && f.isLog,\n"
                "q, x;\n"
                "if (l && !this.isDirty && !f.isDirty && !this.yAxis.isDirty && !b) return ! 1;\n"
                "f && (b = f.getExtremes(), q = b.min, x = b.max);\n"
                "if (l && this.sorted && !n && (!p || d > p || this.forceCrop)) if (c[d - 1] < q || c[0] > x) c = [],\n"
                "e = [];\n"
                "else if (c[0] < q || c[d - 1] > x) m = this.cropData(this.xData, this.yData, q, x),\n"
                "c = m.xData,\n"
                "e = m.yData,\n"
                "m = m.start,\n"
                "g = !0;\n"
                "for (p = c.length || 1; --p;) d = t ? k(c[p]) - k(c[p - 1]) : c[p] - c[p - 1],\n"
                "0 < d && (void 0 === h || d < h) ? h = d: 0 > d && this.requireSorting && a.error(15);\n"
                "this.cropped = g;\n"
                "this.cropStart = m;\n"
                "this.processedXData = c;\n"
                "this.processedYData = e;\n"
                "this.closestPointRange = h\n"
            "},\n"
            "cropData: function(a, b, c, e) {\n"
                "var d = a.length,\n"
                "g = 0,\n"
                "m = d,\n"
                "h = D(this.cropShoulder, 1),\n"
                "f;\n"
                "for (f = 0; f < d; f++) if (a[f] >= c) {\n"
                    "g = Math.max(0, f - h);\n"
                    "break\n"
                "}\n"
                "for (c = f; c < d; c++) if (a[c] > e) {\n"
                    "m = c + h;\n"
                    "break\n"
                "}\n"
                "return {\n"
                    "xData: a.slice(g, m),\n"
                    "yData: b.slice(g, m),\n"
                    "start: g,\n"
                    "end: m\n"
                "}\n"
            "},\n"
            "generatePoints: function() {\n"
                "var a = this.options.data,\n"
                "b = this.data,\n"
                "c, d = this.processedXData,\n"
                "h = this.processedYData,\n"
                "g = this.pointClass,\n"
                "f = d.length,\n"
                "p = this.cropStart || 0,\n"
                "k, n = this.hasGroupedData,\n"
                "l, t = [],\n"
                "q;\n"
                "b || n || (b = [], b.length = a.length, b = this.data = b);\n"
                "for (q = 0; q < f; q++) k = p + q,\n"
                "n ? (l = (new g).init(this, [d[q]].concat(e(h[q]))), l.dataGroup = this.groupMap[q]) : (l = b[k]) || void 0 === a[k] || (b[k] = l = (new g).init(this, a[k], d[q])),\n"
                "l && (l.index = k, t[q] = l);\n"
                "if (b && (f !== (c = b.length) || n)) for (q = 0; q < c; q++) q !== p || n || (q += f),\n"
                "b[q] && (b[q].destroyElements(), b[q].plotX = void 0);\n"
                "this.data = b;\n"
                "this.points = t\n"
            "},\n"
            "getExtremes: function(a) {\n"
                "var c = this.yAxis,\n"
                "e = this.processedXData,\n"
                "d, m = [],\n"
                "g = 0;\n"
                "d = this.xAxis.getExtremes();\n"
                "var h = d.min,\n"
                "f = d.max,\n"
                "k, n, l, t;\n"
                "a = a || this.stackedYData || this.processedYData || [];\n"
                "d = a.length;\n"
                "for (t = 0; t < d; t++) if (n = e[t], l = a[t], k = (p(l, !0) || b(l)) && (!c.positiveValuesOnly || l.length || 0 < l), n = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (e[t] || n) >= h && (e[t] || n) <= f, k && n) if (k = l.length) for (; k--;) null !== l[k] && (m[g++] = l[k]);\n"
                "else m[g++] = l;\n"
                "this.dataMin = G(m);\n"
                "this.dataMax = H(m)\n"
            "},\n"
            "translate: function() {\n"
                "this.processedXData || this.processData();\n"
                "this.generatePoints();\n"
                "var a = this.options,\n"
                "b = a.stacking,\n"
                "c = this.xAxis,\n"
                "e = c.categories,\n"
                "d = this.yAxis,\n"
                "g = this.points,\n"
                "h = g.length,\n"
                "f = !!this.modifyValue,\n"
                "n = a.pointPlacement,\n"
                "l = \"between\" === n || p(n),\n"
                "t = a.threshold,\n"
                "q = a.startFromThreshold ? t: 0,\n"
                "x,\n"
                "u,\n"
                "w,\n"
                "C,\n"
                "E = Number.MAX_VALUE;\n"
                "\"between\" === n && (n = .5);\n"
                "p(n) && (n *= D(a.pointRange || c.pointRange));\n"
                "for (a = 0; a < h; a++) {\n"
                    "var z = g[a],\n"
                    "A = z.x,\n"
                    "B = z.y;\n"
                    "u = z.low;\n"
                    "var H = b && d.stacks[(this.negStacks && B < (q ? 0 : t) ? \"-\": \"\") + this.stackKey],\n"
                    "G;\n"
                    "d.positiveValuesOnly && null !== B && 0 >= B && (z.isNull = !0);\n"
                    "z.plotX = x = r(Math.min(Math.max( - 1E5, c.translate(A, 0, 0, 0, 1, n, \"flags\" === this.type)), 1E5));\n"
                    "b && this.visible && !z.isNull && H && H[A] && (C = this.getStackIndicator(C, A, this.index), G = H[A], B = G.points[C.key], u = B[0], B = B[1], u === q && C.key === H[A].base && (u = D(t, d.min)), d.positiveValuesOnly && 0 >= u && (u = null), z.total = z.stackTotal = G.total, z.percentage = G.total && z.y / G.total * 100, z.stackY = B, G.setOffset(this.pointXOffset || 0, this.barW || 0));\n"
                    "z.yBottom = k(u) ? d.translate(u, 0, 1, 0, 1) : null;\n"
                    "f && (B = this.modifyValue(B, z));\n"
                    "z.plotY = u = \"number\" === typeof B && Infinity !== B ? Math.min(Math.max( - 1E5, d.translate(B, 0, 1, 0, 1)), 1E5) : void 0;\n"
                    "z.isInside = void 0 !== u && 0 <= u && u <= d.len && 0 <= x && x <= c.len;\n"
                    "z.clientX = l ? r(c.translate(A, 0, 0, 0, 1, n)) : x;\n"
                    "z.negative = z.y < (t || 0);\n"
                    "z.category = e && void 0 !== e[z.x] ? e[z.x] : z.x;\n"
                    "z.isNull || (void 0 !== w && (E = Math.min(E, Math.abs(x - w))), w = x);\n"
                    "z.zone = this.zones.length && z.getZone()\n"
                "}\n"
                "this.closestPointRangePx = E\n"
            "},\n"
            "getValidPoints: function(a, b) {\n"
                "var c = this.chart;\n"
                "return z(a || this.points || [],\n"
                "function(a) {\n"
                    "return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull\n"
                "})\n"
            "},\n"
            "setClip: function(a) {\n"
                "var b = this.chart,\n"
                "c = this.options,\n"
                "e = b.renderer,\n"
                "d = b.inverted,\n"
                "g = this.clipBox,\n"
                "h = g || b.clipBox,\n"
                "m = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, h.height, c.xAxis, c.yAxis].join(),\n"
                "f = b[m],\n"
                "p = b[m + \"m\"];\n"
                "f || (a && (h.width = 0, b[m + \"m\"] = p = e.clipRect( - 99, d ? -b.plotLeft: -b.plotTop, 99, d ? b.chartWidth: b.chartHeight)), b[m] = f = e.clipRect(h), f.count = {\n"
                    "length: 0\n"
                "});\n"
                "a && !f.count[this.index] && (f.count[this.index] = !0, f.count.length += 1); ! 1 !== c.clip && (this.group.clip(a || g ? f: b.clipRect), this.markerGroup.clip(p), this.sharedClipKey = m);\n"
                "a || (f.count[this.index] && (delete f.count[this.index], --f.count.length), 0 === f.count.length && m && b[m] && (g || (b[m] = b[m].destroy()), b[m + \"m\"] && (b[m + \"m\"] = b[m + \"m\"].destroy())))\n"
            "},\n"
            "animate: function(a) {\n"
                "var b = this.chart,\n"
                "c = A(this.options.animation),\n"
                "e;\n"
                "a ? this.setClip(c) : (e = this.sharedClipKey, (a = b[e]) && a.animate({\n"
                    "width: b.plotSizeX\n"
                "},\n"
                "c), b[e + \"m\"] && b[e + \"m\"].animate({\n"
                    "width: b.plotSizeX + 99\n"
                "},\n"
                "c), this.animate = null)\n"
            "},\n"
            "afterAnimate: function() {\n"
                "this.setClip();\n"
                "n(this, \"afterAnimate\")\n"
            "},\n"
            "drawPoints: function() {\n"
                "var a = this.points,\n"
                "b = this.chart,\n"
                "c, e, d, g, h = this.options.marker,\n"
                "f, n, k, l, t = this.markerGroup,\n"
                "q = D(h.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= 2 * h.radius);\n"
                "if (!1 !== h.enabled || this._hasPointMarkers) for (e = 0; e < a.length; e++) d = a[e],\n"
                "c = d.plotY,\n"
                "g = d.graphic,\n"
                "f = d.marker || {},\n"
                "n = !!d.marker,\n"
                "k = q && void 0 === f.enabled || f.enabled,\n"
                "l = d.isInside,\n"
                "k && p(c) && null !== d.y ? (c = D(f.symbol, this.symbol), d.hasImage = 0 === c.indexOf(\"url\"), k = this.markerAttribs(d, d.selected && \"select\"), g ? g[l ? \"show\": \"hide\"](!0).animate(k) : l && (0 < k.width || d.hasImage) && (d.graphic = g = b.renderer.symbol(c, k.x, k.y, k.width, k.height, n ? f: h).add(t)), g && g.attr(this.pointAttribs(d, d.selected && \"select\")), g && g.addClass(d.getClassName(), !0)) : g && (d.graphic = g.destroy())\n"
            "},\n"
            "markerAttribs: function(a, b) {\n"
                "var c = this.options.marker,\n"
                "e = a.marker || {},\n"
                "d = D(e.radius, c.radius);\n"
                "b && (c = c.states[b], b = e.states && e.states[b], d = D(b && b.radius, c && c.radius, d + (c && c.radiusPlus || 0)));\n"
                "a.hasImage && (d = 0);\n"
                "a = {\n"
                    "x: Math.floor(a.plotX) - d,\n"
                    "y: a.plotY - d\n"
                "};\n"
                "d && (a.width = a.height = 2 * d);\n"
                "return a\n"
            "},\n"
            "pointAttribs: function(a, b) {\n"
                "var c = this.options.marker,\n"
                "e = a && a.options,\n"
                "d = e && e.marker || {},\n"
                "g = this.color,\n"
                "h = e && e.color,\n"
                "f = a && a.color,\n"
                "e = D(d.lineWidth, c.lineWidth);\n"
                "a = a && a.zone && a.zone.color;\n"
                "g = h || a || f || g;\n"
                "a = d.fillColor || c.fillColor || g;\n"
                "g = d.lineColor || c.lineColor || g;\n"
                "b && (c = c.states[b], b = d.states && d.states[b] || {},\n"
                "e = D(b.lineWidth, c.lineWidth, e + D(b.lineWidthPlus, c.lineWidthPlus, 0)), a = b.fillColor || c.fillColor || a, g = b.lineColor || c.lineColor || g);\n"
                "return {\n"
                    "stroke: g,\n"
                    "\"stroke-width\": e,\n"
                    "fill: a\n"
                "}\n"
            "},\n"
            "destroy: function() {\n"
                "var a = this,\n"
                "b = a.chart,\n"
                "c = /AppleWebKit\\/533/.test(E.navigator.userAgent),\n"
                "e,\n"
                "h = a.data || [],\n"
                "g,\n"
                "f,\n"
                "k;\n"
                "n(a, \"destroy\");\n"
                "w(a);\n"
                "u(a.axisTypes || [],\n"
                "function(b) { (k = a[b]) && k.series && (d(k.series, a), k.isDirty = k.forceRedraw = !0)\n"
                "});\n"
                "a.legendItem && a.chart.legend.destroyItem(a);\n"
                "for (e = h.length; e--;)(g = h[e]) && g.destroy && g.destroy();\n"
                "a.points = null;\n"
                "clearTimeout(a.animationTimeout);\n"
                "for (f in a) a[f] instanceof x && !a[f].survive && (e = c && \"group\" === f ? \"hide\": \"destroy\", a[f][e]());\n"
                "b.hoverSeries === a && (b.hoverSeries = null);\n"
                "d(b.series, a);\n"
                "b.orderSeries();\n"
                "for (f in a) delete a[f]\n"
            "},\n"
            "getGraphPath: function(a, b, c) {\n"
                "var e = this,\n"
                "d = e.options,\n"
                "g = d.step,\n"
                "h, f = [],\n"
                "m = [],\n"
                "p;\n"
                "a = a || e.points; (h = a.reversed) && a.reverse(); (g = {\n"
                    "right: 1,\n"
                    "center: 2\n"
                "} [g] || g && 3) && h && (g = 4 - g); ! d.connectNulls || b || c || (a = this.getValidPoints(a));\n"
                "u(a,\n"
                "function(h, n) {\n"
                    "var l = h.plotX,\n"
                    "t = h.plotY,\n"
                    "q = a[n - 1]; (h.leftCliff || q && q.rightCliff) && !c && (p = !0);\n"
                    "h.isNull && !k(b) && 0 < n ? p = !d.connectNulls: h.isNull && !b ? p = !0 : (0 === n || p ? n = [\"M\", h.plotX, h.plotY] : e.getPointSpline ? n = e.getPointSpline(a, h, n) : g ? (n = 1 === g ? [\"L\", q.plotX, t] : 2 === g ? [\"L\", (q.plotX + l) / 2, q.plotY, \"L\", (q.plotX + l) / 2, t] : [\"L\", l, q.plotY], n.push(\"L\", l, t)) : n = [\"L\", l, t], m.push(h.x), g && m.push(h.x), f.push.apply(f, n), p = !1)\n"
                "});\n"
                "f.xMap = m;\n"
                "return e.graphPath = f\n"
            "},\n"
            "drawGraph: function() {\n"
                "var a = this,\n"
                "b = this.options,\n"
                "c = (this.gappedPath || this.getGraphPath).call(this),\n"
                "e = [[\"graph\", \"highcharts-graph\", b.lineColor || this.color, b.dashStyle]];\n"
                "u(this.zones,\n"
                "function(c, d) {\n"
                    "e.push([\"zone-graph-\" + d, \"highcharts-graph highcharts-zone-graph-\" + d + \" \" + (c.className || \"\"), c.color || a.color, c.dashStyle || b.dashStyle])\n"
                "});\n"
                "u(e,\n"
                "function(e, d) {\n"
                    "var g = e[0],\n"
                    "h = a[g];\n"
                    "h ? (h.endX = c.xMap, h.animate({\n"
                        "d: c\n"
                    "})) : c.length && (a[g] = a.chart.renderer.path(c).addClass(e[1]).attr({\n"
                        "zIndex: 1\n"
                    "}).add(a.group), h = {\n"
                        "stroke: e[2],\n"
                        "\"stroke-width\": b.lineWidth,\n"
                        "fill: a.fillGraph && a.color || \"none\"\n"
                    "},\n"
                    "e[3] ? h.dashstyle = e[3] : \"square\" !== b.linecap && (h[\"stroke-linecap\"] = h[\"stroke-linejoin\"] = \"round\"), h = a[g].attr(h).shadow(2 > d && b.shadow));\n"
                    "h && (h.startX = c.xMap, h.isArea = c.isArea)\n"
                "})\n"
            "},\n"
            "applyZones: function() {\n"
                "var a = this,\n"
                "b = this.chart,\n"
                "c = b.renderer,\n"
                "e = this.zones,\n"
                "d, g, h = this.clips || [],\n"
                "f,\n"
                "k = this.graph,\n"
                "p = this.area,\n"
                "n = Math.max(b.chartWidth, b.chartHeight),\n"
                "l = this[(this.zoneAxis || \"y\") + \"Axis\"],\n"
                "t,\n"
                "q,\n"
                "x = b.inverted,\n"
                "w,\n"
                "r,\n"
                "C,\n"
                "E,\n"
                "z = !1;\n"
                "e.length && (k || p) && l && void 0 !== l.min && (q = l.reversed, w = l.horiz, k && k.hide(), p && p.hide(), t = l.getExtremes(), u(e,\n"
                "function(e, m) {\n"
                    "d = q ? w ? b.plotWidth: 0 : w ? 0 : l.toPixels(t.min);\n"
                    "d = Math.min(Math.max(D(g, d), 0), n);\n"
                    "g = Math.min(Math.max(Math.round(l.toPixels(D(e.value, t.max), !0)), 0), n);\n"
                    "z && (d = g = l.toPixels(t.max));\n"
                    "r = Math.abs(d - g);\n"
                    "C = Math.min(d, g);\n"
                    "E = Math.max(d, g);\n"
                    "l.isXAxis ? (f = {\n"
                        "x: x ? E: C,\n"
                        "y: 0,\n"
                        "width: r,\n"
                        "height: n\n"
                    "},\n"
                    "w || (f.x = b.plotHeight - f.x)) : (f = {\n"
                        "x: 0,\n"
                        "y: x ? E: C,\n"
                        "width: n,\n"
                        "height: r\n"
                    "},\n"
                    "w && (f.y = b.plotWidth - f.y));\n"
                    "x && c.isVML && (f = l.isXAxis ? {\n"
                        "x: 0,\n"
                        "y: q ? C: E,\n"
                        "height: f.width,\n"
                        "width: b.chartWidth\n"
                    "}: {\n"
                        "x: f.y - b.plotLeft - b.spacingBox.x,\n"
                        "y: 0,\n"
                        "width: f.height,\n"
                        "height: b.chartHeight\n"
                    "});\n"
                    "h[m] ? h[m].animate(f) : (h[m] = c.clipRect(f), k && a[\"zone-graph-\" + m].clip(h[m]), p && a[\"zone-area-\" + m].clip(h[m]));\n"
                    "z = e.value > t.max\n"
                "}), this.clips = h)\n"
            "},\n"
            "invertGroups: function(a) {\n"
                "function b() {\n"
                    "u([\"group\", \"markerGroup\"],\n"
                    "function(b) {\n"
                        "c[b] && (e.renderer.isVML && c[b].attr({\n"
                            "width: c.yAxis.len,\n"
                            "height: c.xAxis.len\n"
                        "}), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a))\n"
                    "})\n"
                "}\n"
                "var c = this,\n"
                "e = c.chart,\n"
                "d;\n"
                "c.xAxis && (d = B(e, \"resize\", b), B(c, \"destroy\", d), b(a), c.invertGroups = b)\n"
            "},\n"
            "plotGroup: function(a, b, c, e, d) {\n"
                "var g = this[a],\n"
                "h = !g;\n"
                "h && (this[a] = g = this.chart.renderer.g(b).attr({\n"
                    "zIndex: e || .1\n"
                "}).add(d), g.addClass(\"highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series highcharts-color-\" + this.colorIndex + \" \" + (this.options.className || \"\")));\n"
                "g.attr({\n"
                    "visibility: c\n"
                "})[h ? \"attr\": \"animate\"](this.getPlotBox());\n"
                "return g\n"
            "},\n"
            "getPlotBox: function() {\n"
                "var a = this.chart,\n"
                "b = this.xAxis,\n"
                "c = this.yAxis;\n"
                "a.inverted && (b = c, c = this.xAxis);\n"
                "return {\n"
                    "translateX: b ? b.left: a.plotLeft,\n"
                    "translateY: c ? c.top: a.plotTop,\n"
                    "scaleX: 1,\n"
                    "scaleY: 1\n"
                "}\n"
            "},\n"
            "render: function() {\n"
                "var a = this,\n"
                "b = a.chart,\n"
                "c, e = a.options,\n"
                "d = !!a.animate && b.renderer.isSVG && A(e.animation).duration,\n"
                "g = a.visible ? \"inherit\": \"hidden\",\n"
                "h = e.zIndex,\n"
                "f = a.hasRendered,\n"
                "k = b.seriesGroup,\n"
                "p = b.inverted;\n"
                "c = a.plotGroup(\"group\", \"series\", g, h, k);\n"
                "a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", g, h, k);\n"
                "d && a.animate(!0);\n"
                "c.inverted = a.isCartesian ? p: !1;\n"
                "a.drawGraph && (a.drawGraph(), a.applyZones());\n"
                "a.drawDataLabels && a.drawDataLabels();\n"
                "a.visible && a.drawPoints();\n"
                "a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n"
                "a.invertGroups(p); ! 1 === e.clip || a.sharedClipKey || f || c.clip(b.clipRect);\n"
                "d && a.animate();\n"
                "f || (a.animationTimeout = C(function() {\n"
                    "a.afterAnimate()\n"
                "},\n"
                "d));\n"
                "a.isDirty = !1;\n"
                "a.hasRendered = !0\n"
            "},\n"
            "redraw: function() {\n"
                "var a = this.chart,\n"
                "b = this.isDirty || this.isDirtyData,\n"
                "c = this.group,\n"
                "e = this.xAxis,\n"
                "d = this.yAxis;\n"
                "c && (a.inverted && c.attr({\n"
                    "width: a.plotWidth,\n"
                    "height: a.plotHeight\n"
                "}), c.animate({\n"
                    "translateX: D(e && e.left, a.plotLeft),\n"
                    "translateY: D(d && d.top, a.plotTop)\n"
                "}));\n"
                "this.translate();\n"
                "this.render();\n"
                "b && delete this.kdTree\n"
            "},\n"
            "kdAxisArray: [\"clientX\", \"plotY\"],\n"
            "searchPoint: function(a, b) {\n"
                "var c = this.xAxis,\n"
                "e = this.yAxis,\n"
                "d = this.chart.inverted;\n"
                "return this.searchKDTree({\n"
                    "clientX: d ? c.len - a.chartY + c.pos: a.chartX - c.pos,\n"
                    "plotY: d ? e.len - a.chartX + e.pos: a.chartY - e.pos\n"
                "},\n"
                "b)\n"
            "},\n"
            "buildKDTree: function() {\n"
                "function a(c, e, d) {\n"
                    "var g, h;\n"
                    "if (h = c && c.length) return g = b.kdAxisArray[e % d],\n"
                    "c.sort(function(a, b) {\n"
                        "return a[g] - b[g]\n"
                    "}),\n"
                    "h = Math.floor(h / 2),\n"
                    "{\n"
                        "point: c[h],\n"
                        "left: a(c.slice(0, h), e + 1, d),\n"
                        "right: a(c.slice(h + 1), e + 1, d)\n"
                    "}\n"
                "}\n"
                "this.buildingKdTree = !0;\n"
                "var b = this,\n"
                "c = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n"
                "delete b.kdTree;\n"
                "C(function() {\n"
                    "b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);\n"
                    "b.buildingKdTree = !1\n"
                "},\n"
                "b.options.kdNow ? 0 : 1)\n"
            "},\n"
            "searchKDTree: function(a, b) {\n"
                "function c(a, b, f, m) {\n"
                    "var p = b.point,\n"
                    "n = e.kdAxisArray[f % m],\n"
                    "l,\n"
                    "t,\n"
                    "q = p;\n"
                    "t = k(a[d]) && k(p[d]) ? Math.pow(a[d] - p[d], 2) : null;\n"
                    "l = k(a[g]) && k(p[g]) ? Math.pow(a[g] - p[g], 2) : null;\n"
                    "l = (t || 0) + (l || 0);\n"
                    "p.dist = k(l) ? Math.sqrt(l) : Number.MAX_VALUE;\n"
                    "p.distX = k(t) ? Math.sqrt(t) : Number.MAX_VALUE;\n"
                    "n = a[n] - p[n];\n"
                    "l = 0 > n ? \"left\": \"right\";\n"
                    "t = 0 > n ? \"right\": \"left\";\n"
                    "b[l] && (l = c(a, b[l], f + 1, m), q = l[h] < q[h] ? l: p);\n"
                    "b[t] && Math.sqrt(n * n) < q[h] && (a = c(a, b[t], f + 1, m), q = a[h] < q[h] ? a: q);\n"
                    "return q\n"
                "}\n"
                "var e = this,\n"
                "d = this.kdAxisArray[0],\n"
                "g = this.kdAxisArray[1],\n"
                "h = b ? \"distX\": \"dist\";\n"
                "b = -1 < e.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n"
                "this.kdTree || this.buildingKdTree || this.buildKDTree();\n"
                "if (this.kdTree) return c(a, this.kdTree, b, b)\n"
            "}\n"
        "})\n"
    "})(L); (function(a) {\n"
        "function B(a, d, c, f, l) {\n"
            "var b = a.chart.inverted;\n"
            "this.axis = a;\n"
            "this.isNegative = c;\n"
            "this.options = d;\n"
            "this.x = f;\n"
            "this.total = null;\n"
            "this.points = {};\n"
            "this.stack = l;\n"
            "this.rightCliff = this.leftCliff = 0;\n"
            "this.alignOptions = {\n"
                "align: d.align || (b ? c ? \"left\": \"right\": \"center\"),\n"
                "verticalAlign: d.verticalAlign || (b ? \"middle\": c ? \"bottom\": \"top\"),\n"
                "y: k(d.y, b ? 4 : c ? 14 : -6),\n"
                "x: k(d.x, b ? c ? -6 : 6 : 0)\n"
            "};\n"
            "this.textAlign = d.textAlign || (b ? c ? \"right\": \"left\": \"center\")\n"
        "}\n"
        "var A = a.Axis,\n"
        "H = a.Chart,\n"
        "G = a.correctFloat,\n"
        "r = a.defined,\n"
        "f = a.destroyObjectProperties,\n"
        "l = a.each,\n"
        "q = a.format,\n"
        "k = a.pick;\n"
        "a = a.Series;\n"
        "B.prototype = {\n"
            "destroy: function() {\n"
                "f(this, this.axis)\n"
            "},\n"
            "render: function(a) {\n"
                "var d = this.options,\n"
                "c = d.format,\n"
                "c = c ? q(c, this) : d.formatter.call(this);\n"
                "this.label ? this.label.attr({\n"
                    "text: c,\n"
                    "visibility: \"hidden\"\n"
                "}) : this.label = this.axis.chart.renderer.text(c, null, null, d.useHTML).css(d.style).attr({\n"
                    "align: this.textAlign,\n"
                    "rotation: d.rotation,\n"
                    "visibility: \"hidden\"\n"
                "}).add(a)\n"
            "},\n"
            "setOffset: function(a, d) {\n"
                "var c = this.axis,\n"
                "f = c.chart,\n"
                "k = f.inverted,\n"
                "b = c.reversed,\n"
                "b = this.isNegative && !b || !this.isNegative && b,\n"
                "p = c.translate(c.usePercentage ? 100 : this.total, 0, 0, 0, 1),\n"
                "c = c.translate(0),\n"
                "c = Math.abs(p - c);\n"
                "a = f.xAxis[0].translate(this.x) + a;\n"
                "var h = f.plotHeight,\n"
                "k = {\n"
                    "x: k ? b ? p: p - c: a,\n"
                    "y: k ? h - a - d: b ? h - p - c: h - p,\n"
                    "width: k ? c: d,\n"
                    "height: k ? d: c\n"
                "};\n"
                "if (d = this.label) d.align(this.alignOptions, null, k),\n"
                "k = d.alignAttr,\n"
                "d[!1 === this.options.crop || f.isInsidePlot(k.x, k.y) ? \"show\": \"hide\"](!0)\n"
            "}\n"
        "};\n"
        "H.prototype.getStacks = function() {\n"
            "var a = this;\n"
            "l(a.yAxis,\n"
            "function(a) {\n"
                "a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks)\n"
            "});\n"
            "l(a.series,\n"
            "function(d) { ! d.options.stacking || !0 !== d.visible && !1 !== a.options.chart.ignoreHiddenSeries || (d.stackKey = d.type + k(d.options.stack, \"\"))\n"
            "})\n"
        "};\n"
        "A.prototype.buildStacks = function() {\n"
            "var a = this.series,\n"
            "d, c = k(this.options.reversedStacks, !0),\n"
            "f = a.length,\n"
            "l;\n"
            "if (!this.isXAxis) {\n"
                "this.usePercentage = !1;\n"
                "for (l = f; l--;) a[c ? l: f - l - 1].setStackedPoints();\n"
                "for (l = f; l--;) d = a[c ? l: f - l - 1],\n"
                "d.setStackCliffs && d.setStackCliffs();\n"
                "if (this.usePercentage) for (l = 0; l < f; l++) a[l].setPercentStacks()\n"
            "}\n"
        "};\n"
        "A.prototype.renderStackTotals = function() {\n"
            "var a = this.chart,\n"
            "d = a.renderer,\n"
            "c = this.stacks,\n"
            "f, k, b = this.stackTotalGroup;\n"
            "b || (this.stackTotalGroup = b = d.g(\"stack-labels\").attr({\n"
                "visibility: \"visible\",\n"
                "zIndex: 6\n"
            "}).add());\n"
            "b.translate(a.plotLeft, a.plotTop);\n"
            "for (f in c) for (k in a = c[f], a) a[k].render(b)\n"
        "};\n"
        "A.prototype.resetStacks = function() {\n"
            "var a = this.stacks,\n"
            "d, c;\n"
            "if (!this.isXAxis) for (d in a) for (c in a[d]) a[d][c].touched < this.stacksTouched ? (a[d][c].destroy(), delete a[d][c]) : (a[d][c].total = null, a[d][c].cum = null)\n"
        "};\n"
        "A.prototype.cleanStacks = function() {\n"
            "var a, d, c;\n"
            "if (!this.isXAxis) for (d in this.oldStacks && (a = this.stacks = this.oldStacks), a) for (c in a[d]) a[d][c].cum = a[d][c].total\n"
        "};\n"
        "a.prototype.setStackedPoints = function() {\n"
            "if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n"
                "var a = this.processedXData,\n"
                "d = this.processedYData,\n"
                "c = [],\n"
                "f = d.length,\n"
                "l = this.options,\n"
                "b = l.threshold,\n"
                "p = l.startFromThreshold ? b: 0,\n"
                "h = l.stack,\n"
                "l = l.stacking,\n"
                "t = this.stackKey,\n"
                "q = \"-\" + t,\n"
                "w = this.negStacks,\n"
                "e = this.yAxis,\n"
                "x = e.stacks,\n"
                "C = e.oldStacks,\n"
                "E,\n"
                "m,\n"
                "y,\n"
                "A,\n"
                "K,\n"
                "J,\n"
                "g;\n"
                "e.stacksTouched += 1;\n"
                "for (K = 0; K < f; K++) J = a[K],\n"
                "g = d[K],\n"
                "E = this.getStackIndicator(E, J, this.index),\n"
                "A = E.key,\n"
                "y = (m = w && g < (p ? 0 : b)) ? q: t,\n"
                "x[y] || (x[y] = {}),\n"
                "x[y][J] || (C[y] && C[y][J] ? (x[y][J] = C[y][J], x[y][J].total = null) : x[y][J] = new B(e, e.options.stackLabels, m, J, h)),\n"
                "y = x[y][J],\n"
                "null !== g && (y.points[A] = y.points[this.index] = [k(y.cum, p)], r(y.cum) || (y.base = A), y.touched = e.stacksTouched, 0 < E.index && !1 === this.singleStacks && (y.points[A][0] = y.points[this.index + \",\" + J + \",0\"][0])),\n"
                "\"percent\" === l ? (m = m ? t: q, w && x[m] && x[m][J] ? (m = x[m][J], y.total = m.total = Math.max(m.total, y.total) + Math.abs(g) || 0) : y.total = G(y.total + (Math.abs(g) || 0))) : y.total = G(y.total + (g || 0)),\n"
                "y.cum = k(y.cum, p) + (g || 0),\n"
                "null !== g && (y.points[A].push(y.cum), c[K] = y.cum);\n"
                "\"percent\" === l && (e.usePercentage = !0);\n"
                "this.stackedYData = c;\n"
                "e.oldStacks = {}\n"
            "}\n"
        "};\n"
        "a.prototype.setPercentStacks = function() {\n"
            "var a = this,\n"
            "d = a.stackKey,\n"
            "c = a.yAxis.stacks,\n"
            "f = a.processedXData,\n"
            "k;\n"
            "l([d, \"-\" + d],\n"
            "function(b) {\n"
                "for (var d = f.length,\n"
                "h, n; d--;) if (h = f[d], k = a.getStackIndicator(k, h, a.index, b), h = (n = c[b] && c[b][h]) && n.points[k.key]) n = n.total ? 100 / n.total: 0,\n"
                "h[0] = G(h[0] * n),\n"
                "h[1] = G(h[1] * n),\n"
                "a.stackedYData[d] = h[1]\n"
            "})\n"
        "};\n"
        "a.prototype.getStackIndicator = function(a, d, c, f) { ! r(a) || a.x !== d || f && a.key !== f ? a = {\n"
                "x: d,\n"
                "index: 0,\n"
                "key: f\n"
            "}: a.index++;\n"
            "a.key = [c, d, a.index].join();\n"
            "return a\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.animate,\n"
        "H = a.Axis,\n"
        "G = a.createElement,\n"
        "r = a.css,\n"
        "f = a.defined,\n"
        "l = a.each,\n"
        "q = a.erase,\n"
        "k = a.extend,\n"
        "u = a.fireEvent,\n"
        "d = a.inArray,\n"
        "c = a.isNumber,\n"
        "n = a.isObject,\n"
        "z = a.merge,\n"
        "b = a.pick,\n"
        "p = a.Point,\n"
        "h = a.Series,\n"
        "t = a.seriesTypes,\n"
        "D = a.setAnimation,\n"
        "w = a.splat;\n"
        "k(a.Chart.prototype, {\n"
            "addSeries: function(a, c, d) {\n"
                "var e, h = this;\n"
                "a && (c = b(c, !0), u(h, \"addSeries\", {\n"
                    "options: a\n"
                "},\n"
                "function() {\n"
                    "e = h.initSeries(a);\n"
                    "h.isDirtyLegend = !0;\n"
                    "h.linkSeries();\n"
                    "c && h.redraw(d)\n"
                "}));\n"
                "return e\n"
            "},\n"
            "addAxis: function(a, c, d, h) {\n"
                "var e = c ? \"xAxis\": \"yAxis\",\n"
                "f = this.options;\n"
                "a = z(a, {\n"
                    "index: this[e].length,\n"
                    "isX: c\n"
                "});\n"
                "new H(this, a);\n"
                "f[e] = w(f[e] || {});\n"
                "f[e].push(a);\n"
                "b(d, !0) && this.redraw(h)\n"
            "},\n"
            "showLoading: function(a) {\n"
                "var b = this,\n"
                "c = b.options,\n"
                "e = b.loadingDiv,\n"
                "d = c.loading,\n"
                "h = function() {\n"
                    "e && r(e, {\n"
                        "left: b.plotLeft + \"px\",\n"
                        "top: b.plotTop + \"px\",\n"
                        "width: b.plotWidth + \"px\",\n"
                        "height: b.plotHeight + \"px\"\n"
                    "})\n"
                "};\n"
                "e || (b.loadingDiv = e = G(\"div\", {\n"
                    "className: \"highcharts-loading highcharts-loading-hidden\"\n"
                "},\n"
                "null, b.container), b.loadingSpan = G(\"span\", {\n"
                    "className: \"highcharts-loading-inner\"\n"
                "},\n"
                "null, e), B(b, \"redraw\", h));\n"
                "e.className = \"highcharts-loading\";\n"
                "b.loadingSpan.innerHTML = a || c.lang.loading;\n"
                "r(e, k(d.style, {\n"
                    "zIndex: 10\n"
                "}));\n"
                "r(b.loadingSpan, d.labelStyle);\n"
                "b.loadingShown || (r(e, {\n"
                    "opacity: 0,\n"
                    "display: \"\"\n"
                "}), A(e, {\n"
                    "opacity: d.style.opacity || .5\n"
                "},\n"
                "{\n"
                    "duration: d.showDuration || 0\n"
                "}));\n"
                "b.loadingShown = !0;\n"
                "h()\n"
            "},\n"
            "hideLoading: function() {\n"
                "var a = this.options,\n"
                "b = this.loadingDiv;\n"
                "b && (b.className = \"highcharts-loading highcharts-loading-hidden\", A(b, {\n"
                    "opacity: 0\n"
                "},\n"
                "{\n"
                    "duration: a.loading.hideDuration || 100,\n"
                    "complete: function() {\n"
                        "r(b, {\n"
                            "display: \"none\"\n"
                        "})\n"
                    "}\n"
                "}));\n"
                "this.loadingShown = !1\n"
            "},\n"
            "propsRequireDirtyBox: \"backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n"
            "propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions\".split(\" \"),\n"
            "update: function(a, h) {\n"
                "var e, k = {\n"
                    "credits: \"addCredits\",\n"
                    "title: \"setTitle\",\n"
                    "subtitle: \"setSubtitle\"\n"
                "},\n"
                "m = a.chart,\n"
                "p,\n"
                "n;\n"
                "if (m) {\n"
                    "z(!0, this.options.chart, m);\n"
                    "\"className\" in m && this.setClassName(m.className);\n"
                    "if (\"inverted\" in m || \"polar\" in m) this.propFromSeries(),\n"
                    "p = !0;\n"
                    "\"alignTicks\" in m && (p = !0);\n"
                    "for (e in m) m.hasOwnProperty(e) && ( - 1 !== d(\"chart.\" + e, this.propsRequireUpdateSeries) && (n = !0), -1 !== d(e, this.propsRequireDirtyBox) && (this.isDirtyBox = !0));\n"
                    "\"style\" in m && this.renderer.setStyle(m.style)\n"
                "}\n"
                "for (e in a) {\n"
                    "if (this[e] && \"function\" === typeof this[e].update) this[e].update(a[e], !1);\n"
                    "else if (\"function\" === typeof this[k[e]]) this[k[e]](a[e]);\n"
                    "\"chart\" !== e && -1 !== d(e, this.propsRequireUpdateSeries) && (n = !0)\n"
                "}\n"
                "a.colors && (this.options.colors = a.colors);\n"
                "a.plotOptions && z(!0, this.options.plotOptions, a.plotOptions);\n"
                "l([\"xAxis\", \"yAxis\", \"series\", \"colorAxis\", \"pane\"],\n"
                "function(b) {\n"
                    "a[b] && l(w(a[b]),\n"
                    "function(a, c) { (c = f(a.id) && this.get(a.id) || this[b][c]) && c.coll === b && c.update(a, !1)\n"
                    "},\n"
                    "this)\n"
                "},\n"
                "this);\n"
                "p && l(this.axes,\n"
                "function(a) {\n"
                    "a.update({},\n"
                    "!1)\n"
                "});\n"
                "n && l(this.series,\n"
                "function(a) {\n"
                    "a.update({},\n"
                    "!1)\n"
                "});\n"
                "a.loading && z(!0, this.options.loading, a.loading);\n"
                "e = m && m.width;\n"
                "m = m && m.height;\n"
                "c(e) && e !== this.chartWidth || c(m) && m !== this.chartHeight ? this.setSize(e, m) : b(h, !0) && this.redraw()\n"
            "},\n"
            "setSubtitle: function(a) {\n"
                "this.setTitle(void 0, a)\n"
            "}\n"
        "});\n"
        "k(p.prototype, {\n"
            "update: function(a, c, d, h) {\n"
                "function e() {\n"
                    "f.applyOptions(a);\n"
                    "null === f.y && p && (f.graphic = p.destroy());\n"
                    "n(a, !0) && (p && p.element && a && a.marker && a.marker.symbol && (f.graphic = p.destroy()), a && a.dataLabels && f.dataLabel && (f.dataLabel = f.dataLabel.destroy()));\n"
                    "l = f.index;\n"
                    "k.updateParallelArrays(f, l);\n"
                    "t.data[l] = n(t.data[l], !0) || n(a, !0) ? f.options: a;\n"
                    "k.isDirty = k.isDirtyData = !0; ! k.fixedBox && k.hasCartesianSeries && (g.isDirtyBox = !0);\n"
                    "\"point\" === t.legendType && (g.isDirtyLegend = !0);\n"
                    "c && g.redraw(d)\n"
                "}\n"
                "var f = this,\n"
                "k = f.series,\n"
                "p = f.graphic,\n"
                "l, g = k.chart,\n"
                "t = k.options;\n"
                "c = b(c, !0); ! 1 === h ? e() : f.firePointEvent(\"update\", {\n"
                    "options: a\n"
                "},\n"
                "e)\n"
            "},\n"
            "remove: function(a, b) {\n"
                "this.series.removePoint(d(this, this.series.data), a, b)\n"
            "}\n"
        "});\n"
        "k(h.prototype, {\n"
            "addPoint: function(a, c, d, h) {\n"
                "var e = this.options,\n"
                "f = this.data,\n"
                "k = this.chart,\n"
                "p = this.xAxis,\n"
                "p = p && p.hasNames && p.names,\n"
                "n = e.data,\n"
                "g, l, t = this.xData,\n"
                "q, w;\n"
                "c = b(c, !0);\n"
                "g = {\n"
                    "series: this\n"
                "};\n"
                "this.pointClass.prototype.applyOptions.apply(g, [a]);\n"
                "w = g.x;\n"
                "q = t.length;\n"
                "if (this.requireSorting && w < t[q - 1]) for (l = !0; q && t[q - 1] > w;) q--;\n"
                "this.updateParallelArrays(g, \"splice\", q, 0, 0);\n"
                "this.updateParallelArrays(g, q);\n"
                "p && g.name && (p[w] = g.name);\n"
                "n.splice(q, 0, a);\n"
                "l && (this.data.splice(q, 0, null), this.processData());\n"
                "\"point\" === e.legendType && this.generatePoints();\n"
                "d && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(g, \"shift\"), n.shift()));\n"
                "this.isDirtyData = this.isDirty = !0;\n"
                "c && k.redraw(h)\n"
            "},\n"
            "removePoint: function(a, c, d) {\n"
                "var e = this,\n"
                "h = e.data,\n"
                "f = h[a],\n"
                "k = e.points,\n"
                "p = e.chart,\n"
                "n = function() {\n"
                    "k && k.length === h.length && k.splice(a, 1);\n"
                    "h.splice(a, 1);\n"
                    "e.options.data.splice(a, 1);\n"
                    "e.updateParallelArrays(f || {\n"
                        "series: e\n"
                    "},\n"
                    "\"splice\", a, 1);\n"
                    "f && f.destroy();\n"
                    "e.isDirty = !0;\n"
                    "e.isDirtyData = !0;\n"
                    "c && p.redraw()\n"
                "};\n"
                "D(d, p);\n"
                "c = b(c, !0);\n"
                "f ? f.firePointEvent(\"remove\", null, n) : n()\n"
            "},\n"
            "remove: function(a, c, d) {\n"
                "function e() {\n"
                    "h.destroy();\n"
                    "f.isDirtyLegend = f.isDirtyBox = !0;\n"
                    "f.linkSeries();\n"
                    "b(a, !0) && f.redraw(c)\n"
                "}\n"
                "var h = this,\n"
                "f = h.chart; ! 1 !== d ? u(h, \"remove\", null, e) : e()\n"
            "},\n"
            "update: function(a, c) {\n"
                "var e = this,\n"
                "d = this.chart,\n"
                "h = this.userOptions,\n"
                "f = this.oldType || this.type,\n"
                "p = a.type || h.type || d.options.chart.type,\n"
                "n = t[f].prototype,\n"
                "q = [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n"
                "g;\n"
                "if (p && p !== f || void 0 !== a.zIndex) q.length = 0;\n"
                "l(q,\n"
                "function(a) {\n"
                    "q[a] = e[a];\n"
                    "delete e[a]\n"
                "});\n"
                "a = z(h, {\n"
                    "animation: !1,\n"
                    "index: this.index,\n"
                    "pointStart: this.xData[0]\n"
                "},\n"
                "{\n"
                    "data: this.options.data\n"
                "},\n"
                "a);\n"
                "this.remove(!1, null, !1);\n"
                "for (g in n) this[g] = void 0;\n"
                "k(this, t[p || f].prototype);\n"
                "l(q,\n"
                "function(a) {\n"
                    "e[a] = q[a]\n"
                "});\n"
                "this.init(d, a);\n"
                "this.oldType = f;\n"
                "d.linkSeries();\n"
                "b(c, !0) && d.redraw(!1)\n"
            "}\n"
        "});\n"
        "k(H.prototype, {\n"
            "update: function(a, c) {\n"
                "var e = this.chart;\n"
                "a = e.options[this.coll][this.options.index] = z(this.userOptions, a);\n"
                "this.destroy(!0);\n"
                "this.init(e, k(a, {\n"
                    "events: void 0\n"
                "}));\n"
                "e.isDirtyBox = !0;\n"
                "b(c, !0) && e.redraw()\n"
            "},\n"
            "remove: function(a) {\n"
                "for (var c = this.chart,\n"
                "e = this.coll,\n"
                "d = this.series,\n"
                "h = d.length; h--;) d[h] && d[h].remove(!1);\n"
                "q(c.axes, this);\n"
                "q(c[e], this);\n"
                "c.options[e].splice(this.options.index, 1);\n"
                "l(c[e],\n"
                "function(a, b) {\n"
                    "a.options.index = b\n"
                "});\n"
                "this.destroy();\n"
                "c.isDirtyBox = !0;\n"
                "b(a, !0) && c.redraw()\n"
            "},\n"
            "setTitle: function(a, b) {\n"
                "this.update({\n"
                    "title: a\n"
                "},\n"
                "b)\n"
            "},\n"
            "setCategories: function(a, b) {\n"
                "this.update({\n"
                    "categories: a\n"
                "},\n"
                "b)\n"
            "}\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.color,\n"
        "A = a.each,\n"
        "H = a.map,\n"
        "G = a.pick,\n"
        "r = a.Series,\n"
        "f = a.seriesType;\n"
        "f(\"area\", \"line\", {\n"
            "softThreshold: !1,\n"
            "threshold: 0\n"
        "},\n"
        "{\n"
            "singleStacks: !1,\n"
            "getStackPoints: function() {\n"
                "var a = [],\n"
                "f = [],\n"
                "k = this.xAxis,\n"
                "r = this.yAxis,\n"
                "d = r.stacks[this.stackKey],\n"
                "c = {},\n"
                "n = this.points,\n"
                "z = this.index,\n"
                "b = r.series,\n"
                "p = b.length,\n"
                "h,\n"
                "t = G(r.options.reversedStacks, !0) ? 1 : -1,\n"
                "D,\n"
                "w;\n"
                "if (this.options.stacking) {\n"
                    "for (D = 0; D < n.length; D++) c[n[D].x] = n[D];\n"
                    "for (w in d) null !== d[w].total && f.push(w);\n"
                    "f.sort(function(a, b) {\n"
                        "return a - b\n"
                    "});\n"
                    "h = H(b,\n"
                    "function() {\n"
                        "return this.visible\n"
                    "});\n"
                    "A(f,\n"
                    "function(b, n) {\n"
                        "var e = 0,\n"
                        "l, m;\n"
                        "if (c[b] && !c[b].isNull) a.push(c[b]),\n"
                        "A([ - 1, 1],\n"
                        "function(a) {\n"
                            "var e = 1 === a ? \"rightNull\": \"leftNull\",\n"
                            "k = 0,\n"
                            "q = d[f[n + a]];\n"
                            "if (q) for (D = z; 0 <= D && D < p;) l = q.points[D],\n"
                            "l || (D === z ? c[b][e] = !0 : h[D] && (m = d[b].points[D]) && (k -= m[1] - m[0])),\n"
                            "D += t;\n"
                            "c[b][1 === a ? \"rightCliff\": \"leftCliff\"] = k\n"
                        "});\n"
                        "else {\n"
                            "for (D = z; 0 <= D && D < p;) {\n"
                                "if (l = d[b].points[D]) {\n"
                                    "e = l[1];\n"
                                    "break\n"
                                "}\n"
                                "D += t\n"
                            "}\n"
                            "e = r.translate(e, 0, 1, 0, 1);\n"
                            "a.push({\n"
                                "isNull: !0,\n"
                                "plotX: k.translate(b, 0, 0, 0, 1),\n"
                                "x: b,\n"
                                "plotY: e,\n"
                                "yBottom: e\n"
                            "})\n"
                        "}\n"
                    "})\n"
                "}\n"
                "return a\n"
            "},\n"
            "getGraphPath: function(a) {\n"
                "var f = r.prototype.getGraphPath,\n"
                "k = this.options,\n"
                "l = k.stacking,\n"
                "d = this.yAxis,\n"
                "c, n, z = [],\n"
                "b = [],\n"
                "p = this.index,\n"
                "h,\n"
                "t = d.stacks[this.stackKey],\n"
                "D = k.threshold,\n"
                "w = d.getThreshold(k.threshold),\n"
                "e,\n"
                "k = k.connectNulls || \"percent\" === l,\n"
                "x = function(c, e, f) {\n"
                    "var k = a[c];\n"
                    "c = l && t[k.x].points[p];\n"
                    "var m = k[f + \"Null\"] || 0;\n"
                    "f = k[f + \"Cliff\"] || 0;\n"
                    "var n, q, k = !0;\n"
                    "f || m ? (n = (m ? c[0] : c[1]) + f, q = c[0] + f, k = !!m) : !l && a[e] && a[e].isNull && (n = q = D);\n"
                    "void 0 !== n && (b.push({\n"
                        "plotX: h,\n"
                        "plotY: null === n ? w: d.getThreshold(n),\n"
                        "isNull: k,\n"
                        "isCliff: !0\n"
                    "}), z.push({\n"
                        "plotX: h,\n"
                        "plotY: null === q ? w: d.getThreshold(q),\n"
                        "doCurve: !1\n"
                    "}))\n"
                "};\n"
                "a = a || this.points;\n"
                "l && (a = this.getStackPoints());\n"
                "for (c = 0; c < a.length; c++) if (n = a[c].isNull, h = G(a[c].rectPlotX, a[c].plotX), e = G(a[c].yBottom, w), !n || k) k || x(c, c - 1, \"left\"),\n"
                "n && !l && k || (b.push(a[c]), z.push({\n"
                    "x: c,\n"
                    "plotX: h,\n"
                    "plotY: e\n"
                "})),\n"
                "k || x(c, c + 1, \"right\");\n"
                "c = f.call(this, b, !0, !0);\n"
                "z.reversed = !0;\n"
                "n = f.call(this, z, !0, !0);\n"
                "n.length && (n[0] = \"L\");\n"
                "n = c.concat(n);\n"
                "f = f.call(this, b, !1, k);\n"
                "n.xMap = c.xMap;\n"
                "this.areaPath = n;\n"
                "return f\n"
            "},\n"
            "drawGraph: function() {\n"
                "this.areaPath = [];\n"
                "r.prototype.drawGraph.apply(this);\n"
                "var a = this,\n"
                "f = this.areaPath,\n"
                "k = this.options,\n"
                "u = [[\"area\", \"highcharts-area\", this.color, k.fillColor]];\n"
                "A(this.zones,\n"
                "function(d, c) {\n"
                    "u.push([\"zone-area-\" + c, \"highcharts-area highcharts-zone-area-\" + c + \" \" + d.className, d.color || a.color, d.fillColor || k.fillColor])\n"
                "});\n"
                "A(u,\n"
                "function(d) {\n"
                    "var c = d[0],\n"
                    "n = a[c];\n"
                    "n ? (n.endX = f.xMap, n.animate({\n"
                        "d: f\n"
                    "})) : (n = a[c] = a.chart.renderer.path(f).addClass(d[1]).attr({\n"
                        "fill: G(d[3], B(d[2]).setOpacity(G(k.fillOpacity, .75)).get()),\n"
                        "zIndex: 0\n"
                    "}).add(a.group), n.isArea = !0);\n"
                    "n.startX = f.xMap;\n"
                    "n.shiftUnit = k.step ? 2 : 1\n"
                "})\n"
            "},\n"
            "drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.pick;\n"
        "a = a.seriesType;\n"
        "a(\"spline\", \"line\", {},\n"
        "{\n"
            "getPointSpline: function(a, H, G) {\n"
                "var r = H.plotX,\n"
                "f = H.plotY,\n"
                "l = a[G - 1];\n"
                "G = a[G + 1];\n"
                "var q, k, u, d;\n"
                "if (l && !l.isNull && !1 !== l.doCurve && !H.isCliff && G && !G.isNull && !1 !== G.doCurve && !H.isCliff) {\n"
                    "a = l.plotY;\n"
                    "u = G.plotX;\n"
                    "G = G.plotY;\n"
                    "var c = 0;\n"
                    "q = (1.5 * r + l.plotX) / 2.5;\n"
                    "k = (1.5 * f + a) / 2.5;\n"
                    "u = (1.5 * r + u) / 2.5;\n"
                    "d = (1.5 * f + G) / 2.5;\n"
                    "u !== q && (c = (d - k) * (u - r) / (u - q) + f - d);\n"
                    "k += c;\n"
                    "d += c;\n"
                    "k > a && k > f ? (k = Math.max(a, f), d = 2 * f - k) : k < a && k < f && (k = Math.min(a, f), d = 2 * f - k);\n"
                    "d > G && d > f ? (d = Math.max(G, f), k = 2 * f - d) : d < G && d < f && (d = Math.min(G, f), k = 2 * f - d);\n"
                    "H.rightContX = u;\n"
                    "H.rightContY = d\n"
                "}\n"
                "H = [\"C\", B(l.rightContX, l.plotX), B(l.rightContY, l.plotY), B(q, r), B(k, f), r, f];\n"
                "l.rightContX = l.rightContY = null;\n"
                "return H\n"
            "}\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.seriesTypes.area.prototype,\n"
        "A = a.seriesType;\n"
        "A(\"areaspline\", \"spline\", a.defaultPlotOptions.area, {\n"
            "getStackPoints: B.getStackPoints,\n"
            "getGraphPath: B.getGraphPath,\n"
            "setStackCliffs: B.setStackCliffs,\n"
            "drawGraph: B.drawGraph,\n"
            "drawLegendSymbol: a.LegendSymbolMixin.drawRectangle\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.animObject,\n"
        "A = a.color,\n"
        "H = a.each,\n"
        "G = a.extend,\n"
        "r = a.isNumber,\n"
        "f = a.merge,\n"
        "l = a.pick,\n"
        "q = a.Series,\n"
        "k = a.seriesType,\n"
        "u = a.svg;\n"
        "k(\"column\", \"line\", {\n"
            "borderRadius: 0,\n"
            "crisp: !0,\n"
            "groupPadding: .2,\n"
            "marker: null,\n"
            "pointPadding: .1,\n"
            "minPointLength: 0,\n"
            "cropThreshold: 50,\n"
            "pointRange: null,\n"
            "states: {\n"
                "hover: {\n"
                    "halo: !1,\n"
                    "brightness: .1,\n"
                    "shadow: !1\n"
                "},\n"
                "select: {\n"
                    "color: \"#cccccc\",\n"
                    "borderColor: \"#000000\",\n"
                    "shadow: !1\n"
                "}\n"
            "},\n"
            "dataLabels: {\n"
                "align: null,\n"
                "verticalAlign: null,\n"
                "y: null\n"
            "},\n"
            "softThreshold: !1,\n"
            "startFromThreshold: !0,\n"
            "stickyTracking: !1,\n"
            "tooltip: {\n"
                "distance: 6\n"
            "},\n"
            "threshold: 0,\n"
            "borderColor: \"#ffffff\"\n"
        "},\n"
        "{\n"
            "cropShoulder: 0,\n"
            "directTouch: !0,\n"
            "trackerGroups: [\"group\", \"dataLabelsGroup\"],\n"
            "negStacks: !0,\n"
            "init: function() {\n"
                "q.prototype.init.apply(this, arguments);\n"
                "var a = this,\n"
                "c = a.chart;\n"
                "c.hasRendered && H(c.series,\n"
                "function(c) {\n"
                    "c.type === a.type && (c.isDirty = !0)\n"
                "})\n"
            "},\n"
            "getColumnMetrics: function() {\n"
                "var a = this,\n"
                "c = a.options,\n"
                "f = a.xAxis,\n"
                "k = a.yAxis,\n"
                "b = f.reversed,\n"
                "p, h = {},\n"
                "t = 0; ! 1 === c.grouping ? t = 1 : H(a.chart.series,\n"
                "function(b) {\n"
                    "var c = b.options,\n"
                    "e = b.yAxis,\n"
                    "d;\n"
                    "b.type === a.type && b.visible && k.len === e.len && k.pos === e.pos && (c.stacking ? (p = b.stackKey, void 0 === h[p] && (h[p] = t++), d = h[p]) : !1 !== c.grouping && (d = t++), b.columnIndex = d)\n"
                "});\n"
                "var q = Math.min(Math.abs(f.transA) * (f.ordinalSlope || c.pointRange || f.closestPointRange || f.tickInterval || 1), f.len),\n"
                "w = q * c.groupPadding,\n"
                "e = (q - 2 * w) / (t || 1),\n"
                "c = Math.min(c.maxPointWidth || f.len, l(c.pointWidth, e * (1 - 2 * c.pointPadding)));\n"
                "a.columnMetrics = {\n"
                    "width: c,\n"
                    "offset: (e - c) / 2 + (w + ((a.columnIndex || 0) + (b ? 1 : 0)) * e - q / 2) * (b ? -1 : 1)\n"
                "};\n"
                "return a.columnMetrics\n"
            "},\n"
            "crispCol: function(a, c, f, k) {\n"
                "var b = this.chart,\n"
                "d = this.borderWidth,\n"
                "h = -(d % 2 ? .5 : 0),\n"
                "d = d % 2 ? .5 : 1;\n"
                "b.inverted && b.renderer.isVML && (d += 1);\n"
                "this.options.crisp && (f = Math.round(a + f) + h, a = Math.round(a) + h, f -= a);\n"
                "k = Math.round(c + k) + d;\n"
                "h = .5 >= Math.abs(c) && .5 < k;\n"
                "c = Math.round(c) + d;\n"
                "k -= c;\n"
                "h && k && (--c, k += 1);\n"
                "return {\n"
                    "x: a,\n"
                    "y: c,\n"
                    "width: f,\n"
                    "height: k\n"
                "}\n"
            "},\n"
            "translate: function() {\n"
                "var a = this,\n"
                "c = a.chart,\n"
                "f = a.options,\n"
                "k = a.dense = 2 > a.closestPointRange * a.xAxis.transA,\n"
                "k = a.borderWidth = l(f.borderWidth, k ? 0 : 1),\n"
                "b = a.yAxis,\n"
                "p = a.translatedThreshold = b.getThreshold(f.threshold),\n"
                "h = l(f.minPointLength, 5),\n"
                "t = a.getColumnMetrics(),\n"
                "r = t.width,\n"
                "w = a.barW = Math.max(r, 1 + 2 * k),\n"
                "e = a.pointXOffset = t.offset;\n"
                "c.inverted && (p -= .5);\n"
                "f.pointPadding && (w = Math.ceil(w));\n"
                "q.prototype.translate.apply(a);\n"
                "H(a.points,\n"
                "function(d) {\n"
                    "var f = l(d.yBottom, p),\n"
                    "k = 999 + Math.abs(f),\n"
                    "k = Math.min(Math.max( - k, d.plotY), b.len + k),\n"
                    "m = d.plotX + e,\n"
                    "n = w,\n"
                    "t = Math.min(k, f),\n"
                    "q,\n"
                    "u = Math.max(k, f) - t;\n"
                    "Math.abs(u) < h && h && (u = h, q = !b.reversed && !d.negative || b.reversed && d.negative, t = Math.abs(t - p) > h ? f - h: p - (q ? h: 0));\n"
                    "d.barX = m;\n"
                    "d.pointWidth = r;\n"
                    "d.tooltipPos = c.inverted ? [b.len + b.pos - c.plotLeft - k, a.xAxis.len - m - n / 2, u] : [m + n / 2, k + b.pos - c.plotTop, u];\n"
                    "d.shapeType = \"rect\";\n"
                    "d.shapeArgs = a.crispCol.apply(a, d.isNull ? [d.plotX, b.len / 2, 0, 0] : [m, t, n, u])\n"
                "})\n"
            "},\n"
            "getSymbol: a.noop,\n"
            "drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n"
            "drawGraph: function() {\n"
                "this.group[this.dense ? \"addClass\": \"removeClass\"](\"highcharts-dense-data\")\n"
            "},\n"
            "pointAttribs: function(a, c) {\n"
                "var d = this.options,\n"
                "k, b = this.pointAttrToOptions || {};\n"
                "k = b.stroke || \"borderColor\";\n"
                "var p = b[\"stroke-width\"] || \"borderWidth\",\n"
                "h = a && a.color || this.color,\n"
                "l = a[k] || d[k] || this.color || h,\n"
                "q = a[p] || d[p] || this[p] || 0,\n"
                "b = d.dashStyle;\n"
                "a && this.zones.length && (h = (h = a.getZone()) && h.color || a.options.color || this.color);\n"
                "c && (a = f(d.states[c], a.options.states && a.options.states[c] || {}), c = a.brightness, h = a.color || void 0 !== c && A(h).brighten(a.brightness).get() || h, l = a[k] || l, q = a[p] || q, b = a.dashStyle || b);\n"
                "k = {\n"
                    "fill: h,\n"
                    "stroke: l,\n"
                    "\"stroke-width\": q\n"
                "};\n"
                "d.borderRadius && (k.r = d.borderRadius);\n"
                "b && (k.dashstyle = b);\n"
                "return k\n"
            "},\n"
            "drawPoints: function() {\n"
                "var a = this,\n"
                "c = this.chart,\n"
                "k = a.options,\n"
                "l = c.renderer,\n"
                "b = k.animationLimit || 250,\n"
                "p;\n"
                "H(a.points,\n"
                "function(d) {\n"
                    "var h = d.graphic;\n"
                    "if (r(d.plotY) && null !== d.y) {\n"
                        "p = d.shapeArgs;\n"
                        "if (h) h[c.pointCount < b ? \"animate\": \"attr\"](f(p));\n"
                        "else d.graphic = h = l[d.shapeType](p).add(d.group || a.group);\n"
                        "h.attr(a.pointAttribs(d, d.selected && \"select\")).shadow(k.shadow, null, k.stacking && !k.borderRadius);\n"
                        "h.addClass(d.getClassName(), !0)\n"
                    "} else h && (d.graphic = h.destroy())\n"
                "})\n"
            "},\n"
            "animate: function(a) {\n"
                "var c = this,\n"
                "d = this.yAxis,\n"
                "f = c.options,\n"
                "b = this.chart.inverted,\n"
                "k = {};\n"
                "u && (a ? (k.scaleY = .001, a = Math.min(d.pos + d.len, Math.max(d.pos, d.toPixels(f.threshold))), b ? k.translateX = a - d.len: k.translateY = a, c.group.attr(k)) : (k[b ? \"translateX\": \"translateY\"] = d.pos, c.group.animate(k, G(B(c.options.animation), {\n"
                    "step: function(a, b) {\n"
                        "c.group.attr({\n"
                            "scaleY: Math.max(.001, b.pos)\n"
                        "})\n"
                    "}\n"
                "})), c.animate = null))\n"
            "},\n"
            "remove: function() {\n"
                "var a = this,\n"
                "c = a.chart;\n"
                "c.hasRendered && H(c.series,\n"
                "function(c) {\n"
                    "c.type === a.type && (c.isDirty = !0)\n"
                "});\n"
                "q.prototype.remove.apply(a, arguments)\n"
            "}\n"
        "})\n"
    "})(L); (function(a) {\n"
        "a = a.seriesType;\n"
        "a(\"bar\", \"column\", null, {\n"
            "inverted: !0\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.Series;\n"
        "a = a.seriesType;\n"
        "a(\"scatter\", \"line\", {\n"
            "lineWidth: 0,\n"
            "findNearestPointBy: \"xy\",\n"
            "marker: {\n"
                "enabled: !0\n"
            "},\n"
            "tooltip: {\n"
                "headerFormat: '\\x3cspan style\\x3d\"color:{point.color}\"\\x3e\\u25cf\\x3c/span\\x3e \\x3cspan style\\x3d\"font-size: 0.85em\"\\x3e {series.name}\\x3c/span\\x3e\\x3cbr/\\x3e',\n"
                "pointFormat: \"x: \\x3cb\\x3e{point.x}\\x3c/b\\x3e\\x3cbr/\\x3ey: \\x3cb\\x3e{point.y}\\x3c/b\\x3e\\x3cbr/\\x3e\"\n"
            "}\n"
        "},\n"
        "{\n"
            "sorted: !1,\n"
            "requireSorting: !1,\n"
            "noSharedTooltip: !0,\n"
            "trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n"
            "takeOrdinalPosition: !1,\n"
            "drawGraph: function() {\n"
                "this.options.lineWidth && B.prototype.drawGraph.call(this)\n"
            "}\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.pick,\n"
        "A = a.relativeLength;\n"
        "a.CenteredSeriesMixin = {\n"
            "getCenter: function() {\n"
                "var a = this.options,\n"
                "G = this.chart,\n"
                "r = 2 * (a.slicedOffset || 0),\n"
                "f = G.plotWidth - 2 * r,\n"
                "G = G.plotHeight - 2 * r,\n"
                "l = a.center,\n"
                "l = [B(l[0], \"50%\"), B(l[1], \"50%\"), a.size || \"100%\", a.innerSize || 0],\n"
                "q = Math.min(f, G),\n"
                "k,\n"
                "u;\n"
                "for (k = 0; 4 > k; ++k) u = l[k],\n"
                "a = 2 > k || 2 === k && /%$/.test(u),\n"
                "l[k] = A(u, [f, G, q, l[2]][k]) + (a ? r: 0);\n"
                "l[3] > l[2] && (l[3] = l[2]);\n"
                "return l\n"
            "}\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.defined,\n"
        "H = a.each,\n"
        "G = a.extend,\n"
        "r = a.inArray,\n"
        "f = a.noop,\n"
        "l = a.pick,\n"
        "q = a.Point,\n"
        "k = a.Series,\n"
        "u = a.seriesType,\n"
        "d = a.setAnimation;\n"
        "u(\"pie\", \"line\", {\n"
            "center: [null, null],\n"
            "clip: !1,\n"
            "colorByPoint: !0,\n"
            "dataLabels: {\n"
                "distance: 30,\n"
                "enabled: !0,\n"
                "formatter: function() {\n"
                    "return null === this.y ? void 0 : this.point.name\n"
                "},\n"
                "x: 0\n"
            "},\n"
            "ignoreHiddenPoint: !0,\n"
            "legendType: \"point\",\n"
            "marker: null,\n"
            "size: null,\n"
            "showInLegend: !1,\n"
            "slicedOffset: 10,\n"
            "stickyTracking: !1,\n"
            "tooltip: {\n"
                "followPointer: !0\n"
            "},\n"
            "borderColor: \"#ffffff\",\n"
            "borderWidth: 1,\n"
            "states: {\n"
                "hover: {\n"
                    "brightness: .1,\n"
                    "shadow: !1\n"
                "}\n"
            "}\n"
        "},\n"
        "{\n"
            "isCartesian: !1,\n"
            "requireSorting: !1,\n"
            "directTouch: !0,\n"
            "noSharedTooltip: !0,\n"
            "trackerGroups: [\"group\", \"dataLabelsGroup\"],\n"
            "axisTypes: [],\n"
            "pointAttribs: a.seriesTypes.column.prototype.pointAttribs,\n"
            "animate: function(a) {\n"
                "var c = this,\n"
                "d = c.points,\n"
                "b = c.startAngleRad;\n"
                "a || (H(d,\n"
                "function(a) {\n"
                    "var d = a.graphic,\n"
                    "f = a.shapeArgs;\n"
                    "d && (d.attr({\n"
                        "r: a.startR || c.center[3] / 2,\n"
                        "start: b,\n"
                        "end: b\n"
                    "}), d.animate({\n"
                        "r: f.r,\n"
                        "start: f.start,\n"
                        "end: f.end\n"
                    "},\n"
                    "c.options.animation))\n"
                "}), c.animate = null)\n"
            "},\n"
            "updateTotals: function() {\n"
                "var a, d = 0,\n"
                "f = this.points,\n"
                "b = f.length,\n"
                "k, h = this.options.ignoreHiddenPoint;\n"
                "for (a = 0; a < b; a++) k = f[a],\n"
                "0 > k.y && (k.y = null),\n"
                "d += h && !k.visible ? 0 : k.y;\n"
                "this.total = d;\n"
                "for (a = 0; a < b; a++) k = f[a],\n"
                "k.percentage = 0 < d && (k.visible || !h) ? k.y / d * 100 : 0,\n"
                "k.total = d\n"
            "},\n"
            "generatePoints: function() {\n"
                "k.prototype.generatePoints.call(this);\n"
                "this.updateTotals()\n"
            "},\n"
            "translate: function(a) {\n"
                "this.generatePoints();\n"
                "var c = 0,\n"
                "d = this.options,\n"
                "b = d.slicedOffset,\n"
                "f = b + (d.borderWidth || 0),\n"
                "h,\n"
                "k,\n"
                "q,\n"
                "w = d.startAngle || 0,\n"
                "e = this.startAngleRad = Math.PI / 180 * (w - 90),\n"
                "w = (this.endAngleRad = Math.PI / 180 * (l(d.endAngle, w + 360) - 90)) - e,\n"
                "r = this.points,\n"
                "u = d.dataLabels.distance,\n"
                "d = d.ignoreHiddenPoint,\n"
                "E,\n"
                "m = r.length,\n"
                "y;\n"
                "a || (this.center = a = this.getCenter());\n"
                "this.getX = function(b, c) {\n"
                    "q = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + u), 1));\n"
                    "return a[0] + (c ? -1 : 1) * Math.cos(q) * (a[2] / 2 + u)\n"
                "};\n"
                "for (E = 0; E < m; E++) {\n"
                    "y = r[E];\n"
                    "h = e + c * w;\n"
                    "if (!d || y.visible) c += y.percentage / 100;\n"
                    "k = e + c * w;\n"
                    "y.shapeType = \"arc\";\n"
                    "y.shapeArgs = {\n"
                        "x: a[0],\n"
                        "y: a[1],\n"
                        "r: a[2] / 2,\n"
                        "innerR: a[3] / 2,\n"
                        "start: Math.round(1E3 * h) / 1E3,\n"
                        "end: Math.round(1E3 * k) / 1E3\n"
                    "};\n"
                    "q = (k + h) / 2;\n"
                    "q > 1.5 * Math.PI ? q -= 2 * Math.PI: q < -Math.PI / 2 && (q += 2 * Math.PI);\n"
                    "y.slicedTranslation = {\n"
                        "translateX: Math.round(Math.cos(q) * b),\n"
                        "translateY: Math.round(Math.sin(q) * b)\n"
                    "};\n"
                    "h = Math.cos(q) * a[2] / 2;\n"
                    "k = Math.sin(q) * a[2] / 2;\n"
                    "y.tooltipPos = [a[0] + .7 * h, a[1] + .7 * k];\n"
                    "y.half = q < -Math.PI / 2 || q > Math.PI / 2 ? 1 : 0;\n"
                    "y.angle = q;\n"
                    "f = Math.min(f, u / 5);\n"
                    "y.labelPos = [a[0] + h + Math.cos(q) * u, a[1] + k + Math.sin(q) * u, a[0] + h + Math.cos(q) * f, a[1] + k + Math.sin(q) * f, a[0] + h, a[1] + k, 0 > u ? \"center\": y.half ? \"right\": \"left\", q]\n"
                "}\n"
            "},\n"
            "drawGraph: null,\n"
            "drawPoints: function() {\n"
                "var a = this,\n"
                "d = a.chart.renderer,\n"
                "f, b, k, h, l = a.options.shadow;\n"
                "l && !a.shadowGroup && (a.shadowGroup = d.g(\"shadow\").add(a.group));\n"
                "H(a.points,\n"
                "function(c) {\n"
                    "if (null !== c.y) {\n"
                        "b = c.graphic;\n"
                        "h = c.shapeArgs;\n"
                        "f = c.getTranslate();\n"
                        "var p = c.shadowGroup;\n"
                        "l && !p && (p = c.shadowGroup = d.g(\"shadow\").add(a.shadowGroup));\n"
                        "p && p.attr(f);\n"
                        "k = a.pointAttribs(c, c.selected && \"select\");\n"
                        "b ? b.setRadialReference(a.center).attr(k).animate(G(h, f)) : (c.graphic = b = d[c.shapeType](h).setRadialReference(a.center).attr(f).add(a.group), c.visible || b.attr({\n"
                            "visibility: \"hidden\"\n"
                        "}), b.attr(k).attr({\n"
                            "\"stroke-linejoin\": \"round\"\n"
                        "}).shadow(l, p));\n"
                        "b.addClass(c.getClassName())\n"
                    "}\n"
                "})\n"
            "},\n"
            "searchPoint: f,\n"
            "sortByAngle: function(a, d) {\n"
                "a.sort(function(a, b) {\n"
                    "return void 0 !== a.angle && (b.angle - a.angle) * d\n"
                "})\n"
            "},\n"
            "drawLegendSymbol: a.LegendSymbolMixin.drawRectangle,\n"
            "getCenter: a.CenteredSeriesMixin.getCenter,\n"
            "getSymbol: f\n"
        "},\n"
        "{\n"
            "init: function() {\n"
                "q.prototype.init.apply(this, arguments);\n"
                "var a = this,\n"
                "d;\n"
                "a.name = l(a.name, \"Slice\");\n"
                "d = function(c) {\n"
                    "a.slice(\"select\" === c.type)\n"
                "};\n"
                "B(a, \"select\", d);\n"
                "B(a, \"unselect\", d);\n"
                "return a\n"
            "},\n"
            "setVisible: function(a, d) {\n"
                "var c = this,\n"
                "b = c.series,\n"
                "f = b.chart,\n"
                "h = b.options.ignoreHiddenPoint;\n"
                "d = l(d, h);\n"
                "a !== c.visible && (c.visible = c.options.visible = a = void 0 === a ? !c.visible: a, b.options.data[r(c, b.data)] = c.options, H([\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"],\n"
                "function(b) {\n"
                    "if (c[b]) c[b][a ? \"show\": \"hide\"](!0)\n"
                "}), c.legendItem && f.legend.colorizeItem(c, a), a || \"hover\" !== c.state || c.setState(\"\"), h && (b.isDirty = !0), d && f.redraw())\n"
            "},\n"
            "slice: function(a, f, k) {\n"
                "var b = this.series;\n"
                "d(k, b.chart);\n"
                "l(f, !0);\n"
                "this.sliced = this.options.sliced = A(a) ? a: !this.sliced;\n"
                "b.options.data[r(this, b.data)] = this.options;\n"
                "this.graphic.animate(this.getTranslate());\n"
                "this.shadowGroup && this.shadowGroup.animate(this.getTranslate())\n"
            "},\n"
            "getTranslate: function() {\n"
                "return this.sliced ? this.slicedTranslation: {\n"
                    "translateX: 0,\n"
                    "translateY: 0\n"
                "}\n"
            "},\n"
            "haloPath: function(a) {\n"
                "var c = this.shapeArgs;\n"
                "return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, {\n"
                    "innerR: this.shapeArgs.r,\n"
                    "start: c.start,\n"
                    "end: c.end\n"
                "})\n"
            "}\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.arrayMax,\n"
        "H = a.defined,\n"
        "G = a.each,\n"
        "r = a.extend,\n"
        "f = a.format,\n"
        "l = a.map,\n"
        "q = a.merge,\n"
        "k = a.noop,\n"
        "u = a.pick,\n"
        "d = a.relativeLength,\n"
        "c = a.Series,\n"
        "n = a.seriesTypes,\n"
        "z = a.stableSort;\n"
        "a.distribute = function(a, c) {\n"
            "function b(a, b) {\n"
                "return a.target - b.target\n"
            "}\n"
            "var d, f = !0,\n"
            "k = a,\n"
            "e = [],\n"
            "p;\n"
            "p = 0;\n"
            "for (d = a.length; d--;) p += a[d].size;\n"
            "if (p > c) {\n"
                "z(a,\n"
                "function(a, b) {\n"
                    "return (b.rank || 0) - (a.rank || 0)\n"
                "});\n"
                "for (p = d = 0; p <= c;) p += a[d].size,\n"
                "d++;\n"
                "e = a.splice(d - 1, a.length)\n"
            "}\n"
            "z(a, b);\n"
            "for (a = l(a,\n"
            "function(a) {\n"
                "return {\n"
                    "size: a.size,\n"
                    "targets: [a.target]\n"
                "}\n"
            "}); f;) {\n"
                "for (d = a.length; d--;) f = a[d],\n"
                "p = (Math.min.apply(0, f.targets) + Math.max.apply(0, f.targets)) / 2,\n"
                "f.pos = Math.min(Math.max(0, p - f.size / 2), c - f.size);\n"
                "d = a.length;\n"
                "for (f = !1; d--;) 0 < d && a[d - 1].pos + a[d - 1].size > a[d].pos && (a[d - 1].size += a[d].size, a[d - 1].targets = a[d - 1].targets.concat(a[d].targets), a[d - 1].pos + a[d - 1].size > c && (a[d - 1].pos = c - a[d - 1].size), a.splice(d, 1), f = !0)\n"
            "}\n"
            "d = 0;\n"
            "G(a,\n"
            "function(a) {\n"
                "var b = 0;\n"
                "G(a.targets,\n"
                "function() {\n"
                    "k[d].pos = a.pos + b;\n"
                    "b += k[d].size;\n"
                    "d++\n"
                "})\n"
            "});\n"
            "k.push.apply(k, e);\n"
            "z(k, b)\n"
        "};\n"
        "c.prototype.drawDataLabels = function() {\n"
            "var a = this,\n"
            "c = a.options,\n"
            "d = c.dataLabels,\n"
            "k = a.points,\n"
            "l, n, e = a.hasRendered || 0,\n"
            "r, C, E = u(d.defer, !0),\n"
            "m = a.chart.renderer;\n"
            "if (d.enabled || a._hasPointLabels) a.dlProcessOptions && a.dlProcessOptions(d),\n"
            "C = a.plotGroup(\"dataLabelsGroup\", \"data-labels\", E && !e ? \"hidden\": \"visible\", d.zIndex || 6),\n"
            "E && (C.attr({\n"
                "opacity: +e\n"
            "}), e || B(a, \"afterAnimate\",\n"
            "function() {\n"
                "a.visible && C.show(!0);\n"
                "C[c.animation ? \"animate\": \"attr\"]({\n"
                    "opacity: 1\n"
                "},\n"
                "{\n"
                    "duration: 200\n"
                "})\n"
            "})),\n"
            "n = d,\n"
            "G(k,\n"
            "function(b) {\n"
                "var e, h = b.dataLabel,\n"
                "k, g, p, t = b.connector,\n"
                "w = !h,\n"
                "x;\n"
                "l = b.dlOptions || b.options && b.options.dataLabels;\n"
                "if (e = u(l && l.enabled, n.enabled) && null !== b.y) for (g in d = q(n, l), k = b.getLabelConfig(), r = d.format ? f(d.format, k) : d.formatter.call(k, d), x = d.style, p = d.rotation, x.color = u(d.color, x.color, a.color, \"#000000\"), \"contrast\" === x.color && (b.contrastColor = m.getContrast(b.color || a.color), x.color = d.inside || 0 > d.distance || c.stacking ? b.contrastColor: \"#000000\"), c.cursor && (x.cursor = c.cursor), k = {\n"
                    "fill: d.backgroundColor,\n"
                    "stroke: d.borderColor,\n"
                    "\"stroke-width\": d.borderWidth,\n"
                    "r: d.borderRadius || 0,\n"
                    "rotation: p,\n"
                    "padding: d.padding,\n"
                    "zIndex: 1\n"
                "},\n"
                "k) void 0 === k[g] && delete k[g]; ! h || e && H(r) ? e && H(r) && (h ? k.text = r: (h = b.dataLabel = m[p ? \"text\": \"label\"](r, 0, -9999, d.shape, null, null, d.useHTML, null, \"data-label\"), h.addClass(\"highcharts-data-label-color-\" + b.colorIndex + \" \" + (d.className || \"\") + (d.useHTML ? \"highcharts-tracker\": \"\"))), h.attr(k), h.css(x).shadow(d.shadow), h.added || h.add(C), a.alignDataLabel(b, h, d, null, w)) : (b.dataLabel = h.destroy(), t && (b.connector = t.destroy()))\n"
            "})\n"
        "};\n"
        "c.prototype.alignDataLabel = function(a, c, d, f, k) {\n"
            "var b = this.chart,\n"
            "e = b.inverted,\n"
            "h = u(a.plotX, -9999),\n"
            "l = u(a.plotY, -9999),\n"
            "p = c.getBBox(),\n"
            "m,\n"
            "n = d.rotation,\n"
            "q = d.align,\n"
            "t = this.visible && (a.series.forceDL || b.isInsidePlot(h, Math.round(l), e) || f && b.isInsidePlot(h, e ? f.x + 1 : f.y + f.height - 1, e)),\n"
            "D = \"justify\" === u(d.overflow, \"justify\");\n"
            "t && (m = d.style.fontSize, m = b.renderer.fontMetrics(m, c).b, f = r({\n"
                "x: e ? b.plotWidth - l: h,\n"
                "y: Math.round(e ? b.plotHeight - h: l),\n"
                "width: 0,\n"
                "height: 0\n"
            "},\n"
            "f), r(d, {\n"
                "width: p.width,\n"
                "height: p.height\n"
            "}), n ? (D = !1, e = b.renderer.rotCorr(m, n), e = {\n"
                "x: f.x + d.x + f.width / 2 + e.x,\n"
                "y: f.y + d.y + {\n"
                    "top: 0,\n"
                    "middle: .5,\n"
                    "bottom: 1\n"
                "} [d.verticalAlign] * f.height\n"
            "},\n"
            "c[k ? \"attr\": \"animate\"](e).attr({\n"
                "align: q\n"
            "}), h = (n + 720) % 360, h = 180 < h && 360 > h, \"left\" === q ? e.y -= h ? p.height: 0 : \"center\" === q ? (e.x -= p.width / 2, e.y -= p.height / 2) : \"right\" === q && (e.x -= p.width, e.y -= h ? 0 : p.height)) : (c.align(d, null, f), e = c.alignAttr), D ? a.isLabelJustified = this.justifyDataLabel(c, d, e, p, f, k) : u(d.crop, !0) && (t = b.isInsidePlot(e.x, e.y) && b.isInsidePlot(e.x + p.width, e.y + p.height)), d.shape && !n && c.attr({\n"
                "anchorX: a.plotX,\n"
                "anchorY: a.plotY\n"
            "}));\n"
            "t || (c.attr({\n"
                "y: -9999\n"
            "}), c.placed = !1)\n"
        "};\n"
        "c.prototype.justifyDataLabel = function(a, c, d, f, k, l) {\n"
            "var b = this.chart,\n"
            "h = c.align,\n"
            "p = c.verticalAlign,\n"
            "n, m, q = a.box ? 0 : a.padding || 0;\n"
            "n = d.x + q;\n"
            "0 > n && (\"right\" === h ? c.align = \"left\": c.x = -n, m = !0);\n"
            "n = d.x + f.width - q;\n"
            "n > b.plotWidth && (\"left\" === h ? c.align = \"right\": c.x = b.plotWidth - n, m = !0);\n"
            "n = d.y + q;\n"
            "0 > n && (\"bottom\" === p ? c.verticalAlign = \"top\": c.y = -n, m = !0);\n"
            "n = d.y + f.height - q;\n"
            "n > b.plotHeight && (\"top\" === p ? c.verticalAlign = \"bottom\": c.y = b.plotHeight - n, m = !0);\n"
            "m && (a.placed = !l, a.align(c, null, k));\n"
            "return m\n"
        "};\n"
        "n.pie && (n.pie.prototype.drawDataLabels = function() {\n"
            "var b = this,\n"
            "d = b.data,\n"
            "f, k = b.chart,\n"
            "n = b.options.dataLabels,\n"
            "q = u(n.connectorPadding, 10),\n"
            "e = u(n.connectorWidth, 1),\n"
            "r = k.plotWidth,\n"
            "C = k.plotHeight,\n"
            "E,\n"
            "m = n.distance,\n"
            "y = b.center,\n"
            "z = y[2] / 2,\n"
            "B = y[1],\n"
            "H = 0 < m,\n"
            "g,\n"
            "F,\n"
            "L,\n"
            "N,\n"
            "P = [[], []],\n"
            "O,\n"
            "v,\n"
            "M,\n"
            "R,\n"
            "S = [0, 0, 0, 0];\n"
            "b.visible && (n.enabled || b._hasPointLabels) && (G(d,\n"
            "function(a) {\n"
                "a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n"
                    "width: \"auto\"\n"
                "}).css({\n"
                    "width: \"auto\",\n"
                    "textOverflow: \"clip\"\n"
                "}), a.dataLabel.shortened = !1)\n"
            "}), c.prototype.drawDataLabels.apply(b), G(d,\n"
            "function(a) {\n"
                "a.dataLabel && a.visible && (P[a.half].push(a), a.dataLabel._pos = null)\n"
            "}), G(P,\n"
            "function(c, e) {\n"
                "var d, h, p = c.length,\n"
                "t, w, u;\n"
                "if (p) for (b.sortByAngle(c, e - .5), 0 < m && (d = Math.max(0, B - z - m), h = Math.min(B + z + m, k.plotHeight), t = l(c,\n"
                "function(a) {\n"
                    "if (a.dataLabel) return u = a.dataLabel.getBBox().height || 21,\n"
                    "{\n"
                        "target: a.labelPos[1] - d + u / 2,\n"
                        "size: u,\n"
                        "rank: a.y\n"
                    "}\n"
                "}), a.distribute(t, h + u - d)), R = 0; R < p; R++) f = c[R],\n"
                "L = f.labelPos,\n"
                "g = f.dataLabel,\n"
                "M = !1 === f.visible ? \"hidden\": \"inherit\",\n"
                "w = L[1],\n"
                "t ? void 0 === t[R].pos ? M = \"hidden\": (N = t[R].size, v = d + t[R].pos) : v = w,\n"
                "O = n.justify ? y[0] + (e ? -1 : 1) * (z + m) : b.getX(v < d + 2 || v > h - 2 ? w: v, e),\n"
                "g._attr = {\n"
                    "visibility: M,\n"
                    "align: L[6]\n"
                "},\n"
                "g._pos = {\n"
                    "x: O + n.x + ({\n"
                        "left: q,\n"
                        "right: -q\n"
                    "} [L[6]] || 0),\n"
                    "y: v + n.y - 10\n"
                "},\n"
                "L.x = O,\n"
                "L.y = v,\n"
                "null === b.options.size && (F = g.getBBox().width, w = null, O - F < q ? (w = Math.round(F - O + q), S[3] = Math.max(w, S[3])) : O + F > r - q && (w = Math.round(O + F - r + q), S[1] = Math.max(w, S[1])), 0 > v - N / 2 ? S[0] = Math.max(Math.round( - v + N / 2), S[0]) : v + N / 2 > C && (S[2] = Math.max(Math.round(v + N / 2 - C), S[2])), g.sideOverflow = w)\n"
            "}), 0 === A(S) || this.verifyDataLabelOverflow(S)) && (this.placeDataLabels(), H && e && G(this.points,\n"
            "function(a) {\n"
                "var c;\n"
                "E = a.connector;\n"
                "if ((g = a.dataLabel) && g._pos && a.visible) {\n"
                    "M = g._attr.visibility;\n"
                    "if (c = !E) a.connector = E = k.renderer.path().addClass(\"highcharts-data-label-connector highcharts-color-\" + a.colorIndex).add(b.dataLabelsGroup),\n"
                    "E.attr({\n"
                        "\"stroke-width\": e,\n"
                        "stroke: n.connectorColor || a.color || \"#666666\"\n"
                    "});\n"
                    "E[c ? \"attr\": \"animate\"]({\n"
                        "d: b.connectorPath(a.labelPos)\n"
                    "});\n"
                    "E.attr(\"visibility\", M)\n"
                "} else E && (a.connector = E.destroy())\n"
            "}))\n"
        "},\n"
        "n.pie.prototype.connectorPath = function(a) {\n"
            "var b = a.x,\n"
            "c = a.y;\n"
            "return u(this.options.dataLabels.softConnector, !0) ? [\"M\", b + (\"left\" === a[6] ? 5 : -5), c, \"C\", b, c, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], \"L\", a[4], a[5]] : [\"M\", b + (\"left\" === a[6] ? 5 : -5), c, \"L\", a[2], a[3], \"L\", a[4], a[5]]\n"
        "},\n"
        "n.pie.prototype.placeDataLabels = function() {\n"
            "G(this.points,\n"
            "function(a) {\n"
                "var b = a.dataLabel;\n"
                "b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({\n"
                    "width: b._attr.width + \"px\",\n"
                    "textOverflow: \"ellipsis\"\n"
                "}), b.shortened = !0), b.attr(b._attr), b[b.moved ? \"animate\": \"attr\"](a), b.moved = !0) : b && b.attr({\n"
                    "y: -9999\n"
                "}))\n"
            "},\n"
            "this)\n"
        "},\n"
        "n.pie.prototype.alignDataLabel = k, n.pie.prototype.verifyDataLabelOverflow = function(a) {\n"
            "var b = this.center,\n"
            "c = this.options,\n"
            "f = c.center,\n"
            "k = c.minSize || 80,\n"
            "l, e;\n"
            "null !== f[0] ? l = Math.max(b[2] - Math.max(a[1], a[3]), k) : (l = Math.max(b[2] - a[1] - a[3], k), b[0] += (a[3] - a[1]) / 2);\n"
            "null !== f[1] ? l = Math.max(Math.min(l, b[2] - Math.max(a[0], a[2])), k) : (l = Math.max(Math.min(l, b[2] - a[0] - a[2]), k), b[1] += (a[0] - a[2]) / 2);\n"
            "l < b[2] ? (b[2] = l, b[3] = Math.min(d(c.innerSize || 0, l), l), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : e = !0;\n"
            "return e\n"
        "});\n"
        "n.column && (n.column.prototype.alignDataLabel = function(a, d, f, k, l) {\n"
            "var b = this.chart.inverted,\n"
            "e = a.series,\n"
            "h = a.dlBox || a.shapeArgs,\n"
            "n = u(a.below, a.plotY > u(this.translatedThreshold, e.yAxis.len)),\n"
            "p = u(f.inside, !!this.options.stacking);\n"
            "h && (k = q(h), 0 > k.y && (k.height += k.y, k.y = 0), h = k.y + k.height - e.yAxis.len, 0 < h && (k.height -= h), b && (k = {\n"
                "x: e.yAxis.len - k.y - k.height,\n"
                "y: e.xAxis.len - k.x - k.width,\n"
                "width: k.height,\n"
                "height: k.width\n"
            "}), p || (b ? (k.x += n ? 0 : k.width, k.width = 0) : (k.y += n ? k.height: 0, k.height = 0)));\n"
            "f.align = u(f.align, !b || p ? \"center\": n ? \"right\": \"left\");\n"
            "f.verticalAlign = u(f.verticalAlign, b || p ? \"middle\": n ? \"top\": \"bottom\");\n"
            "c.prototype.alignDataLabel.call(this, a, d, f, k, l);\n"
            "a.isLabelJustified && a.contrastColor && a.dataLabel.css({\n"
                "color: a.contrastColor\n"
            "})\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.Chart,\n"
        "A = a.each,\n"
        "H = a.pick,\n"
        "G = a.addEvent;\n"
        "B.prototype.callbacks.push(function(a) {\n"
            "function f() {\n"
                "var f = [];\n"
                "A(a.series || [],\n"
                "function(a) {\n"
                    "var k = a.options.dataLabels,\n"
                    "l = a.dataLabelCollections || [\"dataLabel\"]; (k.enabled || a._hasPointLabels) && !k.allowOverlap && a.visible && A(l,\n"
                    "function(d) {\n"
                        "A(a.points,\n"
                        "function(a) {\n"
                            "a[d] && (a[d].labelrank = H(a.labelrank, a.shapeArgs && a.shapeArgs.height), f.push(a[d]))\n"
                        "})\n"
                    "})\n"
                "});\n"
                "a.hideOverlappingLabels(f)\n"
            "}\n"
            "f();\n"
            "G(a, \"redraw\", f)\n"
        "});\n"
        "B.prototype.hideOverlappingLabels = function(a) {\n"
            "var f = a.length,\n"
            "l, q, k, r, d, c, n, z, b, p = function(a, b, c, d, e, f, k, l) {\n"
                "return ! (e > a + c || e + k < a || f > b + d || f + l < b)\n"
            "};\n"
            "for (q = 0; q < f; q++) if (l = a[q]) l.oldOpacity = l.opacity,\n"
            "l.newOpacity = 1;\n"
            "a.sort(function(a, b) {\n"
                "return (b.labelrank || 0) - (a.labelrank || 0)\n"
            "});\n"
            "for (q = 0; q < f; q++) for (k = a[q], l = q + 1; l < f; ++l) if (r = a[l], k && r && k !== r && k.placed && r.placed && 0 !== k.newOpacity && 0 !== r.newOpacity && (d = k.alignAttr, c = r.alignAttr, n = k.parentGroup, z = r.parentGroup, b = 2 * (k.box ? 0 : k.padding), d = p(d.x + n.translateX, d.y + n.translateY, k.width - b, k.height - b, c.x + z.translateX, c.y + z.translateY, r.width - b, r.height - b)))(k.labelrank < r.labelrank ? k: r).newOpacity = 0;\n"
            "A(a,\n"
            "function(a) {\n"
                "var b, c;\n"
                "a && (c = a.newOpacity, a.oldOpacity !== c && a.placed && (c ? a.show(!0) : b = function() {\n"
                    "a.hide()\n"
                "},\n"
                "a.alignAttr.opacity = c, a[a.isOld ? \"animate\": \"attr\"](a.alignAttr, null, b)), a.isOld = !0)\n"
            "})\n"
        "}\n"
    "})(L); (function(a) {\n"
        "var B = a.addEvent,\n"
        "A = a.Chart,\n"
        "H = a.createElement,\n"
        "G = a.css,\n"
        "r = a.defaultOptions,\n"
        "f = a.defaultPlotOptions,\n"
        "l = a.each,\n"
        "q = a.extend,\n"
        "k = a.fireEvent,\n"
        "u = a.hasTouch,\n"
        "d = a.inArray,\n"
        "c = a.isObject,\n"
        "n = a.Legend,\n"
        "z = a.merge,\n"
        "b = a.pick,\n"
        "p = a.Point,\n"
        "h = a.Series,\n"
        "t = a.seriesTypes,\n"
        "D = a.svg;\n"
        "a = a.TrackerMixin = {\n"
            "drawTrackerPoint: function() {\n"
                "var a = this,\n"
                "b = a.chart.pointer,\n"
                "c = function(a) {\n"
                    "var c = b.getPointFromEvent(a);\n"
                    "if (void 0 !== c) c.onMouseOver(a)\n"
                "};\n"
                "l(a.points,\n"
                "function(a) {\n"
                    "a.graphic && (a.graphic.element.point = a);\n"
                    "a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a: a.dataLabel.element.point = a)\n"
                "});\n"
                "a._hasTracking || (l(a.trackerGroups,\n"
                "function(e) {\n"
                    "if (a[e]) {\n"
                        "a[e].addClass(\"highcharts-tracker\").on(\"mouseover\", c).on(\"mouseout\",\n"
                        "function(a) {\n"
                            "b.onTrackerMouseOut(a)\n"
                        "});\n"
                        "if (u) a[e].on(\"touchstart\", c);\n"
                        "a.options.cursor && a[e].css(G).css({\n"
                            "cursor: a.options.cursor\n"
                        "})\n"
                    "}\n"
                "}), a._hasTracking = !0)\n"
            "},\n"
            "drawTrackerGraph: function() {\n"
                "var a = this,\n"
                "b = a.options,\n"
                "c = b.trackByArea,\n"
                "d = [].concat(c ? a.areaPath: a.graphPath),\n"
                "f = d.length,\n"
                "h = a.chart,\n"
                "k = h.pointer,\n"
                "n = h.renderer,\n"
                "p = h.options.tooltip.snap,\n"
                "q = a.tracker,\n"
                "g,\n"
                "r = function() {\n"
                    "if (h.hoverSeries !== a) a.onMouseOver()\n"
                "},\n"
                "t = \"rgba(192,192,192,\" + (D ? .0001 : .002) + \")\";\n"
                "if (f && !c) for (g = f + 1; g--;)\"M\" === d[g] && d.splice(g + 1, 0, d[g + 1] - p, d[g + 2], \"L\"),\n"
                "(g && \"M\" === d[g] || g === f) && d.splice(g, 0, \"L\", d[g - 2] + p, d[g - 1]);\n"
                "q ? q.attr({\n"
                    "d: d\n"
                "}) : a.graph && (a.tracker = n.path(d).attr({\n"
                    "\"stroke-linejoin\": \"round\",\n"
                    "visibility: a.visible ? \"visible\": \"hidden\",\n"
                    "stroke: t,\n"
                    "fill: c ? t: \"none\",\n"
                    "\"stroke-width\": a.graph.strokeWidth() + (c ? 0 : 2 * p),\n"
                    "zIndex: 2\n"
                "}).add(a.group), l([a.tracker, a.markerGroup],\n"
                "function(a) {\n"
                    "a.addClass(\"highcharts-tracker\").on(\"mouseover\", r).on(\"mouseout\",\n"
                    "function(a) {\n"
                        "k.onTrackerMouseOut(a)\n"
                    "});\n"
                    "b.cursor && a.css({\n"
                        "cursor: b.cursor\n"
                    "});\n"
                    "if (u) a.on(\"touchstart\", r)\n"
                "}))\n"
            "}\n"
        "};\n"
        "t.column && (t.column.prototype.drawTracker = a.drawTrackerPoint);\n"
        "t.pie && (t.pie.prototype.drawTracker = a.drawTrackerPoint);\n"
        "t.scatter && (t.scatter.prototype.drawTracker = a.drawTrackerPoint);\n"
        "q(n.prototype, {\n"
            "setItemEvents: function(a, b, c) {\n"
                "var d = this,\n"
                "e = d.chart.renderer.boxWrapper,\n"
                "f = \"highcharts-legend-\" + (a.series ? \"point\": \"series\") + \"-active\"; (c ? b: a.legendGroup).on(\"mouseover\",\n"
                "function() {\n"
                    "a.setState(\"hover\");\n"
                    "e.addClass(f);\n"
                    "b.css(d.options.itemHoverStyle)\n"
                "}).on(\"mouseout\",\n"
                "function() {\n"
                    "b.css(a.visible ? d.itemStyle: d.itemHiddenStyle);\n"
                    "e.removeClass(f);\n"
                    "a.setState()\n"
                "}).on(\"click\",\n"
                "function(b) {\n"
                    "var c = function() {\n"
                        "a.setVisible && a.setVisible()\n"
                    "};\n"
                    "b = {\n"
                        "browserEvent: b\n"
                    "};\n"
                    "a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, c) : k(a, \"legendItemClick\", b, c)\n"
                "})\n"
            "},\n"
            "createCheckboxForItem: function(a) {\n"
                "a.checkbox = H(\"input\", {\n"
                    "type: \"checkbox\",\n"
                    "checked: a.selected,\n"
                    "defaultChecked: a.selected\n"
                "},\n"
                "this.options.itemCheckboxStyle, this.chart.container);\n"
                "B(a.checkbox, \"click\",\n"
                "function(b) {\n"
                    "k(a.series || a, \"checkboxClick\", {\n"
                        "checked: b.target.checked,\n"
                        "item: a\n"
                    "},\n"
                    "function() {\n"
                        "a.select()\n"
                    "})\n"
                "})\n"
            "}\n"
        "});\n"
        "r.legend.itemStyle.cursor = \"pointer\";\n"
        "q(A.prototype, {\n"
            "showResetZoom: function() {\n"
                "var a = this,\n"
                "b = r.lang,\n"
                "c = a.options.chart.resetZoomButton,\n"
                "d = c.theme,\n"
                "f = d.states,\n"
                "h = \"chart\" === c.relativeTo ? null: \"plotBox\";\n"
                "this.resetZoomButton = a.renderer.button(b.resetZoom, null, null,\n"
                "function() {\n"
                    "a.zoomOut()\n"
                "},\n"
                "d, f && f.hover).attr({\n"
                    "align: c.position.align,\n"
                    "title: b.resetZoomTitle\n"
                "}).addClass(\"highcharts-reset-zoom\").add().align(c.position, !1, h)\n"
            "},\n"
            "zoomOut: function() {\n"
                "var a = this;\n"
                "k(a, \"selection\", {\n"
                    "resetSelection: !0\n"
                "},\n"
                "function() {\n"
                    "a.zoom()\n"
                "})\n"
            "},\n"
            "zoom: function(a) {\n"
                "var d, f = this.pointer,\n"
                "h = !1,\n"
                "k; ! a || a.resetSelection ? l(this.axes,\n"
                "function(a) {\n"
                    "d = a.zoom()\n"
                "}) : l(a.xAxis.concat(a.yAxis),\n"
                "function(a) {\n"
                    "var b = a.axis;\n"
                    "f[b.isXAxis ? \"zoomX\": \"zoomY\"] && (d = b.zoom(a.min, a.max), b.displayBtn && (h = !0))\n"
                "});\n"
                "k = this.resetZoomButton;\n"
                "h && !k ? this.showResetZoom() : !h && c(k) && (this.resetZoomButton = k.destroy());\n"
                "d && this.redraw(b(this.options.chart.animation, a && a.animation, 100 > this.pointCount))\n"
            "},\n"
            "pan: function(a, b) {\n"
                "var c = this,\n"
                "d = c.hoverPoints,\n"
                "e;\n"
                "d && l(d,\n"
                "function(a) {\n"
                    "a.setState()\n"
                "});\n"
                "l(\"xy\" === b ? [1, 0] : [1],\n"
                "function(b) {\n"
                    "b = c[b ? \"xAxis\": \"yAxis\"][0];\n"
                    "var d = b.horiz,\n"
                    "f = a[d ? \"chartX\": \"chartY\"],\n"
                    "d = d ? \"mouseDownX\": \"mouseDownY\",\n"
                    "h = c[d],\n"
                    "k = (b.pointRange || 0) / 2,\n"
                    "g = b.getExtremes(),\n"
                    "l = b.toValue(h - f, !0) + k,\n"
                    "k = b.toValue(h + b.len - f, !0) - k,\n"
                    "m = k < l,\n"
                    "h = m ? k: l,\n"
                    "l = m ? l: k,\n"
                    "m = b.toValue(b.toPixels(g.min) - b.minPixelPadding),\n"
                    "k = b.toValue(b.toPixels(g.max) + b.minPixelPadding),\n"
                    "m = Math.min(g.dataMin, m) - h,\n"
                    "g = l - Math.max(g.dataMax, k);\n"
                    "b.series.length && 0 > m && 0 > g && (b.setExtremes(h, l, !1, !1, {\n"
                        "trigger: \"pan\"\n"
                    "}), e = !0);\n"
                    "c[d] = f\n"
                "});\n"
                "e && c.redraw(!1);\n"
                "G(c.container, {\n"
                    "cursor: \"move\"\n"
                "})\n"
            "}\n"
        "});\n"
        "q(p.prototype, {\n"
            "select: function(a, c) {\n"
                "var e = this,\n"
                "f = e.series,\n"
                "h = f.chart;\n"
                "a = b(a, !e.selected);\n"
                "e.firePointEvent(a ? \"select\": \"unselect\", {\n"
                    "accumulate: c\n"
                "},\n"
                "function() {\n"
                    "e.selected = e.options.selected = a;\n"
                    "f.options.data[d(e, f.data)] = e.options;\n"
                    "e.setState(a && \"select\");\n"
                    "c || l(h.getSelectedPoints(),\n"
                    "function(a) {\n"
                        "a.selected && a !== e && (a.selected = a.options.selected = !1, f.options.data[d(a, f.data)] = a.options, a.setState(\"\"), a.firePointEvent(\"unselect\"))\n"
                    "})\n"
                "})\n"
            "},\n"
            "onMouseOver: function(a) {\n"
                "var b = this.series.chart.pointer;\n"
                "this.firePointEvent(\"mouseOver\");\n"
                "b.runPointActions(a, this)\n"
            "},\n"
            "onMouseOut: function() {\n"
                "var a = this.series.chart;\n"
                "this.firePointEvent(\"mouseOut\");\n"
                "l(a.hoverPoints || [],\n"
                "function(a) {\n"
                    "a.setState()\n"
                "});\n"
                "a.hoverPoints = a.hoverPoint = null\n"
            "},\n"
            "importEvents: function() {\n"
                "if (!this.hasImportedEvents) {\n"
                    "var a = z(this.series.options.point, this.options).events,\n"
                    "b;\n"
                    "this.events = a;\n"
                    "for (b in a) B(this, b, a[b]);\n"
                    "this.hasImportedEvents = !0\n"
                "}\n"
            "},\n"
            "setState: function(a, c) {\n"
                "var d = Math.floor(this.plotX),\n"
                "e = this.plotY,\n"
                "h = this.series,\n"
                "k = h.options.states[a] || {},\n"
                "l = f[h.type].marker && h.options.marker,\n"
                "n = l && !1 === l.enabled,\n"
                "p = l && l.states && l.states[a] || {},\n"
                "r = !1 === p.enabled,\n"
                "g = h.stateMarkerGraphic,\n"
                "t = this.marker || {},\n"
                "u = h.chart,\n"
                "w = h.halo,\n"
                "z,\n"
                "A = l && h.markerAttribs;\n"
                "a = a || \"\";\n"
                "if (! (a === this.state && !c || this.selected && \"select\" !== a || !1 === k.enabled || a && (r || n && !1 === p.enabled) || a && t.states && t.states[a] && !1 === t.states[a].enabled)) {\n"
                    "A && (z = h.markerAttribs(this, a));\n"
                    "if (this.graphic) this.state && this.graphic.removeClass(\"highcharts-point-\" + this.state),\n"
                    "a && this.graphic.addClass(\"highcharts-point-\" + a),\n"
                    "this.graphic.attr(h.pointAttribs(this, a)),\n"
                    "z && this.graphic.animate(z, b(u.options.chart.animation, p.animation, l.animation)),\n"
                    "g && g.hide();\n"
                    "else {\n"
                        "if (a && p) {\n"
                            "l = t.symbol || h.symbol;\n"
                            "g && g.currentSymbol !== l && (g = g.destroy());\n"
                            "if (g) g[c ? \"animate\": \"attr\"]({\n"
                                "x: z.x,\n"
                                "y: z.y\n"
                            "});\n"
                            "else l && (h.stateMarkerGraphic = g = u.renderer.symbol(l, z.x, z.y, z.width, z.height).add(h.markerGroup), g.currentSymbol = l);\n"
                            "g && g.attr(h.pointAttribs(this, a))\n"
                        "}\n"
                        "g && (g[a && u.isInsidePlot(d, e, u.inverted) ? \"show\": \"hide\"](), g.element.point = this)\n"
                    "} (d = k.halo) && d.size ? (w || (h.halo = w = u.renderer.path().add(A ? h.markerGroup: h.group)), w[c ? \"animate\": \"attr\"]({\n"
                        "d: this.haloPath(d.size)\n"
                    "}), w.attr({\n"
                        "\"class\": \"highcharts-halo highcharts-color-\" + b(this.colorIndex, h.colorIndex)\n"
                    "}), w.point = this, w.attr(q({\n"
                        "fill: this.color || h.color,\n"
                        "\"fill-opacity\": d.opacity,\n"
                        "zIndex: -1\n"
                    "},\n"
                    "d.attributes))) : w && w.point && w.point.haloPath && w.animate({\n"
                        "d: w.point.haloPath(0)\n"
                    "});\n"
                    "this.state = a\n"
                "}\n"
            "},\n"
            "haloPath: function(a) {\n"
                "return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a)\n"
            "}\n"
        "});\n"
        "q(h.prototype, {\n"
            "onMouseOver: function() {\n"
                "var a = this.chart,\n"
                "b = a.hoverSeries;\n"
                "if (b && b !== this) b.onMouseOut();\n"
                "this.options.events.mouseOver && k(this, \"mouseOver\");\n"
                "this.setState(\"hover\");\n"
                "a.hoverSeries = this\n"
            "},\n"
            "onMouseOut: function() {\n"
                "var a = this.options,\n"
                "b = this.chart,\n"
                "c = b.tooltip,\n"
                "d = b.hoverPoint;\n"
                "b.hoverSeries = null;\n"
                "if (d) d.onMouseOut();\n"
                "this && a.events.mouseOut && k(this, \"mouseOut\"); ! c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n"
                "this.setState()\n"
            "},\n"
            "setState: function(a) {\n"
                "var c = this,\n"
                "d = c.options,\n"
                "f = c.graph,\n"
                "h = d.states,\n"
                "k = d.lineWidth,\n"
                "d = 0;\n"
                "a = a || \"\";\n"
                "if (c.state !== a && (l([c.group, c.markerGroup, c.dataLabelsGroup],\n"
                "function(b) {\n"
                    "b && (c.state && b.removeClass(\"highcharts-series-\" + c.state), a && b.addClass(\"highcharts-series-\" + a))\n"
                "}), c.state = a, !h[a] || !1 !== h[a].enabled) && (a && (k = h[a].lineWidth || k + (h[a].lineWidthPlus || 0)), f && !f.dashstyle)) for (k = {\n"
                    "\"stroke-width\": k\n"
                "},\n"
                "f.animate(k, b(c.chart.options.chart.animation, h[a] && h[a].animation)); c[\"zone-graph-\" + d];) c[\"zone-graph-\" + d].attr(k),\n"
                "d += 1\n"
            "},\n"
            "setVisible: function(a, b) {\n"
                "var c = this,\n"
                "d = c.chart,\n"
                "e = c.legendItem,\n"
                "f, h = d.options.chart.ignoreHiddenSeries,\n"
                "n = c.visible;\n"
                "f = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !n: a) ? \"show\": \"hide\";\n"
                "l([\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"],\n"
                "function(a) {\n"
                    "if (c[a]) c[a][f]()\n"
                "});\n"
                "if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();\n"
                "e && d.legend.colorizeItem(c, a);\n"
                "c.isDirty = !0;\n"
                "c.options.stacking && l(d.series,\n"
                "function(a) {\n"
                    "a.options.stacking && a.visible && (a.isDirty = !0)\n"
                "});\n"
                "l(c.linkedSeries,\n"
                "function(b) {\n"
                    "b.setVisible(a, !1)\n"
                "});\n"
                "h && (d.isDirtyBox = !0); ! 1 !== b && d.redraw();\n"
                "k(c, f)\n"
            "},\n"
            "show: function() {\n"
                "this.setVisible(!0)\n"
            "},\n"
            "hide: function() {\n"
                "this.setVisible(!1)\n"
            "},\n"
            "select: function(a) {\n"
                "this.selected = a = void 0 === a ? !this.selected: a;\n"
                "this.checkbox && (this.checkbox.checked = a);\n"
                "k(this, a ? \"select\": \"unselect\")\n"
            "},\n"
            "drawTracker: a.drawTrackerGraph\n"
        "})\n"
    "})(L); (function(a) {\n"
        "var B = a.Chart,\n"
        "A = a.each,\n"
        "H = a.inArray,\n"
        "G = a.isArray,\n"
        "r = a.isObject,\n"
        "f = a.pick,\n"
        "l = a.splat;\n"
        "B.prototype.setResponsive = function(f) {\n"
            "var k = this.options.responsive,\n"
            "l = [],\n"
            "d = this.currentResponsive;\n"
            "k && k.rules && A(k.rules,\n"
            "function(c) {\n"
                "void 0 === c._id && (c._id = a.uniqueKey());\n"
                "this.matchResponsiveRule(c, l, f)\n"
            "},\n"
            "this);\n"
            "var c = a.merge.apply(0, a.map(l,\n"
            "function(c) {\n"
                "return a.find(k.rules,\n"
                "function(a) {\n"
                    "return a._id === c\n"
                "}).chartOptions\n"
            "})),\n"
            "l = l.toString() || void 0;\n"
            "l !== (d && d.ruleIds) && (d && this.update(d.undoOptions, f), l ? (this.currentResponsive = {\n"
                "ruleIds: l,\n"
                "mergedOptions: c,\n"
                "undoOptions: this.currentOptions(c)\n"
            "},\n"
            "this.update(c, f)) : this.currentResponsive = void 0)\n"
        "};\n"
        "B.prototype.matchResponsiveRule = function(a, k) {\n"
            "var l = a.condition; (l.callback ||\n"
            "function() {\n"
                "return this.chartWidth <= f(l.maxWidth, Number.MAX_VALUE) && this.chartHeight <= f(l.maxHeight, Number.MAX_VALUE) && this.chartWidth >= f(l.minWidth, 0) && this.chartHeight >= f(l.minHeight, 0)\n"
            "}).call(this) && k.push(a._id)\n"
        "};\n"
        "B.prototype.currentOptions = function(a) {\n"
            "function f(a, c, k, q) {\n"
                "var b, d;\n"
                "for (b in a) if (!q && -1 < H(b, [\"series\", \"xAxis\", \"yAxis\"])) for (a[b] = l(a[b]), k[b] = [], d = 0; d < a[b].length; d++) c[b][d] && (k[b][d] = {},\n"
                "f(a[b][d], c[b][d], k[b][d], q + 1));\n"
                "else r(a[b]) ? (k[b] = G(a[b]) ? [] : {},\n"
                "f(a[b], c[b] || {},\n"
                "k[b], q + 1)) : k[b] = c[b] || null\n"
            "}\n"
            "var q = {};\n"
            "f(a, this.options, q, 0);\n"
            "return q\n"
        "}\n"
    "})(L);\n"
    "return L\n"
"});\n"
};
#endif
