#ifndef _J_003_H_
#define _J_003_H_

#if Web_RunTime_Debug==1
static const char j_003[]={
"HTTP/1.1 200 OK\r\nContent-Type:text/javascript\r\nAccept-Ranges:bytes\r\n\r\n"
 //Javascript plotting library for jQuery, version 0.8.3.\n"
 //Copyright (c) 2007-2014 IOLA and Ole Laursen.\n"
 //Licensed under the MIT license.\n"
"(function($) {\n"
    "$.color = {};\n"
    "$.color.make = function(r, g, b, a) {\n"
        "var o = {};\n"
        "o.r = r || 0;\n"
        "o.g = g || 0;\n"
        "o.b = b || 0;\n"
        "o.a = a != null ? a: 1;\n"
        "o.add = function(c, d) {\n"
            "for (var i = 0; i < c.length; ++i) o[c.charAt(i)] += d;\n"
            "return o.normalize()\n"
        "};\n"
        "o.scale = function(c, f) {\n"
            "for (var i = 0; i < c.length; ++i) o[c.charAt(i)] *= f;\n"
            "return o.normalize()\n"
        "};\n"
        "o.toString = function() {\n"
            "if (o.a >= 1) {\n"
                "return \"rgb(\" + [o.r, o.g, o.b].join(\",\") + \")\"\n"
            "} else {\n"
                "return \"rgba(\" + [o.r, o.g, o.b, o.a].join(\",\") + \")\"\n"
            "}\n"
        "};\n"
        "o.normalize = function() {\n"
            "function clamp(min, value, max) {\n"
                "return value < min ? min: value > max ? max: value\n"
            "}\n"
            "o.r = clamp(0, parseInt(o.r), 255);\n"
            "o.g = clamp(0, parseInt(o.g), 255);\n"
            "o.b = clamp(0, parseInt(o.b), 255);\n"
            "o.a = clamp(0, o.a, 1);\n"
            "return o\n"
        "};\n"
        "o.clone = function() {\n"
            "return $.color.make(o.r, o.b, o.g, o.a)\n"
        "};\n"
        "return o.normalize()\n"
    "};\n"
    "$.color.extract = function(elem, css) {\n"
        "var c;\n"
        "do {\n"
            "c = elem.css(css).toLowerCase();\n"
            "if (c != \"\" && c != \"transparent\") break;\n"
            "elem = elem.parent()\n"
        "} while ( elem . length && ! $ . nodeName ( elem . get ( 0 ), \"body\"));\n"
        "if (c == \"rgba(0, 0, 0, 0)\") c = \"transparent\";\n"
        "return $.color.parse(c)\n"
    "};\n"
    "$.color.parse = function(str) {\n"
        "var res, m = $.color.make;\n"
        "if (res = /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10));\n"
        "if (res = /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)) return m(parseInt(res[1], 10), parseInt(res[2], 10), parseInt(res[3], 10), parseFloat(res[4]));\n"
        "if (res = /rgb\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*\\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55);\n"
        "if (res = /rgba\\(\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\%\\s*,\\s*([0-9]+(?:\\.[0-9]+)?)\\s*\\)/.exec(str)) return m(parseFloat(res[1]) * 2.55, parseFloat(res[2]) * 2.55, parseFloat(res[3]) * 2.55, parseFloat(res[4]));\n"
        "if (res = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(str)) return m(parseInt(res[1], 16), parseInt(res[2], 16), parseInt(res[3], 16));\n"
        "if (res = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(str)) return m(parseInt(res[1] + res[1], 16), parseInt(res[2] + res[2], 16), parseInt(res[3] + res[3], 16));\n"
        "var name = $.trim(str).toLowerCase();\n"
        "if (name == \"transparent\") return m(255, 255, 255, 0);\n"
        "else {\n"
            "res = lookupColors[name] || [0, 0, 0];\n"
            "return m(res[0], res[1], res[2])\n"
        "}\n"
    "};\n"
    "var lookupColors = {\n"
        "aqua: [0, 255, 255],\n"
        "azure: [240, 255, 255],\n"
        "beige: [245, 245, 220],\n"
        "black: [0, 0, 0],\n"
        "blue: [0, 0, 255],\n"
        "brown: [165, 42, 42],\n"
        "cyan: [0, 255, 255],\n"
        "darkblue: [0, 0, 139],\n"
        "darkcyan: [0, 139, 139],\n"
        "darkgrey: [169, 169, 169],\n"
        "darkgreen: [0, 100, 0],\n"
        "darkkhaki: [189, 183, 107],\n"
        "darkmagenta: [139, 0, 139],\n"
        "darkolivegreen: [85, 107, 47],\n"
        "darkorange: [255, 140, 0],\n"
        "darkorchid: [153, 50, 204],\n"
        "darkred: [139, 0, 0],\n"
        "darksalmon: [233, 150, 122],\n"
        "darkviolet: [148, 0, 211],\n"
        "fuchsia: [255, 0, 255],\n"
        "gold: [255, 215, 0],\n"
        "green: [0, 128, 0],\n"
        "indigo: [75, 0, 130],\n"
        "khaki: [240, 230, 140],\n"
        "lightblue: [173, 216, 230],\n"
        "lightcyan: [224, 255, 255],\n"
        "lightgreen: [144, 238, 144],\n"
        "lightgrey: [211, 211, 211],\n"
        "lightpink: [255, 182, 193],\n"
        "lightyellow: [255, 255, 224],\n"
        "lime: [0, 255, 0],\n"
        "magenta: [255, 0, 255],\n"
        "maroon: [128, 0, 0],\n"
        "navy: [0, 0, 128],\n"
        "olive: [128, 128, 0],\n"
        "orange: [255, 165, 0],\n"
        "pink: [255, 192, 203],\n"
        "purple: [128, 0, 128],\n"
        "violet: [128, 0, 128],\n"
        "red: [255, 0, 0],\n"
        "silver: [192, 192, 192],\n"
        "white: [255, 255, 255],\n"
        "yellow: [255, 255, 0]\n"
    "}\n"
"})(jQuery); (function($) {\n"
    "var hasOwnProperty = Object.prototype.hasOwnProperty;\n"
    "if (!$.fn.detach) {\n"
        "$.fn.detach = function() {\n"
            "return this.each(function() {\n"
                "if (this.parentNode) {\n"
                    "this.parentNode.removeChild(this)\n"
                "}\n"
            "})\n"
        "}\n"
    "}\n"
    "function Canvas(cls, container) {\n"
        "var element = container.children(\".\" + cls)[0];\n"
        "if (element == null) {\n"
            "element = document.createElement(\"canvas\");\n"
            "element.className = cls;\n"
            "$(element).css({\n"
                "direction: \"ltr\",\n"
                "position: \"absolute\",\n"
                "left: 0,\n"
                "top: 0\n"
            "}).appendTo(container);\n"
            "if (!element.getContext) {\n"
                "if (window.G_vmlCanvasManager) {\n"
                    "element = window.G_vmlCanvasManager.initElement(element)\n"
                "} else {\n"
                    "throw new Error(\"Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.\")\n"
                "}\n"
            "}\n"
        "}\n"
        "this.element = element;\n"
        "var context = this.context = element.getContext(\"2d\");\n"
        "var devicePixelRatio = window.devicePixelRatio || 1,\n"
        "backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n"
        "this.pixelRatio = devicePixelRatio / backingStoreRatio;\n"
        "this.resize(container.width(), container.height());\n"
        "this.textContainer = null;\n"
        "this.text = {};\n"
        "this._textCache = {}\n"
    "}\n"
    "Canvas.prototype.resize = function(width, height) {\n"
        "if (width <= 0 || height <= 0) {\n"
            "throw new Error(\"Invalid dimensions for plot, width = \" + width + \", height = \" + height)\n"
        "}\n"
        "var element = this.element,\n"
        "context = this.context,\n"
        "pixelRatio = this.pixelRatio;\n"
        "if (this.width != width) {\n"
            "element.width = width * pixelRatio;\n"
            "element.style.width = width + \"px\";\n"
            "this.width = width\n"
        "}\n"
        "if (this.height != height) {\n"
            "element.height = height * pixelRatio;\n"
            "element.style.height = height + \"px\";\n"
            "this.height = height\n"
        "}\n"
        "context.restore();\n"
        "context.save();\n"
        "context.scale(pixelRatio, pixelRatio)\n"
    "};\n"
    "Canvas.prototype.clear = function() {\n"
        "this.context.clearRect(0, 0, this.width, this.height)\n"
    "};\n"
    "Canvas.prototype.render = function() {\n"
        "var cache = this._textCache;\n"
        "for (var layerKey in cache) {\n"
            "if (hasOwnProperty.call(cache, layerKey)) {\n"
                "var layer = this.getTextLayer(layerKey),\n"
                "layerCache = cache[layerKey];\n"
                "layer.hide();\n"
                "for (var styleKey in layerCache) {\n"
                    "if (hasOwnProperty.call(layerCache, styleKey)) {\n"
                        "var styleCache = layerCache[styleKey];\n"
                        "for (var key in styleCache) {\n"
                            "if (hasOwnProperty.call(styleCache, key)) {\n"
                                "var positions = styleCache[key].positions;\n"
                                "for (var i = 0,\n"
                                "position; position = positions[i]; i++) {\n"
                                    "if (position.active) {\n"
                                        "if (!position.rendered) {\n"
                                            "layer.append(position.element);\n"
                                            "position.rendered = true\n"
                                        "}\n"
                                    "} else {\n"
                                        "positions.splice(i--, 1);\n"
                                        "if (position.rendered) {\n"
                                            "position.element.detach()\n"
                                        "}\n"
                                    "}\n"
                                "}\n"
                                "if (positions.length == 0) {\n"
                                    "delete styleCache[key]\n"
                                "}\n"
                            "}\n"
                        "}\n"
                    "}\n"
                "}\n"
                "layer.show()\n"
            "}\n"
        "}\n"
    "};\n"
    "Canvas.prototype.getTextLayer = function(classes) {\n"
        "var layer = this.text[classes];\n"
        "if (layer == null) {\n"
            "if (this.textContainer == null) {\n"
                "this.textContainer = $(\"<div class='flot-text'></div>\").css({\n"
                    "position: \"absolute\",\n"
                    "top: 0,\n"
                    "left: 0,\n"
                    "bottom: 0,\n"
                    "right: 0,\n"
                    "\"font-size\": \"smaller\",\n"
                    "color: \"#545454\"\n"
                "}).insertAfter(this.element)\n"
            "}\n"
            "layer = this.text[classes] = $(\"<div></div>\").addClass(classes).css({\n"
                "position: \"absolute\",\n"
                "top: 0,\n"
                "left: 0,\n"
                "bottom: 0,\n"
                "right: 0\n"
            "}).appendTo(this.textContainer)\n"
        "}\n"
        "return layer\n"
    "};\n"
    "Canvas.prototype.getTextInfo = function(layer, text, font, angle, width) {\n"
        "var textStyle, layerCache, styleCache, info;\n"
        "text = \"\" + text;\n"
        "if (typeof font === \"object\") {\n"
            "textStyle = font.style + \" \" + font.variant + \" \" + font.weight + \" \" + font.size + \"px/\" + font.lineHeight + \"px \" + font.family\n"
        "} else {\n"
            "textStyle = font\n"
        "}\n"
        "layerCache = this._textCache[layer];\n"
        "if (layerCache == null) {\n"
            "layerCache = this._textCache[layer] = {}\n"
        "}\n"
        "styleCache = layerCache[textStyle];\n"
        "if (styleCache == null) {\n"
            "styleCache = layerCache[textStyle] = {}\n"
        "}\n"
        "info = styleCache[text];\n"
        "if (info == null) {\n"
            "var element = $(\"<div></div>\").html(text).css({\n"
                "position: \"absolute\",\n"
                "\"max-width\": width,\n"
                "top: -9999\n"
            "}).appendTo(this.getTextLayer(layer));\n"
            "if (typeof font === \"object\") {\n"
                "element.css({\n"
                    "font: textStyle,\n"
                    "color: font.color\n"
                "})\n"
            "} else if (typeof font === \"string\") {\n"
                "element.addClass(font)\n"
            "}\n"
            "info = styleCache[text] = {\n"
                "width: element.outerWidth(true),\n"
                "height: element.outerHeight(true),\n"
                "element: element,\n"
                "positions: []\n"
            "};\n"
            "element.detach()\n"
        "}\n"
        "return info\n"
    "};\n"
    "Canvas.prototype.addText = function(layer, x, y, text, font, angle, width, halign, valign) {\n"
        "var info = this.getTextInfo(layer, text, font, angle, width),\n"
        "positions = info.positions;\n"
        "if (halign == \"center\") {\n"
            "x -= info.width / 2\n"
        "} else if (halign == \"right\") {\n"
            "x -= info.width\n"
        "}\n"
        "if (valign == \"middle\") {\n"
            "y -= info.height / 2\n"
        "} else if (valign == \"bottom\") {\n"
            "y -= info.height\n"
        "}\n"
        "for (var i = 0,\n"
        "position; position = positions[i]; i++) {\n"
            "if (position.x == x && position.y == y) {\n"
                "position.active = true;\n"
                "return\n"
            "}\n"
        "}\n"
        "position = {\n"
            "active: true,\n"
            "rendered: false,\n"
            "element: positions.length ? info.element.clone() : info.element,\n"
            "x: x,\n"
            "y: y\n"
        "};\n"
        "positions.push(position);\n"
        "position.element.css({\n"
            "top: Math.round(y),\n"
            "left: Math.round(x),\n"
            "\"text-align\": halign\n"
        "})\n"
    "};\n"
    "Canvas.prototype.removeText = function(layer, x, y, text, font, angle) {\n"
        "if (text == null) {\n"
            "var layerCache = this._textCache[layer];\n"
            "if (layerCache != null) {\n"
                "for (var styleKey in layerCache) {\n"
                    "if (hasOwnProperty.call(layerCache, styleKey)) {\n"
                        "var styleCache = layerCache[styleKey];\n"
                        "for (var key in styleCache) {\n"
                            "if (hasOwnProperty.call(styleCache, key)) {\n"
                                "var positions = styleCache[key].positions;\n"
                                "for (var i = 0,\n"
                                "position; position = positions[i]; i++) {\n"
                                    "position.active = false\n"
                                "}\n"
                            "}\n"
                        "}\n"
                    "}\n"
                "}\n"
            "}\n"
        "} else {\n"
            "var positions = this.getTextInfo(layer, text, font, angle).positions;\n"
            "for (var i = 0,\n"
            "position; position = positions[i]; i++) {\n"
                "if (position.x == x && position.y == y) {\n"
                    "position.active = false\n"
                "}\n"
            "}\n"
        "}\n"
    "};\n"
    "function Plot(placeholder, data_, options_, plugins) {\n"
        "var series = [],\n"
        "options = {\n"
            "colors: [\"#edc240\", \"#afd8f8\", \"#cb4b4b\", \"#4da74d\", \"#9440ed\"],\n"
            "legend: {\n"
                "show: true,\n"
                "noColumns: 1,\n"
                "labelFormatter: null,\n"
                "labelBoxBorderColor: \"#ccc\",\n"
                "container: null,\n"
                "position: \"ne\",\n"
                "margin: 5,\n"
                "backgroundColor: null,\n"
                "backgroundOpacity: .85,\n"
                "sorted: null\n"
            "},\n"
            "xaxis: {\n"
                "show: null,\n"
                "position: \"bottom\",\n"
                "mode: null,\n"
                "font: null,\n"
                "color: null,\n"
                "tickColor: null,\n"
                "transform: null,\n"
                "inverseTransform: null,\n"
                "min: null,\n"
                "max: null,\n"
                "autoscaleMargin: null,\n"
                "ticks: null,\n"
                "tickFormatter: null,\n"
                "labelWidth: null,\n"
                "labelHeight: null,\n"
                "reserveSpace: null,\n"
                "tickLength: null,\n"
                "alignTicksWithAxis: null,\n"
                "tickDecimals: null,\n"
                "tickSize: null,\n"
                "minTickSize: null\n"
            "},\n"
            "yaxis: {\n"
                "autoscaleMargin: .02,\n"
                "position: \"left\"\n"
            "},\n"
            "xaxes: [],\n"
            "yaxes: [],\n"
            "series: {\n"
                "points: {\n"
                    "show: false,\n"
                    "radius: 3,\n"
                    "lineWidth: 2,\n"
                    "fill: true,\n"
                    "fillColor: \"#ffffff\",\n"
                    "symbol: \"circle\"\n"
                "},\n"
                "lines: {\n"
                    "lineWidth: 2,\n"
                    "fill: false,\n"
                    "fillColor: null,\n"
                    "steps: false\n"
                "},\n"
                "bars: {\n"
                    "show: false,\n"
                    "lineWidth: 2,\n"
                    "barWidth: 1,\n"
                    "fill: true,\n"
                    "fillColor: null,\n"
                    "align: \"left\",\n"
                    "horizontal: false,\n"
                    "zero: true\n"
                "},\n"
                "shadowSize: 3,\n"
                "highlightColor: null\n"
            "},\n"
            "grid: {\n"
                "show: true,\n"
                "aboveData: false,\n"
                "color: \"#545454\",\n"
                "backgroundColor: null,\n"
                "borderColor: null,\n"
                "tickColor: null,\n"
                "margin: 0,\n"
                "labelMargin: 5,\n"
                "axisMargin: 8,\n"
                "borderWidth: 2,\n"
                "minBorderMargin: null,\n"
                "markings: null,\n"
                "markingsColor: \"#f4f4f4\",\n"
                "markingsLineWidth: 2,\n"
                "clickable: false,\n"
                "hoverable: false,\n"
                "autoHighlight: true,\n"
                "mouseActiveRadius: 10\n"
            "},\n"
            "interaction: {\n"
                "redrawOverlayInterval: 1e3 / 60\n"
            "},\n"
            "hooks: {}\n"
        "},\n"
        "surface = null,\n"
        "overlay = null,\n"
        "eventHolder = null,\n"
        "ctx = null,\n"
        "octx = null,\n"
        "xaxes = [],\n"
        "yaxes = [],\n"
        "plotOffset = {\n"
            "left: 0,\n"
            "right: 0,\n"
            "top: 0,\n"
            "bottom: 0\n"
        "},\n"
        "plotWidth = 0,\n"
        "plotHeight = 0,\n"
        "hooks = {\n"
            "processOptions: [],\n"
            "processRawData: [],\n"
            "processDatapoints: [],\n"
            "processOffset: [],\n"
            "drawBackground: [],\n"
            "drawSeries: [],\n"
            "draw: [],\n"
            "bindEvents: [],\n"
            "drawOverlay: [],\n"
            "shutdown: []\n"
        "},\n"
        "plot = this;\n"
        "plot.setData = setData;\n"
        "plot.setupGrid = setupGrid;\n"
        "plot.draw = draw;\n"
        "plot.getPlaceholder = function() {\n"
            "return placeholder\n"
        "};\n"
        "plot.getCanvas = function() {\n"
            "return surface.element\n"
        "};\n"
        "plot.getPlotOffset = function() {\n"
            "return plotOffset\n"
        "};\n"
        "plot.width = function() {\n"
            "return plotWidth\n"
        "};\n"
        "plot.height = function() {\n"
            "return plotHeight\n"
        "};\n"
        "plot.offset = function() {\n"
            "var o = eventHolder.offset();\n"
            "o.left += plotOffset.left;\n"
            "o.top += plotOffset.top;\n"
            "return o\n"
        "};\n"
        "plot.getData = function() {\n"
            "return series\n"
        "};\n"
        "plot.getAxes = function() {\n"
            "var res = {},\n"
            "i;\n"
            "$.each(xaxes.concat(yaxes),\n"
            "function(_, axis) {\n"
                "if (axis) res[axis.direction + (axis.n != 1 ? axis.n: \"\") + \"axis\"] = axis\n"
            "});\n"
            "return res\n"
        "};\n"
        "plot.getXAxes = function() {\n"
            "return xaxes\n"
        "};\n"
        "plot.getYAxes = function() {\n"
            "return yaxes\n"
        "};\n"
        "plot.c2p = canvasToAxisCoords;\n"
        "plot.p2c = axisToCanvasCoords;\n"
        "plot.getOptions = function() {\n"
            "return options\n"
        "};\n"
        "plot.highlight = highlight;\n"
        "plot.unhighlight = unhighlight;\n"
        "plot.triggerRedrawOverlay = triggerRedrawOverlay;\n"
        "plot.pointOffset = function(point) {\n"
            "return {\n"
                "left: parseInt(xaxes[axisNumber(point, \"x\") - 1].p2c( + point.x) + plotOffset.left, 10),\n"
                "top: parseInt(yaxes[axisNumber(point, \"y\") - 1].p2c( + point.y) + plotOffset.top, 10)\n"
            "}\n"
        "};\n"
        "plot.shutdown = shutdown;\n"
        "plot.destroy = function() {\n"
            "shutdown();\n"
            "placeholder.removeData(\"plot\").empty();\n"
            "series = [];\n"
            "options = null;\n"
            "surface = null;\n"
            "overlay = null;\n"
            "eventHolder = null;\n"
            "ctx = null;\n"
            "octx = null;\n"
            "xaxes = [];\n"
            "yaxes = [];\n"
            "hooks = null;\n"
            "highlights = [];\n"
            "plot = null\n"
        "};\n"
        "plot.resize = function() {\n"
            "var width = placeholder.width(),\n"
            "height = placeholder.height();\n"
            "surface.resize(width, height);\n"
            "overlay.resize(width, height)\n"
        "};\n"
        "plot.hooks = hooks;\n"
        "initPlugins(plot);\n"
        "parseOptions(options_);\n"
        "setupCanvases();\n"
        "setData(data_);\n"
        "setupGrid();\n"
        "draw();\n"
        "bindEvents();\n"
        "function executeHooks(hook, args) {\n"
            "args = [plot].concat(args);\n"
            "for (var i = 0; i < hook.length; ++i) hook[i].apply(this, args)\n"
        "}\n"
        "function initPlugins() {\n"
            "var classes = {\n"
                "Canvas: Canvas\n"
            "};\n"
            "for (var i = 0; i < plugins.length; ++i) {\n"
                "var p = plugins[i];\n"
                "p.init(plot, classes);\n"
                "if (p.options) $.extend(true, options, p.options)\n"
            "}\n"
        "}\n"
        "function parseOptions(opts) {\n"
            "$.extend(true, options, opts);\n"
            "if (opts && opts.colors) {\n"
                "options.colors = opts.colors\n"
            "}\n"
            "if (options.xaxis.color == null) options.xaxis.color = $.color.parse(options.grid.color).scale(\"a\", .22).toString();\n"
            "if (options.yaxis.color == null) options.yaxis.color = $.color.parse(options.grid.color).scale(\"a\", .22).toString();\n"
            "if (options.xaxis.tickColor == null) options.xaxis.tickColor = options.grid.tickColor || options.xaxis.color;\n"
            "if (options.yaxis.tickColor == null) options.yaxis.tickColor = options.grid.tickColor || options.yaxis.color;\n"
            "if (options.grid.borderColor == null) options.grid.borderColor = options.grid.color;\n"
            "if (options.grid.tickColor == null) options.grid.tickColor = $.color.parse(options.grid.color).scale(\"a\", .22).toString();\n"
            "var i, axisOptions, axisCount, fontSize = placeholder.css(\"font-size\"),\n"
            "fontSizeDefault = fontSize ? +fontSize.replace(\"px\", \"\") : 13,\n"
            "fontDefaults = {\n"
                "style: placeholder.css(\"font-style\"),\n"
                "size: Math.round(.8 * fontSizeDefault),\n"
                "variant: placeholder.css(\"font-variant\"),\n"
                "weight: placeholder.css(\"font-weight\"),\n"
                "family: placeholder.css(\"font-family\")\n"
            "};\n"
            "axisCount = options.xaxes.length || 1;\n"
            "for (i = 0; i < axisCount; ++i) {\n"
                "axisOptions = options.xaxes[i];\n"
                "if (axisOptions && !axisOptions.tickColor) {\n"
                    "axisOptions.tickColor = axisOptions.color\n"
                "}\n"
                "axisOptions = $.extend(true, {},\n"
                "options.xaxis, axisOptions);\n"
                "options.xaxes[i] = axisOptions;\n"
                "if (axisOptions.font) {\n"
                    "axisOptions.font = $.extend({},\n"
                    "fontDefaults, axisOptions.font);\n"
                    "if (!axisOptions.font.color) {\n"
                        "axisOptions.font.color = axisOptions.color\n"
                    "}\n"
                    "if (!axisOptions.font.lineHeight) {\n"
                        "axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15)\n"
                    "}\n"
                "}\n"
            "}\n"
            "axisCount = options.yaxes.length || 1;\n"
            "for (i = 0; i < axisCount; ++i) {\n"
                "axisOptions = options.yaxes[i];\n"
                "if (axisOptions && !axisOptions.tickColor) {\n"
                    "axisOptions.tickColor = axisOptions.color\n"
                "}\n"
                "axisOptions = $.extend(true, {},\n"
                "options.yaxis, axisOptions);\n"
                "options.yaxes[i] = axisOptions;\n"
                "if (axisOptions.font) {\n"
                    "axisOptions.font = $.extend({},\n"
                    "fontDefaults, axisOptions.font);\n"
                    "if (!axisOptions.font.color) {\n"
                        "axisOptions.font.color = axisOptions.color\n"
                    "}\n"
                    "if (!axisOptions.font.lineHeight) {\n"
                        "axisOptions.font.lineHeight = Math.round(axisOptions.font.size * 1.15)\n"
                    "}\n"
                "}\n"
            "}\n"
            "if (options.xaxis.noTicks && options.xaxis.ticks == null) options.xaxis.ticks = options.xaxis.noTicks;\n"
            "if (options.yaxis.noTicks && options.yaxis.ticks == null) options.yaxis.ticks = options.yaxis.noTicks;\n"
            "if (options.x2axis) {\n"
                "options.xaxes[1] = $.extend(true, {},\n"
                "options.xaxis, options.x2axis);\n"
                "options.xaxes[1].position = \"top\";\n"
                "if (options.x2axis.min == null) {\n"
                    "options.xaxes[1].min = null\n"
                "}\n"
                "if (options.x2axis.max == null) {\n"
                    "options.xaxes[1].max = null\n"
                "}\n"
            "}\n"
            "if (options.y2axis) {\n"
                "options.yaxes[1] = $.extend(true, {},\n"
                "options.yaxis, options.y2axis);\n"
                "options.yaxes[1].position = \"right\";\n"
                "if (options.y2axis.min == null) {\n"
                    "options.yaxes[1].min = null\n"
                "}\n"
                "if (options.y2axis.max == null) {\n"
                    "options.yaxes[1].max = null\n"
                "}\n"
            "}\n"
            "if (options.grid.coloredAreas) options.grid.markings = options.grid.coloredAreas;\n"
            "if (options.grid.coloredAreasColor) options.grid.markingsColor = options.grid.coloredAreasColor;\n"
            "if (options.lines) $.extend(true, options.series.lines, options.lines);\n"
            "if (options.points) $.extend(true, options.series.points, options.points);\n"
            "if (options.bars) $.extend(true, options.series.bars, options.bars);\n"
            "if (options.shadowSize != null) options.series.shadowSize = options.shadowSize;\n"
            "if (options.highlightColor != null) options.series.highlightColor = options.highlightColor;\n"
            "for (i = 0; i < options.xaxes.length; ++i) getOrCreateAxis(xaxes, i + 1).options = options.xaxes[i];\n"
            "for (i = 0; i < options.yaxes.length; ++i) getOrCreateAxis(yaxes, i + 1).options = options.yaxes[i];\n"
            "for (var n in hooks) if (options.hooks[n] && options.hooks[n].length) hooks[n] = hooks[n].concat(options.hooks[n]);\n"
            "executeHooks(hooks.processOptions, [options])\n"
        "}\n"
        "function setData(d) {\n"
            "series = parseData(d);\n"
            "fillInSeriesOptions();\n"
            "processData()\n"
        "}\n"
        "function parseData(d) {\n"
            "var res = [];\n"
            "for (var i = 0; i < d.length; ++i) {\n"
                "var s = $.extend(true, {},\n"
                "options.series);\n"
                "if (d[i].data != null) {\n"
                    "s.data = d[i].data;\n"
                    "delete d[i].data;\n"
                    "$.extend(true, s, d[i]);\n"
                    "d[i].data = s.data\n"
                "} else s.data = d[i];\n"
                "res.push(s)\n"
            "}\n"
            "return res\n"
        "}\n"
        "function axisNumber(obj, coord) {\n"
            "var a = obj[coord + \"axis\"];\n"
            "if (typeof a == \"object\") a = a.n;\n"
            "if (typeof a != \"number\") a = 1;\n"
            "return a\n"
        "}\n"
        "function allAxes() {\n"
            "return $.grep(xaxes.concat(yaxes),\n"
            "function(a) {\n"
                "return a\n"
            "})\n"
        "}\n"
        "function canvasToAxisCoords(pos) {\n"
            "var res = {},\n"
            "i, axis;\n"
            "for (i = 0; i < xaxes.length; ++i) {\n"
                "axis = xaxes[i];\n"
                "if (axis && axis.used) res[\"x\" + axis.n] = axis.c2p(pos.left)\n"
            "}\n"
            "for (i = 0; i < yaxes.length; ++i) {\n"
                "axis = yaxes[i];\n"
                "if (axis && axis.used) res[\"y\" + axis.n] = axis.c2p(pos.top)\n"
            "}\n"
            "if (res.x1 !== undefined) res.x = res.x1;\n"
            "if (res.y1 !== undefined) res.y = res.y1;\n"
            "return res\n"
        "}\n"
        "function axisToCanvasCoords(pos) {\n"
            "var res = {},\n"
            "i, axis, key;\n"
            "for (i = 0; i < xaxes.length; ++i) {\n"
                "axis = xaxes[i];\n"
                "if (axis && axis.used) {\n"
                    "key = \"x\" + axis.n;\n"
                    "if (pos[key] == null && axis.n == 1) key = \"x\";\n"
                    "if (pos[key] != null) {\n"
                        "res.left = axis.p2c(pos[key]);\n"
                        "break\n"
                    "}\n"
                "}\n"
            "}\n"
            "for (i = 0; i < yaxes.length; ++i) {\n"
                "axis = yaxes[i];\n"
                "if (axis && axis.used) {\n"
                    "key = \"y\" + axis.n;\n"
                    "if (pos[key] == null && axis.n == 1) key = \"y\";\n"
                    "if (pos[key] != null) {\n"
                        "res.top = axis.p2c(pos[key]);\n"
                        "break\n"
                    "}\n"
                "}\n"
            "}\n"
            "return res\n"
        "}\n"
        "function getOrCreateAxis(axes, number) {\n"
            "if (!axes[number - 1]) axes[number - 1] = {\n"
                "n: number,\n"
                "direction: axes == xaxes ? \"x\": \"y\",\n"
                "options: $.extend(true, {},\n"
                "axes == xaxes ? options.xaxis: options.yaxis)\n"
            "};\n"
            "return axes[number - 1]\n"
        "}\n"
        "function fillInSeriesOptions() {\n"
            "var neededColors = series.length,\n"
            "maxIndex = -1,\n"
            "i;\n"
            "for (i = 0; i < series.length; ++i) {\n"
                "var sc = series[i].color;\n"
                "if (sc != null) {\n"
                    "neededColors--;\n"
                    "if (typeof sc == \"number\" && sc > maxIndex) {\n"
                        "maxIndex = sc\n"
                    "}\n"
                "}\n"
            "}\n"
            "if (neededColors <= maxIndex) {\n"
                "neededColors = maxIndex + 1\n"
            "}\n"
            "var c, colors = [],\n"
            "colorPool = options.colors,\n"
            "colorPoolSize = colorPool.length,\n"
            "variation = 0;\n"
            "for (i = 0; i < neededColors; i++) {\n"
                "c = $.color.parse(colorPool[i % colorPoolSize] || \"#666\");\n"
                "if (i % colorPoolSize == 0 && i) {\n"
                    "if (variation >= 0) {\n"
                        "if (variation < .5) {\n"
                            "variation = -variation - .2\n"
                        "} else variation = 0\n"
                    "} else variation = -variation\n"
                "}\n"
                "colors[i] = c.scale(\"rgb\", 1 + variation)\n"
            "}\n"
            "var colori = 0,\n"
            "s;\n"
            "for (i = 0; i < series.length; ++i) {\n"
                "s = series[i];\n"
                "if (s.color == null) {\n"
                    "s.color = colors[colori].toString(); ++colori\n"
                "} else if (typeof s.color == \"number\") s.color = colors[s.color].toString();\n"
                "if (s.lines.show == null) {\n"
                    "var v, show = true;\n"
                    "for (v in s) if (s[v] && s[v].show) {\n"
                        "show = false;\n"
                        "break\n"
                    "}\n"
                    "if (show) s.lines.show = true\n"
                "}\n"
                "if (s.lines.zero == null) {\n"
                    "s.lines.zero = !!s.lines.fill\n"
                "}\n"
                "s.xaxis = getOrCreateAxis(xaxes, axisNumber(s, \"x\"));\n"
                "s.yaxis = getOrCreateAxis(yaxes, axisNumber(s, \"y\"))\n"
            "}\n"
        "}\n"
        "function processData() {\n"
            "var topSentry = Number.POSITIVE_INFINITY,\n"
            "bottomSentry = Number.NEGATIVE_INFINITY,\n"
            "fakeInfinity = Number.MAX_VALUE,\n"
            "i, j, k, m, length, s, points, ps, x, y, axis, val, f, p, data, format;\n"
            "function updateAxis(axis, min, max) {\n"
                "if (min < axis.datamin && min != -fakeInfinity) axis.datamin = min;\n"
                "if (max > axis.datamax && max != fakeInfinity) axis.datamax = max\n"
            "}\n"
            "$.each(allAxes(),\n"
            "function(_, axis) {\n"
                "axis.datamin = topSentry;\n"
                "axis.datamax = bottomSentry;\n"
                "axis.used = false\n"
            "});\n"
            "for (i = 0; i < series.length; ++i) {\n"
                "s = series[i];\n"
                "s.datapoints = {\n"
                    "points: []\n"
                "};\n"
                "executeHooks(hooks.processRawData, [s, s.data, s.datapoints])\n"
            "}\n"
            "for (i = 0; i < series.length; ++i) {\n"
                "s = series[i];\n"
                "data = s.data;\n"
                "format = s.datapoints.format;\n"
                "if (!format) {\n"
                    "format = [];\n"
                    "format.push({\n"
                        "x: true,\n"
                        "number: true,\n"
                        "required: true\n"
                    "});\n"
                    "format.push({\n"
                        "y: true,\n"
                        "number: true,\n"
                        "required: true\n"
                    "});\n"
                    "if (s.bars.show || s.lines.show && s.lines.fill) {\n"
                        "var autoscale = !!(s.bars.show && s.bars.zero || s.lines.show && s.lines.zero);\n"
                        "format.push({\n"
                            "y: true,\n"
                            "number: true,\n"
                            "required: false,\n"
                            "defaultValue: 0,\n"
                            "autoscale: autoscale\n"
                        "});\n"
                        "if (s.bars.horizontal) {\n"
                            "delete format[format.length - 1].y;\n"
                            "format[format.length - 1].x = true\n"
                        "}\n"
                    "}\n"
                    "s.datapoints.format = format\n"
                "}\n"
                "if (s.datapoints.pointsize != null) continue;\n"
                "s.datapoints.pointsize = format.length;\n"
                "ps = s.datapoints.pointsize;\n"
                "points = s.datapoints.points;\n"
                "var insertSteps = s.lines.show && s.lines.steps;\n"
                "s.xaxis.used = s.yaxis.used = true;\n"
                "for (j = k = 0; j < data.length; ++j, k += ps) {\n"
                    "p = data[j];\n"
                    "var nullify = p == null;\n"
                    "if (!nullify) {\n"
                        "for (m = 0; m < ps; ++m) {\n"
                            "val = p[m];\n"
                            "f = format[m];\n"
                            "if (f) {\n"
                                "if (f.number && val != null) {\n"
                                    "val = +val;\n"
                                    "if (isNaN(val)) val = null;\n"
                                    "else if (val == Infinity) val = fakeInfinity;\n"
                                    "else if (val == -Infinity) val = -fakeInfinity\n"
                                "}\n"
                                "if (val == null) {\n"
                                    "if (f.required) nullify = true;\n"
                                    "if (f.defaultValue != null) val = f.defaultValue\n"
                                "}\n"
                            "}\n"
                            "points[k + m] = val\n"
                        "}\n"
                    "}\n"
                    "if (nullify) {\n"
                        "for (m = 0; m < ps; ++m) {\n"
                            "val = points[k + m];\n"
                            "if (val != null) {\n"
                                "f = format[m];\n"
                                "if (f.autoscale !== false) {\n"
                                    "if (f.x) {\n"
                                        "updateAxis(s.xaxis, val, val)\n"
                                    "}\n"
                                    "if (f.y) {\n"
                                        "updateAxis(s.yaxis, val, val)\n"
                                    "}\n"
                                "}\n"
                            "}\n"
                            "points[k + m] = null\n"
                        "}\n"
                    "} else {\n"
                        "if (insertSteps && k > 0 && points[k - ps] != null && points[k - ps] != points[k] && points[k - ps + 1] != points[k + 1]) {\n"
                            "for (m = 0; m < ps; ++m) points[k + ps + m] = points[k + m];\n"
                            "points[k + 1] = points[k - ps + 1];\n"
                            "k += ps\n"
                        "}\n"
                    "}\n"
                "}\n"
            "}\n"
            "for (i = 0; i < series.length; ++i) {\n"
                "s = series[i];\n"
                "executeHooks(hooks.processDatapoints, [s, s.datapoints])\n"
            "}\n"
            "for (i = 0; i < series.length; ++i) {\n"
                "s = series[i];\n"
                "points = s.datapoints.points;\n"
                "ps = s.datapoints.pointsize;\n"
                "format = s.datapoints.format;\n"
                "var xmin = topSentry,\n"
                "ymin = topSentry,\n"
                "xmax = bottomSentry,\n"
                "ymax = bottomSentry;\n"
                "for (j = 0; j < points.length; j += ps) {\n"
                    "if (points[j] == null) continue;\n"
                    "for (m = 0; m < ps; ++m) {\n"
                        "val = points[j + m];\n"
                        "f = format[m];\n"
                        "if (!f || f.autoscale === false || val == fakeInfinity || val == -fakeInfinity) continue;\n"
                        "if (f.x) {\n"
                            "if (val < xmin) xmin = val;\n"
                            "if (val > xmax) xmax = val\n"
                        "}\n"
                        "if (f.y) {\n"
                            "if (val < ymin) ymin = val;\n"
                            "if (val > ymax) ymax = val\n"
                        "}\n"
                    "}\n"
                "}\n"
                "if (s.bars.show) {\n"
                    "var delta;\n"
                    "switch (s.bars.align) {\n"
                    "case \"left\":\n"
                        "delta = 0;\n"
                        "break;\n"
                    "case \"right\":\n"
                        "delta = -s.bars.barWidth;\n"
                        "break;\n"
                    "default:\n"
                        "delta = -s.bars.barWidth / 2\n"
                    "}\n"
                    "if (s.bars.horizontal) {\n"
                        "ymin += delta;\n"
                        "ymax += delta + s.bars.barWidth\n"
                    "} else {\n"
                        "xmin += delta;\n"
                        "xmax += delta + s.bars.barWidth\n"
                    "}\n"
                "}\n"
                "updateAxis(s.xaxis, xmin, xmax);\n"
                "updateAxis(s.yaxis, ymin, ymax)\n"
            "}\n"
            "$.each(allAxes(),\n"
            "function(_, axis) {\n"
                "if (axis.datamin == topSentry) axis.datamin = null;\n"
                "if (axis.datamax == bottomSentry) axis.datamax = null\n"
            "})\n"
        "}\n"
        "function setupCanvases() {\n"
            "placeholder.css(\"padding\", 0).children().filter(function() {\n"
                "return ! $(this).hasClass(\"flot-overlay\") && !$(this).hasClass(\"flot-base\")\n"
            "}).remove();\n"
            "if (placeholder.css(\"position\") == \"static\") placeholder.css(\"position\", \"relative\");\n"
            "surface = new Canvas(\"flot-base\", placeholder);\n"
            "overlay = new Canvas(\"flot-overlay\", placeholder);\n"
            "ctx = surface.context;\n"
            "octx = overlay.context;\n"
            "eventHolder = $(overlay.element).unbind();\n"
            "var existing = placeholder.data(\"plot\");\n"
            "if (existing) {\n"
                "existing.shutdown();\n"
                "overlay.clear()\n"
            "}\n"
            "placeholder.data(\"plot\", plot)\n"
        "}\n"
        "function bindEvents() {\n"
            "if (options.grid.hoverable) {\n"
                "eventHolder.mousemove(onMouseMove);\n"
                "eventHolder.bind(\"mouseleave\", onMouseLeave)\n"
            "}\n"
            "if (options.grid.clickable) eventHolder.click(onClick);\n"
            "executeHooks(hooks.bindEvents, [eventHolder])\n"
        "}\n"
        "function shutdown() {\n"
            "if (redrawTimeout) clearTimeout(redrawTimeout);\n"
            "eventHolder.unbind(\"mousemove\", onMouseMove);\n"
            "eventHolder.unbind(\"mouseleave\", onMouseLeave);\n"
            "eventHolder.unbind(\"click\", onClick);\n"
            "executeHooks(hooks.shutdown, [eventHolder])\n"
        "}\n"
        "function setTransformationHelpers(axis) {\n"
            "function identity(x) {\n"
                "return x\n"
            "}\n"
            "var s, m, t = axis.options.transform || identity,\n"
            "it = axis.options.inverseTransform;\n"
            "if (axis.direction == \"x\") {\n"
                "s = axis.scale = plotWidth / Math.abs(t(axis.max) - t(axis.min));\n"
                "m = Math.min(t(axis.max), t(axis.min))\n"
            "} else {\n"
                "s = axis.scale = plotHeight / Math.abs(t(axis.max) - t(axis.min));\n"
                "s = -s;\n"
                "m = Math.max(t(axis.max), t(axis.min))\n"
            "}\n"
            "if (t == identity) axis.p2c = function(p) {\n"
                "return (p - m) * s\n"
            "};\n"
            "else axis.p2c = function(p) {\n"
                "return (t(p) - m) * s\n"
            "};\n"
            "if (!it) axis.c2p = function(c) {\n"
                "return m + c / s\n"
            "};\n"
            "else axis.c2p = function(c) {\n"
                "return it(m + c / s)\n"
            "}\n"
        "}\n"
        "function measureTickLabels(axis) {\n"
            "var opts = axis.options,\n"
            "ticks = axis.ticks || [],\n"
            "labelWidth = opts.labelWidth || 0,\n"
            "labelHeight = opts.labelHeight || 0,\n"
            "maxWidth = labelWidth || (axis.direction == \"x\" ? Math.floor(surface.width / (ticks.length || 1)) : null),\n"
            "legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n"
            "layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n"
            "font = opts.font || \"flot-tick-label tickLabel\";\n"
            "for (var i = 0; i < ticks.length; ++i) {\n"
                "var t = ticks[i];\n"
                "if (!t.label) continue;\n"
                "var info = surface.getTextInfo(layer, t.label, font, null, maxWidth);\n"
                "labelWidth = Math.max(labelWidth, info.width);\n"
                "labelHeight = Math.max(labelHeight, info.height)\n"
            "}\n"
            "axis.labelWidth = opts.labelWidth || labelWidth;\n"
            "axis.labelHeight = opts.labelHeight || labelHeight\n"
        "}\n"
        "function allocateAxisBoxFirstPhase(axis) {\n"
            "var lw = axis.labelWidth,\n"
            "lh = axis.labelHeight,\n"
            "pos = axis.options.position,\n"
            "isXAxis = axis.direction === \"x\",\n"
            "tickLength = axis.options.tickLength,\n"
            "axisMargin = options.grid.axisMargin,\n"
            "padding = options.grid.labelMargin,\n"
            "innermost = true,\n"
            "outermost = true,\n"
            "first = true,\n"
            "found = false;\n"
            "$.each(isXAxis ? xaxes: yaxes,\n"
            "function(i, a) {\n"
                "if (a && (a.show || a.reserveSpace)) {\n"
                    "if (a === axis) {\n"
                        "found = true\n"
                    "} else if (a.options.position === pos) {\n"
                        "if (found) {\n"
                            "outermost = false\n"
                        "} else {\n"
                            "innermost = false\n"
                        "}\n"
                    "}\n"
                    "if (!found) {\n"
                        "first = false\n"
                    "}\n"
                "}\n"
            "});\n"
            "if (outermost) {\n"
                "axisMargin = 0\n"
            "}\n"
            "if (tickLength == null) {\n"
                "tickLength = first ? \"full\": 5\n"
            "}\n"
            "if (!isNaN( + tickLength)) padding += +tickLength;\n"
            "if (isXAxis) {\n"
                "lh += padding;\n"
                "if (pos == \"bottom\") {\n"
                    "plotOffset.bottom += lh + axisMargin;\n"
                    "axis.box = {\n"
                        "top: surface.height - plotOffset.bottom,\n"
                        "height: lh\n"
                    "}\n"
                "} else {\n"
                    "axis.box = {\n"
                        "top: plotOffset.top + axisMargin,\n"
                        "height: lh\n"
                    "};\n"
                    "plotOffset.top += lh + axisMargin\n"
                "}\n"
            "} else {\n"
                "lw += padding;\n"
                "if (pos == \"left\") {\n"
                    "axis.box = {\n"
                        "left: plotOffset.left + axisMargin,\n"
                        "width: lw\n"
                    "};\n"
                    "plotOffset.left += lw + axisMargin\n"
                "} else {\n"
                    "plotOffset.right += lw + axisMargin;\n"
                    "axis.box = {\n"
                        "left: surface.width - plotOffset.right,\n"
                        "width: lw\n"
                    "}\n"
                "}\n"
            "}\n"
            "axis.position = pos;\n"
            "axis.tickLength = tickLength;\n"
            "axis.box.padding = padding;\n"
            "axis.innermost = innermost\n"
        "}\n"
        "function allocateAxisBoxSecondPhase(axis) {\n"
            "if (axis.direction == \"x\") {\n"
                "axis.box.left = plotOffset.left - axis.labelWidth / 2;\n"
                "axis.box.width = surface.width - plotOffset.left - plotOffset.right + axis.labelWidth\n"
            "} else {\n"
                "axis.box.top = plotOffset.top - axis.labelHeight / 2;\n"
                "axis.box.height = surface.height - plotOffset.bottom - plotOffset.top + axis.labelHeight\n"
            "}\n"
        "}\n"
        "function adjustLayoutForThingsStickingOut() {\n"
            "var minMargin = options.grid.minBorderMargin,\n"
            "axis, i;\n"
            "if (minMargin == null) {\n"
                "minMargin = 0;\n"
                "for (i = 0; i < series.length; ++i) minMargin = Math.max(minMargin, 2 * (series[i].points.radius + series[i].points.lineWidth / 2))\n"
            "}\n"
            "var margins = {\n"
                "left: minMargin,\n"
                "right: minMargin,\n"
                "top: minMargin,\n"
                "bottom: minMargin\n"
            "};\n"
            "$.each(allAxes(),\n"
            "function(_, axis) {\n"
                "if (axis.reserveSpace && axis.ticks && axis.ticks.length) {\n"
                    "if (axis.direction === \"x\") {\n"
                        "margins.left = Math.max(margins.left, axis.labelWidth / 2);\n"
                        "margins.right = Math.max(margins.right, axis.labelWidth / 2)\n"
                    "} else {\n"
                        "margins.bottom = Math.max(margins.bottom, axis.labelHeight / 2);\n"
                        "margins.top = Math.max(margins.top, axis.labelHeight / 2)\n"
                    "}\n"
                "}\n"
            "});\n"
            "plotOffset.left = Math.ceil(Math.max(margins.left, plotOffset.left));\n"
            "plotOffset.right = Math.ceil(Math.max(margins.right, plotOffset.right));\n"
            "plotOffset.top = Math.ceil(Math.max(margins.top, plotOffset.top));\n"
            "plotOffset.bottom = Math.ceil(Math.max(margins.bottom, plotOffset.bottom))\n"
        "}\n"
        "function setupGrid() {\n"
            "var i, axes = allAxes(),\n"
            "showGrid = options.grid.show;\n"
            "for (var a in plotOffset) {\n"
                "var margin = options.grid.margin || 0;\n"
                "plotOffset[a] = typeof margin == \"number\" ? margin: margin[a] || 0\n"
            "}\n"
            "executeHooks(hooks.processOffset, [plotOffset]);\n"
            "for (var a in plotOffset) {\n"
                "if (typeof options.grid.borderWidth == \"object\") {\n"
                    "plotOffset[a] += showGrid ? options.grid.borderWidth[a] : 0\n"
                "} else {\n"
                    "plotOffset[a] += showGrid ? options.grid.borderWidth: 0\n"
                "}\n"
            "}\n"
            "$.each(axes,\n"
            "function(_, axis) {\n"
                "var axisOpts = axis.options;\n"
                "axis.show = axisOpts.show == null ? axis.used: axisOpts.show;\n"
                "axis.reserveSpace = axisOpts.reserveSpace == null ? axis.show: axisOpts.reserveSpace;\n"
                "setRange(axis)\n"
            "});\n"
            "if (showGrid) {\n"
                "var allocatedAxes = $.grep(axes,\n"
                "function(axis) {\n"
                    "return axis.show || axis.reserveSpace\n"
                "});\n"
                "$.each(allocatedAxes,\n"
                "function(_, axis) {\n"
                    "setupTickGeneration(axis);\n"
                    "setTicks(axis);\n"
                    "snapRangeToTicks(axis, axis.ticks);\n"
                    "measureTickLabels(axis)\n"
                "});\n"
                "for (i = allocatedAxes.length - 1; i >= 0; --i) allocateAxisBoxFirstPhase(allocatedAxes[i]);\n"
                "adjustLayoutForThingsStickingOut();\n"
                "$.each(allocatedAxes,\n"
                "function(_, axis) {\n"
                    "allocateAxisBoxSecondPhase(axis)\n"
                "})\n"
            "}\n"
            "plotWidth = surface.width - plotOffset.left - plotOffset.right;\n"
            "plotHeight = surface.height - plotOffset.bottom - plotOffset.top;\n"
            "$.each(axes,\n"
            "function(_, axis) {\n"
                "setTransformationHelpers(axis)\n"
            "});\n"
            "if (showGrid) {\n"
                "drawAxisLabels()\n"
            "}\n"
            "insertLegend()\n"
        "}\n"
        "function setRange(axis) {\n"
            "var opts = axis.options,\n"
            "min = +(opts.min != null ? opts.min: axis.datamin),\n"
            "max = +(opts.max != null ? opts.max: axis.datamax),\n"
            "delta = max - min;\n"
            "if (delta == 0) {\n"
                "var widen = max == 0 ? 1 : .01;\n"
                "if (opts.min == null) min -= widen;\n"
                "if (opts.max == null || opts.min != null) max += widen\n"
            "} else {\n"
                "var margin = opts.autoscaleMargin;\n"
                "if (margin != null) {\n"
                    "if (opts.min == null) {\n"
                        "min -= delta * margin;\n"
                        "if (min < 0 && axis.datamin != null && axis.datamin >= 0) min = 0\n"
                    "}\n"
                    "if (opts.max == null) {\n"
                        "max += delta * margin;\n"
                        "if (max > 0 && axis.datamax != null && axis.datamax <= 0) max = 0\n"
                    "}\n"
                "}\n"
            "}\n"
            "axis.min = min;\n"
            "axis.max = max\n"
        "}\n"
        "function setupTickGeneration(axis) {\n"
            "var opts = axis.options;\n"
            "var noTicks;\n"
            "if (typeof opts.ticks == \"number\" && opts.ticks > 0) noTicks = opts.ticks;\n"
            "else noTicks = .3 * Math.sqrt(axis.direction == \"x\" ? surface.width: surface.height);\n"
            "var delta = (axis.max - axis.min) / noTicks,\n"
            "dec = -Math.floor(Math.log(delta) / Math.LN10),\n"
            "maxDec = opts.tickDecimals;\n"
            "if (maxDec != null && dec > maxDec) {\n"
                "dec = maxDec\n"
            "}\n"
            "var magn = Math.pow(10, -dec),\n"
            "norm = delta / magn,\n"
            "size;\n"
            "if (norm < 1.5) {\n"
                "size = 1\n"
            "} else if (norm < 3) {\n"
                "size = 2;\n"
                "if (norm > 2.25 && (maxDec == null || dec + 1 <= maxDec)) {\n"
                    "size = 2.5; ++dec\n"
                "}\n"
            "} else if (norm < 7.5) {\n"
                "size = 5\n"
            "} else {\n"
                "size = 10\n"
            "}\n"
            "size *= magn;\n"
            "if (opts.minTickSize != null && size < opts.minTickSize) {\n"
                "size = opts.minTickSize\n"
            "}\n"
            "axis.delta = delta;\n"
            "axis.tickDecimals = Math.max(0, maxDec != null ? maxDec: dec);\n"
            "axis.tickSize = opts.tickSize || size;\n"
            "if (opts.mode == \"time\" && !axis.tickGenerator) {\n"
                "throw new Error(\"Time mode requires the flot.time plugin.\")\n"
            "}\n"
            "if (!axis.tickGenerator) {\n"
                "axis.tickGenerator = function(axis) {\n"
                    "var ticks = [],\n"
                    "start = floorInBase(axis.min, axis.tickSize),\n"
                    "i = 0,\n"
                    "v = Number.NaN,\n"
                    "prev;\n"
                    "do {\n"
                        "prev = v;\n"
                        "v = start + i * axis.tickSize;\n"
                        "ticks.push(v); ++i\n"
                    "} while ( v < axis . max && v != prev );\n"
                    "return ticks\n"
                "};\n"
                "axis.tickFormatter = function(value, axis) {\n"
                    "var factor = axis.tickDecimals ? Math.pow(10, axis.tickDecimals) : 1;\n"
                    "var formatted = \"\" + Math.round(value * factor) / factor;\n"
                    "if (axis.tickDecimals != null) {\n"
                        "var decimal = formatted.indexOf(\".\");\n"
                        "var precision = decimal == -1 ? 0 : formatted.length - decimal - 1;\n"
                        "if (precision < axis.tickDecimals) {\n"
                            "return (precision ? formatted: formatted + \".\") + (\"\" + factor).substr(1, axis.tickDecimals - precision)\n"
                        "}\n"
                    "}\n"
                    "return formatted\n"
                "}\n"
            "}\n"
            "if ($.isFunction(opts.tickFormatter)) axis.tickFormatter = function(v, axis) {\n"
                "return \"\" + opts.tickFormatter(v, axis)\n"
            "};\n"
            "if (opts.alignTicksWithAxis != null) {\n"
                "var otherAxis = (axis.direction == \"x\" ? xaxes: yaxes)[opts.alignTicksWithAxis - 1];\n"
                "if (otherAxis && otherAxis.used && otherAxis != axis) {\n"
                    "var niceTicks = axis.tickGenerator(axis);\n"
                    "if (niceTicks.length > 0) {\n"
                        "if (opts.min == null) axis.min = Math.min(axis.min, niceTicks[0]);\n"
                        "if (opts.max == null && niceTicks.length > 1) axis.max = Math.max(axis.max, niceTicks[niceTicks.length - 1])\n"
                    "}\n"
                    "axis.tickGenerator = function(axis) {\n"
                        "var ticks = [],\n"
                        "v,\n"
                        "i;\n"
                        "for (i = 0; i < otherAxis.ticks.length; ++i) {\n"
                            "v = (otherAxis.ticks[i].v - otherAxis.min) / (otherAxis.max - otherAxis.min);\n"
                            "v = axis.min + v * (axis.max - axis.min);\n"
                            "ticks.push(v)\n"
                        "}\n"
                        "return ticks\n"
                    "};\n"
                    "if (!axis.mode && opts.tickDecimals == null) {\n"
                        "var extraDec = Math.max(0, -Math.floor(Math.log(axis.delta) / Math.LN10) + 1),\n"
                        "ts = axis.tickGenerator(axis);\n"
                        "if (! (ts.length > 1 && /\\..*0$/.test((ts[1] - ts[0]).toFixed(extraDec)))) axis.tickDecimals = extraDec\n"
                    "}\n"
                "}\n"
            "}\n"
        "}\n"
        "function setTicks(axis) {\n"
            "var oticks = axis.options.ticks,\n"
            "ticks = [];\n"
            "if (oticks == null || typeof oticks == \"number\" && oticks > 0) ticks = axis.tickGenerator(axis);\n"
            "else if (oticks) {\n"
                "if ($.isFunction(oticks)) ticks = oticks(axis);\n"
                "else ticks = oticks\n"
            "}\n"
            "var i, v;\n"
            "axis.ticks = [];\n"
            "for (i = 0; i < ticks.length; ++i) {\n"
                "var label = null;\n"
                "var t = ticks[i];\n"
                "if (typeof t == \"object\") {\n"
                    "v = +t[0];\n"
                    "if (t.length > 1) label = t[1]\n"
                "} else v = +t;\n"
                "if (label == null) label = axis.tickFormatter(v, axis);\n"
                "if (!isNaN(v)) axis.ticks.push({\n"
                    "v: v,\n"
                    "label: label\n"
                "})\n"
            "}\n"
        "}\n"
        "function snapRangeToTicks(axis, ticks) {\n"
            "if (axis.options.autoscaleMargin && ticks.length > 0) {\n"
                "if (axis.options.min == null) axis.min = Math.min(axis.min, ticks[0].v);\n"
                "if (axis.options.max == null && ticks.length > 1) axis.max = Math.max(axis.max, ticks[ticks.length - 1].v)\n"
            "}\n"
        "}\n"
        "function draw() {\n"
            "surface.clear();\n"
            "executeHooks(hooks.drawBackground, [ctx]);\n"
            "var grid = options.grid;\n"
            "if (grid.show && grid.backgroundColor) drawBackground();\n"
            "if (grid.show && !grid.aboveData) {\n"
                "drawGrid()\n"
            "}\n"
            "for (var i = 0; i < series.length; ++i) {\n"
                "executeHooks(hooks.drawSeries, [ctx, series[i]]);\n"
                "drawSeries(series[i])\n"
            "}\n"
            "executeHooks(hooks.draw, [ctx]);\n"
            "if (grid.show && grid.aboveData) {\n"
                "drawGrid()\n"
            "}\n"
            "surface.render();\n"
            "triggerRedrawOverlay()\n"
        "}\n"
        "function extractRange(ranges, coord) {\n"
            "var axis, from, to, key, axes = allAxes();\n"
            "for (var i = 0; i < axes.length; ++i) {\n"
                "axis = axes[i];\n"
                "if (axis.direction == coord) {\n"
                    "key = coord + axis.n + \"axis\";\n"
                    "if (!ranges[key] && axis.n == 1) key = coord + \"axis\";\n"
                    "if (ranges[key]) {\n"
                        "from = ranges[key].from;\n"
                        "to = ranges[key].to;\n"
                        "break\n"
                    "}\n"
                "}\n"
            "}\n"
            "if (!ranges[key]) {\n"
                "axis = coord == \"x\" ? xaxes[0] : yaxes[0];\n"
                "from = ranges[coord + \"1\"];\n"
                "to = ranges[coord + \"2\"]\n"
            "}\n"
            "if (from != null && to != null && from > to) {\n"
                "var tmp = from;\n"
                "from = to;\n"
                "to = tmp\n"
            "}\n"
            "return {\n"
                "from: from,\n"
                "to: to,\n"
                "axis: axis\n"
            "}\n"
        "}\n"
        "function drawBackground() {\n"
            "ctx.save();\n"
            "ctx.translate(plotOffset.left, plotOffset.top);\n"
            "ctx.fillStyle = getColorOrGradient(options.grid.backgroundColor, plotHeight, 0, \"rgba(255, 255, 255, 0)\");\n"
            "ctx.fillRect(0, 0, plotWidth, plotHeight);\n"
            "ctx.restore()\n"
        "}\n"
        "function drawGrid() {\n"
            "var i, axes, bw, bc;\n"
            "ctx.save();\n"
            "ctx.translate(plotOffset.left, plotOffset.top);\n"
            "var markings = options.grid.markings;\n"
            "if (markings) {\n"
                "if ($.isFunction(markings)) {\n"
                    "axes = plot.getAxes();\n"
                    "axes.xmin = axes.xaxis.min;\n"
                    "axes.xmax = axes.xaxis.max;\n"
                    "axes.ymin = axes.yaxis.min;\n"
                    "axes.ymax = axes.yaxis.max;\n"
                    "markings = markings(axes)\n"
                "}\n"
                "for (i = 0; i < markings.length; ++i) {\n"
                    "var m = markings[i],\n"
                    "xrange = extractRange(m, \"x\"),\n"
                    "yrange = extractRange(m, \"y\");\n"
                    "if (xrange.from == null) xrange.from = xrange.axis.min;\n"
                    "if (xrange.to == null) xrange.to = xrange.axis.max;\n"
                    "if (yrange.from == null) yrange.from = yrange.axis.min;\n"
                    "if (yrange.to == null) yrange.to = yrange.axis.max;\n"
                    "if (xrange.to < xrange.axis.min || xrange.from > xrange.axis.max || yrange.to < yrange.axis.min || yrange.from > yrange.axis.max) continue;\n"
                    "xrange.from = Math.max(xrange.from, xrange.axis.min);\n"
                    "xrange.to = Math.min(xrange.to, xrange.axis.max);\n"
                    "yrange.from = Math.max(yrange.from, yrange.axis.min);\n"
                    "yrange.to = Math.min(yrange.to, yrange.axis.max);\n"
                    "var xequal = xrange.from === xrange.to,\n"
                    "yequal = yrange.from === yrange.to;\n"
                    "if (xequal && yequal) {\n"
                        "continue\n"
                    "}\n"
                    "xrange.from = Math.floor(xrange.axis.p2c(xrange.from));\n"
                    "xrange.to = Math.floor(xrange.axis.p2c(xrange.to));\n"
                    "yrange.from = Math.floor(yrange.axis.p2c(yrange.from));\n"
                    "yrange.to = Math.floor(yrange.axis.p2c(yrange.to));\n"
                    "if (xequal || yequal) {\n"
                        "var lineWidth = m.lineWidth || options.grid.markingsLineWidth,\n"
                        "subPixel = lineWidth % 2 ? .5 : 0;\n"
                        "ctx.beginPath();\n"
                        "ctx.strokeStyle = m.color || options.grid.markingsColor;\n"
                        "ctx.lineWidth = lineWidth;\n"
                        "if (xequal) {\n"
                            "ctx.moveTo(xrange.to + subPixel, yrange.from);\n"
                            "ctx.lineTo(xrange.to + subPixel, yrange.to)\n"
                        "} else {\n"
                            "ctx.moveTo(xrange.from, yrange.to + subPixel);\n"
                            "ctx.lineTo(xrange.to, yrange.to + subPixel)\n"
                        "}\n"
                        "ctx.stroke()\n"
                    "} else {\n"
                        "ctx.fillStyle = m.color || options.grid.markingsColor;\n"
                        "ctx.fillRect(xrange.from, yrange.to, xrange.to - xrange.from, yrange.from - yrange.to)\n"
                    "}\n"
                "}\n"
            "}\n"
            "axes = allAxes();\n"
            "bw = options.grid.borderWidth;\n"
            "for (var j = 0; j < axes.length; ++j) {\n"
                "var axis = axes[j],\n"
                "box = axis.box,\n"
                "t = axis.tickLength,\n"
                "x,\n"
                "y,\n"
                "xoff,\n"
                "yoff;\n"
                "if (!axis.show || axis.ticks.length == 0) continue;\n"
                "ctx.lineWidth = 1;\n"
                "if (axis.direction == \"x\") {\n"
                    "x = 0;\n"
                    "if (t == \"full\") y = axis.position == \"top\" ? 0 : plotHeight;\n"
                    "else y = box.top - plotOffset.top + (axis.position == \"top\" ? box.height: 0)\n"
                "} else {\n"
                    "y = 0;\n"
                    "if (t == \"full\") x = axis.position == \"left\" ? 0 : plotWidth;\n"
                    "else x = box.left - plotOffset.left + (axis.position == \"left\" ? box.width: 0)\n"
                "}\n"
                "if (!axis.innermost) {\n"
                    "ctx.strokeStyle = axis.options.color;\n"
                    "ctx.beginPath();\n"
                    "xoff = yoff = 0;\n"
                    "if (axis.direction == \"x\") xoff = plotWidth + 1;\n"
                    "else yoff = plotHeight + 1;\n"
                    "if (ctx.lineWidth == 1) {\n"
                        "if (axis.direction == \"x\") {\n"
                            "y = Math.floor(y) + .5\n"
                        "} else {\n"
                            "x = Math.floor(x) + .5\n"
                        "}\n"
                    "}\n"
                    "ctx.moveTo(x, y);\n"
                    "ctx.lineTo(x + xoff, y + yoff);\n"
                    "ctx.stroke()\n"
                "}\n"
                "ctx.strokeStyle = axis.options.tickColor;\n"
                "ctx.beginPath();\n"
                "for (i = 0; i < axis.ticks.length; ++i) {\n"
                    "var v = axis.ticks[i].v;\n"
                    "xoff = yoff = 0;\n"
                    "if (isNaN(v) || v < axis.min || v > axis.max || t == \"full\" && (typeof bw == \"object\" && bw[axis.position] > 0 || bw > 0) && (v == axis.min || v == axis.max)) continue;\n"
                    "if (axis.direction == \"x\") {\n"
                        "x = axis.p2c(v);\n"
                        "yoff = t == \"full\" ? -plotHeight: t;\n"
                        "if (axis.position == \"top\") yoff = -yoff\n"
                    "} else {\n"
                        "y = axis.p2c(v);\n"
                        "xoff = t == \"full\" ? -plotWidth: t;\n"
                        "if (axis.position == \"left\") xoff = -xoff\n"
                    "}\n"
                    "if (ctx.lineWidth == 1) {\n"
                        "if (axis.direction == \"x\") x = Math.floor(x) + .5;\n"
                        "else y = Math.floor(y) + .5\n"
                    "}\n"
                    "ctx.moveTo(x, y);\n"
                    "ctx.lineTo(x + xoff, y + yoff)\n"
                "}\n"
                "ctx.stroke()\n"
            "}\n"
            "if (bw) {\n"
                "bc = options.grid.borderColor;\n"
                "if (typeof bw == \"object\" || typeof bc == \"object\") {\n"
                    "if (typeof bw !== \"object\") {\n"
                        "bw = {\n"
                            "top: bw,\n"
                            "right: bw,\n"
                            "bottom: bw,\n"
                            "left: bw\n"
                        "}\n"
                    "}\n"
                    "if (typeof bc !== \"object\") {\n"
                        "bc = {\n"
                            "top: bc,\n"
                            "right: bc,\n"
                            "bottom: bc,\n"
                            "left: bc\n"
                        "}\n"
                    "}\n"
                    "if (bw.top > 0) {\n"
                        "ctx.strokeStyle = bc.top;\n"
                        "ctx.lineWidth = bw.top;\n"
                        "ctx.beginPath();\n"
                        "ctx.moveTo(0 - bw.left, 0 - bw.top / 2);\n"
                        "ctx.lineTo(plotWidth, 0 - bw.top / 2);\n"
                        "ctx.stroke()\n"
                    "}\n"
                    "if (bw.right > 0) {\n"
                        "ctx.strokeStyle = bc.right;\n"
                        "ctx.lineWidth = bw.right;\n"
                        "ctx.beginPath();\n"
                        "ctx.moveTo(plotWidth + bw.right / 2, 0 - bw.top);\n"
                        "ctx.lineTo(plotWidth + bw.right / 2, plotHeight);\n"
                        "ctx.stroke()\n"
                    "}\n"
                    "if (bw.bottom > 0) {\n"
                        "ctx.strokeStyle = bc.bottom;\n"
                        "ctx.lineWidth = bw.bottom;\n"
                        "ctx.beginPath();\n"
                        "ctx.moveTo(plotWidth + bw.right, plotHeight + bw.bottom / 2);\n"
                        "ctx.lineTo(0, plotHeight + bw.bottom / 2);\n"
                        "ctx.stroke()\n"
                    "}\n"
                    "if (bw.left > 0) {\n"
                        "ctx.strokeStyle = bc.left;\n"
                        "ctx.lineWidth = bw.left;\n"
                        "ctx.beginPath();\n"
                        "ctx.moveTo(0 - bw.left / 2, plotHeight + bw.bottom);\n"
                        "ctx.lineTo(0 - bw.left / 2, 0);\n"
                        "ctx.stroke()\n"
                    "}\n"
                "} else {\n"
                    "ctx.lineWidth = bw;\n"
                    "ctx.strokeStyle = options.grid.borderColor;\n"
                    "ctx.strokeRect( - bw / 2, -bw / 2, plotWidth + bw, plotHeight + bw)\n"
                "}\n"
            "}\n"
            "ctx.restore()\n"
        "}\n"
        "function drawAxisLabels() {\n"
            "$.each(allAxes(),\n"
            "function(_, axis) {\n"
                "var box = axis.box,\n"
                "legacyStyles = axis.direction + \"Axis \" + axis.direction + axis.n + \"Axis\",\n"
                "layer = \"flot-\" + axis.direction + \"-axis flot-\" + axis.direction + axis.n + \"-axis \" + legacyStyles,\n"
                "font = axis.options.font || \"flot-tick-label tickLabel\",\n"
                "tick, x, y, halign, valign;\n"
                "surface.removeText(layer);\n"
                "if (!axis.show || axis.ticks.length == 0) return;\n"
                "for (var i = 0; i < axis.ticks.length; ++i) {\n"
                    "tick = axis.ticks[i];\n"
                    "if (!tick.label || tick.v < axis.min || tick.v > axis.max) continue;\n"
                    "if (axis.direction == \"x\") {\n"
                        "halign = \"center\";\n"
                        "x = plotOffset.left + axis.p2c(tick.v);\n"
                        "if (axis.position == \"bottom\") {\n"
                            "y = box.top + box.padding\n"
                        "} else {\n"
                            "y = box.top + box.height - box.padding;\n"
                            "valign = \"bottom\"\n"
                        "}\n"
                    "} else {\n"
                        "valign = \"middle\";\n"
                        "y = plotOffset.top + axis.p2c(tick.v);\n"
                        "if (axis.position == \"left\") {\n"
                            "x = box.left + box.width - box.padding;\n"
                            "halign = \"right\"\n"
                        "} else {\n"
                            "x = box.left + box.padding\n"
                        "}\n"
                    "}\n"
                    "surface.addText(layer, x, y, tick.label, font, null, null, halign, valign)\n"
                "}\n"
            "})\n"
        "}\n"
        "function drawSeries(series) {\n"
            "if (series.lines.show) drawSeriesLines(series);\n"
            "if (series.bars.show) drawSeriesBars(series);\n"
            "if (series.points.show) drawSeriesPoints(series)\n"
        "}\n"
        "function drawSeriesLines(series) {\n"
            "function plotLine(datapoints, xoffset, yoffset, axisx, axisy) {\n"
                "var points = datapoints.points,\n"
                "ps = datapoints.pointsize,\n"
                "prevx = null,\n"
                "prevy = null;\n"
                "ctx.beginPath();\n"
                "for (var i = ps; i < points.length; i += ps) {\n"
                    "var x1 = points[i - ps],\n"
                    "y1 = points[i - ps + 1],\n"
                    "x2 = points[i],\n"
                    "y2 = points[i + 1];\n"
                    "if (x1 == null || x2 == null) continue;\n"
                    "if (y1 <= y2 && y1 < axisy.min) {\n"
                        "if (y2 < axisy.min) continue;\n"
                        "x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n"
                        "y1 = axisy.min\n"
                    "} else if (y2 <= y1 && y2 < axisy.min) {\n"
                        "if (y1 < axisy.min) continue;\n"
                        "x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n"
                        "y2 = axisy.min\n"
                    "}\n"
                    "if (y1 >= y2 && y1 > axisy.max) {\n"
                        "if (y2 > axisy.max) continue;\n"
                        "x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n"
                        "y1 = axisy.max\n"
                    "} else if (y2 >= y1 && y2 > axisy.max) {\n"
                        "if (y1 > axisy.max) continue;\n"
                        "x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n"
                        "y2 = axisy.max\n"
                    "}\n"
                    "if (x1 <= x2 && x1 < axisx.min) {\n"
                        "if (x2 < axisx.min) continue;\n"
                        "y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n"
                        "x1 = axisx.min\n"
                    "} else if (x2 <= x1 && x2 < axisx.min) {\n"
                        "if (x1 < axisx.min) continue;\n"
                        "y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n"
                        "x2 = axisx.min\n"
                    "}\n"
                    "if (x1 >= x2 && x1 > axisx.max) {\n"
                        "if (x2 > axisx.max) continue;\n"
                        "y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n"
                        "x1 = axisx.max\n"
                    "} else if (x2 >= x1 && x2 > axisx.max) {\n"
                        "if (x1 > axisx.max) continue;\n"
                        "y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n"
                        "x2 = axisx.max\n"
                    "}\n"
                    "if (x1 != prevx || y1 != prevy) ctx.moveTo(axisx.p2c(x1) + xoffset, axisy.p2c(y1) + yoffset);\n"
                    "prevx = x2;\n"
                    "prevy = y2;\n"
                    "ctx.lineTo(axisx.p2c(x2) + xoffset, axisy.p2c(y2) + yoffset)\n"
                "}\n"
                "ctx.stroke()\n"
            "}\n"
            "function plotLineArea(datapoints, axisx, axisy) {\n"
                "var points = datapoints.points,\n"
                "ps = datapoints.pointsize,\n"
                "bottom = Math.min(Math.max(0, axisy.min), axisy.max),\n"
                "i = 0,\n"
                "top,\n"
                "areaOpen = false,\n"
                "ypos = 1,\n"
                "segmentStart = 0,\n"
                "segmentEnd = 0;\n"
                "while (true) {\n"
                    "if (ps > 0 && i > points.length + ps) break;\n"
                    "i += ps;\n"
                    "var x1 = points[i - ps],\n"
                    "y1 = points[i - ps + ypos],\n"
                    "x2 = points[i],\n"
                    "y2 = points[i + ypos];\n"
                    "if (areaOpen) {\n"
                        "if (ps > 0 && x1 != null && x2 == null) {\n"
                            "segmentEnd = i;\n"
                            "ps = -ps;\n"
                            "ypos = 2;\n"
                            "continue\n"
                        "}\n"
                        "if (ps < 0 && i == segmentStart + ps) {\n"
                            "ctx.fill();\n"
                            "areaOpen = false;\n"
                            "ps = -ps;\n"
                            "ypos = 1;\n"
                            "i = segmentStart = segmentEnd + ps;\n"
                            "continue\n"
                        "}\n"
                    "}\n"
                    "if (x1 == null || x2 == null) continue;\n"
                    "if (x1 <= x2 && x1 < axisx.min) {\n"
                        "if (x2 < axisx.min) continue;\n"
                        "y1 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n"
                        "x1 = axisx.min\n"
                    "} else if (x2 <= x1 && x2 < axisx.min) {\n"
                        "if (x1 < axisx.min) continue;\n"
                        "y2 = (axisx.min - x1) / (x2 - x1) * (y2 - y1) + y1;\n"
                        "x2 = axisx.min\n"
                    "}\n"
                    "if (x1 >= x2 && x1 > axisx.max) {\n"
                        "if (x2 > axisx.max) continue;\n"
                        "y1 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n"
                        "x1 = axisx.max\n"
                    "} else if (x2 >= x1 && x2 > axisx.max) {\n"
                        "if (x1 > axisx.max) continue;\n"
                        "y2 = (axisx.max - x1) / (x2 - x1) * (y2 - y1) + y1;\n"
                        "x2 = axisx.max\n"
                    "}\n"
                    "if (!areaOpen) {\n"
                        "ctx.beginPath();\n"
                        "ctx.moveTo(axisx.p2c(x1), axisy.p2c(bottom));\n"
                        "areaOpen = true\n"
                    "}\n"
                    "if (y1 >= axisy.max && y2 >= axisy.max) {\n"
                        "ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.max));\n"
                        "ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.max));\n"
                        "continue\n"
                    "} else if (y1 <= axisy.min && y2 <= axisy.min) {\n"
                        "ctx.lineTo(axisx.p2c(x1), axisy.p2c(axisy.min));\n"
                        "ctx.lineTo(axisx.p2c(x2), axisy.p2c(axisy.min));\n"
                        "continue\n"
                    "}\n"
                    "var x1old = x1,\n"
                    "x2old = x2;\n"
                    "if (y1 <= y2 && y1 < axisy.min && y2 >= axisy.min) {\n"
                        "x1 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n"
                        "y1 = axisy.min\n"
                    "} else if (y2 <= y1 && y2 < axisy.min && y1 >= axisy.min) {\n"
                        "x2 = (axisy.min - y1) / (y2 - y1) * (x2 - x1) + x1;\n"
                        "y2 = axisy.min\n"
                    "}\n"
                    "if (y1 >= y2 && y1 > axisy.max && y2 <= axisy.max) {\n"
                        "x1 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n"
                        "y1 = axisy.max\n"
                    "} else if (y2 >= y1 && y2 > axisy.max && y1 <= axisy.max) {\n"
                        "x2 = (axisy.max - y1) / (y2 - y1) * (x2 - x1) + x1;\n"
                        "y2 = axisy.max\n"
                    "}\n"
                    "if (x1 != x1old) {\n"
                        "ctx.lineTo(axisx.p2c(x1old), axisy.p2c(y1))\n"
                    "}\n"
                    "ctx.lineTo(axisx.p2c(x1), axisy.p2c(y1));\n"
                    "ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n"
                    "if (x2 != x2old) {\n"
                        "ctx.lineTo(axisx.p2c(x2), axisy.p2c(y2));\n"
                        "ctx.lineTo(axisx.p2c(x2old), axisy.p2c(y2))\n"
                    "}\n"
                "}\n"
            "}\n"
            "ctx.save();\n"
            "ctx.translate(plotOffset.left, plotOffset.top);\n"
            "ctx.lineJoin = \"round\";\n"
            "var lw = series.lines.lineWidth,\n"
            "sw = series.shadowSize;\n"
            "if (lw > 0 && sw > 0) {\n"
                "ctx.lineWidth = sw;\n"
                "ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n"
                "var angle = Math.PI / 18;\n"
                "plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 2), Math.cos(angle) * (lw / 2 + sw / 2), series.xaxis, series.yaxis);\n"
                "ctx.lineWidth = sw / 2;\n"
                "plotLine(series.datapoints, Math.sin(angle) * (lw / 2 + sw / 4), Math.cos(angle) * (lw / 2 + sw / 4), series.xaxis, series.yaxis)\n"
            "}\n"
            "ctx.lineWidth = lw;\n"
            "ctx.strokeStyle = series.color;\n"
            "var fillStyle = getFillStyle(series.lines, series.color, 0, plotHeight);\n"
            "if (fillStyle) {\n"
                "ctx.fillStyle = fillStyle;\n"
                "plotLineArea(series.datapoints, series.xaxis, series.yaxis)\n"
            "}\n"
            "if (lw > 0) plotLine(series.datapoints, 0, 0, series.xaxis, series.yaxis);\n"
            "ctx.restore()\n"
        "}\n"
        "function drawSeriesPoints(series) {\n"
            "function plotPoints(datapoints, radius, fillStyle, offset, shadow, axisx, axisy, symbol) {\n"
                "var points = datapoints.points,\n"
                "ps = datapoints.pointsize;\n"
                "for (var i = 0; i < points.length; i += ps) {\n"
                    "var x = points[i],\n"
                    "y = points[i + 1];\n"
                    "if (x == null || x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) continue;\n"
                    "ctx.beginPath();\n"
                    "x = axisx.p2c(x);\n"
                    "y = axisy.p2c(y) + offset;\n"
                    "if (symbol == \"circle\") ctx.arc(x, y, radius, 0, shadow ? Math.PI: Math.PI * 2, false);\n"
                    "else symbol(ctx, x, y, radius, shadow);\n"
                    "ctx.closePath();\n"
                    "if (fillStyle) {\n"
                        "ctx.fillStyle = fillStyle;\n"
                        "ctx.fill()\n"
                    "}\n"
                    "ctx.stroke()\n"
                "}\n"
            "}\n"
            "ctx.save();\n"
            "ctx.translate(plotOffset.left, plotOffset.top);\n"
            "var lw = series.points.lineWidth,\n"
            "sw = series.shadowSize,\n"
            "radius = series.points.radius,\n"
            "symbol = series.points.symbol;\n"
            "if (lw == 0) lw = 1e-4;\n"
            "if (lw > 0 && sw > 0) {\n"
                "var w = sw / 2;\n"
                "ctx.lineWidth = w;\n"
                "ctx.strokeStyle = \"rgba(0,0,0,0.1)\";\n"
                "plotPoints(series.datapoints, radius, null, w + w / 2, true, series.xaxis, series.yaxis, symbol);\n"
                "ctx.strokeStyle = \"rgba(0,0,0,0.2)\";\n"
                "plotPoints(series.datapoints, radius, null, w / 2, true, series.xaxis, series.yaxis, symbol)\n"
            "}\n"
            "ctx.lineWidth = lw;\n"
            "ctx.strokeStyle = series.color;\n"
            "plotPoints(series.datapoints, radius, getFillStyle(series.points, series.color), 0, false, series.xaxis, series.yaxis, symbol);\n"
            "ctx.restore()\n"
        "}\n"
        "function drawBar(x, y, b, barLeft, barRight, fillStyleCallback, axisx, axisy, c, horizontal, lineWidth) {\n"
            "var left, right, bottom, top, drawLeft, drawRight, drawTop, drawBottom, tmp;\n"
            "if (horizontal) {\n"
                "drawBottom = drawRight = drawTop = true;\n"
                "drawLeft = false;\n"
                "left = b;\n"
                "right = x;\n"
                "top = y + barLeft;\n"
                "bottom = y + barRight;\n"
                "if (right < left) {\n"
                    "tmp = right;\n"
                    "right = left;\n"
                    "left = tmp;\n"
                    "drawLeft = true;\n"
                    "drawRight = false\n"
                "}\n"
            "} else {\n"
                "drawLeft = drawRight = drawTop = true;\n"
                "drawBottom = false;\n"
                "left = x + barLeft;\n"
                "right = x + barRight;\n"
                "bottom = b;\n"
                "top = y;\n"
                "if (top < bottom) {\n"
                    "tmp = top;\n"
                    "top = bottom;\n"
                    "bottom = tmp;\n"
                    "drawBottom = true;\n"
                    "drawTop = false\n"
                "}\n"
            "}\n"
            "if (right < axisx.min || left > axisx.max || top < axisy.min || bottom > axisy.max) return;\n"
            "if (left < axisx.min) {\n"
                "left = axisx.min;\n"
                "drawLeft = false\n"
            "}\n"
            "if (right > axisx.max) {\n"
                "right = axisx.max;\n"
                "drawRight = false\n"
            "}\n"
            "if (bottom < axisy.min) {\n"
                "bottom = axisy.min;\n"
                "drawBottom = false\n"
            "}\n"
            "if (top > axisy.max) {\n"
                "top = axisy.max;\n"
                "drawTop = false\n"
            "}\n"
            "left = axisx.p2c(left);\n"
            "bottom = axisy.p2c(bottom);\n"
            "right = axisx.p2c(right);\n"
            "top = axisy.p2c(top);\n"
            "if (fillStyleCallback) {\n"
                "c.fillStyle = fillStyleCallback(bottom, top);\n"
                "c.fillRect(left, top, right - left, bottom - top)\n"
            "}\n"
            "if (lineWidth > 0 && (drawLeft || drawRight || drawTop || drawBottom)) {\n"
                "c.beginPath();\n"
                "c.moveTo(left, bottom);\n"
                "if (drawLeft) c.lineTo(left, top);\n"
                "else c.moveTo(left, top);\n"
                "if (drawTop) c.lineTo(right, top);\n"
                "else c.moveTo(right, top);\n"
                "if (drawRight) c.lineTo(right, bottom);\n"
                "else c.moveTo(right, bottom);\n"
                "if (drawBottom) c.lineTo(left, bottom);\n"
                "else c.moveTo(left, bottom);\n"
                "c.stroke()\n"
            "}\n"
        "}\n"
        "function drawSeriesBars(series) {\n"
            "function plotBars(datapoints, barLeft, barRight, fillStyleCallback, axisx, axisy) {\n"
                "var points = datapoints.points,\n"
                "ps = datapoints.pointsize;\n"
                "for (var i = 0; i < points.length; i += ps) {\n"
                    "if (points[i] == null) continue;\n"
                    "drawBar(points[i], points[i + 1], points[i + 2], barLeft, barRight, fillStyleCallback, axisx, axisy, ctx, series.bars.horizontal, series.bars.lineWidth)\n"
                "}\n"
            "}\n"
            "ctx.save();\n"
            "ctx.translate(plotOffset.left, plotOffset.top);\n"
            "ctx.lineWidth = series.bars.lineWidth;\n"
            "ctx.strokeStyle = series.color;\n"
            "var barLeft;\n"
            "switch (series.bars.align) {\n"
            "case \"left\":\n"
                "barLeft = 0;\n"
                "break;\n"
            "case \"right\":\n"
                "barLeft = -series.bars.barWidth;\n"
                "break;\n"
            "default:\n"
                "barLeft = -series.bars.barWidth / 2\n"
            "}\n"
            "var fillStyleCallback = series.bars.fill ?\n"
            "function(bottom, top) {\n"
                "return getFillStyle(series.bars, series.color, bottom, top)\n"
            "}: null;\n"
            "plotBars(series.datapoints, barLeft, barLeft + series.bars.barWidth, fillStyleCallback, series.xaxis, series.yaxis);\n"
            "ctx.restore()\n"
        "}\n"
        "function getFillStyle(filloptions, seriesColor, bottom, top) {\n"
            "var fill = filloptions.fill;\n"
            "if (!fill) return null;\n"
            "if (filloptions.fillColor) return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);\n"
            "var c = $.color.parse(seriesColor);\n"
            "c.a = typeof fill == \"number\" ? fill: .4;\n"
            "c.normalize();\n"
            "return c.toString()\n"
        "}\n"
        "function insertLegend() {\n"
            "if (options.legend.container != null) {\n"
                "$(options.legend.container).html(\"\")\n"
            "} else {\n"
                "placeholder.find(\".legend\").remove()\n"
            "}\n"
            "if (!options.legend.show) {\n"
                "return\n"
            "}\n"
            "var fragments = [],\n"
            "entries = [],\n"
            "rowStarted = false,\n"
            "lf = options.legend.labelFormatter,\n"
            "s,\n"
            "label;\n"
            "for (var i = 0; i < series.length; ++i) {\n"
                "s = series[i];\n"
                "if (s.label) {\n"
                    "label = lf ? lf(s.label, s) : s.label;\n"
                    "if (label) {\n"
                        "entries.push({\n"
                            "label: label,\n"
                            "color: s.color\n"
                        "})\n"
                    "}\n"
                "}\n"
            "}\n"
            "if (options.legend.sorted) {\n"
                "if ($.isFunction(options.legend.sorted)) {\n"
                    "entries.sort(options.legend.sorted)\n"
                "} else if (options.legend.sorted == \"reverse\") {\n"
                    "entries.reverse()\n"
                "} else {\n"
                    "var ascending = options.legend.sorted != \"descending\";\n"
                    "entries.sort(function(a, b) {\n"
                        "return a.label == b.label ? 0 : a.label < b.label != ascending ? 1 : -1\n"
                    "})\n"
                "}\n"
            "}\n"
            "for (var i = 0; i < entries.length; ++i) {\n"
                "var entry = entries[i];\n"
                "if (i % options.legend.noColumns == 0) {\n"
                    "if (rowStarted) fragments.push(\"</tr>\");\n"
                    "fragments.push(\"<tr>\");\n"
                    "rowStarted = true\n"
                "}\n"
                "fragments.push('<td class=\"legendColorBox\"><div style=\"border:1px solid ' + options.legend.labelBoxBorderColor + ';padding:1px\"><div style=\"width:4px;height:0;border:5px solid ' + entry.color + ';overflow:hidden\"></div></div></td>' + '<td class=\"legendLabel\">' + entry.label + \"</td>\")\n"
            "}\n"
            "if (rowStarted) fragments.push(\"</tr>\");\n"
            "if (fragments.length == 0) return;\n"
            "var table = '<table style=\"font-size:smaller;color:' + options.grid.color + '\">' + fragments.join(\"\") + \"</table>\";\n"
            "if (options.legend.container != null) $(options.legend.container).html(table);\n"
            "else {\n"
                "var pos = \"\",\n"
                "p = options.legend.position,\n"
                "m = options.legend.margin;\n"
                "if (m[0] == null) m = [m, m];\n"
                "if (p.charAt(0) == \"n\") pos += \"top:\" + (m[1] + plotOffset.top) + \"px;\";\n"
                "else if (p.charAt(0) == \"s\") pos += \"bottom:\" + (m[1] + plotOffset.bottom) + \"px;\";\n"
                "if (p.charAt(1) == \"e\") pos += \"right:\" + (m[0] + plotOffset.right) + \"px;\";\n"
                "else if (p.charAt(1) == \"w\") pos += \"left:\" + (m[0] + plotOffset.left) + \"px;\";\n"
                "var legend = $('<div class=\"legend\">' + table.replace('style=\"', 'style=\"position:absolute;' + pos + \";\") + \"</div>\").appendTo(placeholder);\n"
                "if (options.legend.backgroundOpacity != 0) {\n"
                    "var c = options.legend.backgroundColor;\n"
                    "if (c == null) {\n"
                        "c = options.grid.backgroundColor;\n"
                        "if (c && typeof c == \"string\") c = $.color.parse(c);\n"
                        "else c = $.color.extract(legend, \"background-color\");\n"
                        "c.a = 1;\n"
                        "c = c.toString()\n"
                    "}\n"
                    "var div = legend.children();\n"
                    "$('<div style=\"position:absolute;width:' + div.width() + \"px;height:\" + div.height() + \"px;\" + pos + \"background-color:\" + c + ';\"></div>').prependTo(legend).css(\"opacity\", options.legend.backgroundOpacity)\n"
                "}\n"
            "}\n"
        "}\n"
        "var highlights = [],\n"
        "redrawTimeout = null;\n"
        "function findNearbyItem(mouseX, mouseY, seriesFilter) {\n"
            "var maxDistance = options.grid.mouseActiveRadius,\n"
            "smallestDistance = maxDistance * maxDistance + 1,\n"
            "item = null,\n"
            "foundPoint = false,\n"
            "i, j, ps;\n"
            "for (i = series.length - 1; i >= 0; --i) {\n"
                "if (!seriesFilter(series[i])) continue;\n"
                "var s = series[i],\n"
                "axisx = s.xaxis,\n"
                "axisy = s.yaxis,\n"
                "points = s.datapoints.points,\n"
                "mx = axisx.c2p(mouseX),\n"
                "my = axisy.c2p(mouseY),\n"
                "maxx = maxDistance / axisx.scale,\n"
                "maxy = maxDistance / axisy.scale;\n"
                "ps = s.datapoints.pointsize;\n"
                "if (axisx.options.inverseTransform) maxx = Number.MAX_VALUE;\n"
                "if (axisy.options.inverseTransform) maxy = Number.MAX_VALUE;\n"
                "if (s.lines.show || s.points.show) {\n"
                    "for (j = 0; j < points.length; j += ps) {\n"
                        "var x = points[j],\n"
                        "y = points[j + 1];\n"
                        "if (x == null) continue;\n"
                        "if (x - mx > maxx || x - mx < -maxx || y - my > maxy || y - my < -maxy) continue;\n"
                        "var dx = Math.abs(axisx.p2c(x) - mouseX),\n"
                        "dy = Math.abs(axisy.p2c(y) - mouseY),\n"
                        "dist = dx * dx + dy * dy;\n"
                        "if (dist < smallestDistance) {\n"
                            "smallestDistance = dist;\n"
                            "item = [i, j / ps]\n"
                        "}\n"
                    "}\n"
                "}\n"
                "if (s.bars.show && !item) {\n"
                    "var barLeft, barRight;\n"
                    "switch (s.bars.align) {\n"
                    "case \"left\":\n"
                        "barLeft = 0;\n"
                        "break;\n"
                    "case \"right\":\n"
                        "barLeft = -s.bars.barWidth;\n"
                        "break;\n"
                    "default:\n"
                        "barLeft = -s.bars.barWidth / 2\n"
                    "}\n"
                    "barRight = barLeft + s.bars.barWidth;\n"
                    "for (j = 0; j < points.length; j += ps) {\n"
                        "var x = points[j],\n"
                        "y = points[j + 1],\n"
                        "b = points[j + 2];\n"
                        "if (x == null) continue;\n"
                        "if (series[i].bars.horizontal ? mx <= Math.max(b, x) && mx >= Math.min(b, x) && my >= y + barLeft && my <= y + barRight: mx >= x + barLeft && mx <= x + barRight && my >= Math.min(b, y) && my <= Math.max(b, y)) item = [i, j / ps]\n"
                    "}\n"
                "}\n"
            "}\n"
            "if (item) {\n"
                "i = item[0];\n"
                "j = item[1];\n"
                "ps = series[i].datapoints.pointsize;\n"
                "return {\n"
                    "datapoint: series[i].datapoints.points.slice(j * ps, (j + 1) * ps),\n"
                    "dataIndex: j,\n"
                    "series: series[i],\n"
                    "seriesIndex: i\n"
                "}\n"
            "}\n"
            "return null\n"
        "}\n"
        "function onMouseMove(e) {\n"
            "if (options.grid.hoverable) triggerClickHoverEvent(\"plothover\", e,\n"
            "function(s) {\n"
                "return s[\"hoverable\"] != false\n"
            "})\n"
        "}\n"
        "function onMouseLeave(e) {\n"
            "if (options.grid.hoverable) triggerClickHoverEvent(\"plothover\", e,\n"
            "function(s) {\n"
                "return false\n"
            "})\n"
        "}\n"
        "function onClick(e) {\n"
            "triggerClickHoverEvent(\"plotclick\", e,\n"
            "function(s) {\n"
                "return s[\"clickable\"] != false\n"
            "})\n"
        "}\n"
        "function triggerClickHoverEvent(eventname, event, seriesFilter) {\n"
            "var offset = eventHolder.offset(),\n"
            "canvasX = event.pageX - offset.left - plotOffset.left,\n"
            "canvasY = event.pageY - offset.top - plotOffset.top,\n"
            "pos = canvasToAxisCoords({\n"
                "left: canvasX,\n"
                "top: canvasY\n"
            "});\n"
            "pos.pageX = event.pageX;\n"
            "pos.pageY = event.pageY;\n"
            "var item = findNearbyItem(canvasX, canvasY, seriesFilter);\n"
            "if (item) {\n"
                "item.pageX = parseInt(item.series.xaxis.p2c(item.datapoint[0]) + offset.left + plotOffset.left, 10);\n"
                "item.pageY = parseInt(item.series.yaxis.p2c(item.datapoint[1]) + offset.top + plotOffset.top, 10)\n"
            "}\n"
            "if (options.grid.autoHighlight) {\n"
                "for (var i = 0; i < highlights.length; ++i) {\n"
                    "var h = highlights[i];\n"
                    "if (h.auto == eventname && !(item && h.series == item.series && h.point[0] == item.datapoint[0] && h.point[1] == item.datapoint[1])) unhighlight(h.series, h.point)\n"
                "}\n"
                "if (item) highlight(item.series, item.datapoint, eventname)\n"
            "}\n"
            "placeholder.trigger(eventname, [pos, item])\n"
        "}\n"
        "function triggerRedrawOverlay() {\n"
            "var t = options.interaction.redrawOverlayInterval;\n"
            "if (t == -1) {\n"
                "drawOverlay();\n"
                "return\n"
            "}\n"
            "if (!redrawTimeout) redrawTimeout = setTimeout(drawOverlay, t)\n"
        "}\n"
        "function drawOverlay() {\n"
            "redrawTimeout = null;\n"
            "octx.save();\n"
            "overlay.clear();\n"
            "octx.translate(plotOffset.left, plotOffset.top);\n"
            "var i, hi;\n"
            "for (i = 0; i < highlights.length; ++i) {\n"
                "hi = highlights[i];\n"
                "if (hi.series.bars.show) drawBarHighlight(hi.series, hi.point);\n"
                "else drawPointHighlight(hi.series, hi.point)\n"
            "}\n"
            "octx.restore();\n"
            "executeHooks(hooks.drawOverlay, [octx])\n"
        "}\n"
        "function highlight(s, point, auto) {\n"
            "if (typeof s == \"number\") s = series[s];\n"
            "if (typeof point == \"number\") {\n"
                "var ps = s.datapoints.pointsize;\n"
                "point = s.datapoints.points.slice(ps * point, ps * (point + 1))\n"
            "}\n"
            "var i = indexOfHighlight(s, point);\n"
            "if (i == -1) {\n"
                "highlights.push({\n"
                    "series: s,\n"
                    "point: point,\n"
                    "auto: auto\n"
                "});\n"
                "triggerRedrawOverlay()\n"
            "} else if (!auto) highlights[i].auto = false\n"
        "}\n"
        "function unhighlight(s, point) {\n"
            "if (s == null && point == null) {\n"
                "highlights = [];\n"
                "triggerRedrawOverlay();\n"
                "return\n"
            "}\n"
            "if (typeof s == \"number\") s = series[s];\n"
            "if (typeof point == \"number\") {\n"
                "var ps = s.datapoints.pointsize;\n"
                "point = s.datapoints.points.slice(ps * point, ps * (point + 1))\n"
            "}\n"
            "var i = indexOfHighlight(s, point);\n"
            "if (i != -1) {\n"
                "highlights.splice(i, 1);\n"
                "triggerRedrawOverlay()\n"
            "}\n"
        "}\n"
        "function indexOfHighlight(s, p) {\n"
            "for (var i = 0; i < highlights.length; ++i) {\n"
                "var h = highlights[i];\n"
                "if (h.series == s && h.point[0] == p[0] && h.point[1] == p[1]) return i\n"
            "}\n"
            "return - 1\n"
        "}\n"
        "function drawPointHighlight(series, point) {\n"
            "var x = point[0],\n"
            "y = point[1],\n"
            "axisx = series.xaxis,\n"
            "axisy = series.yaxis,\n"
            "highlightColor = typeof series.highlightColor === \"string\" ? series.highlightColor: $.color.parse(series.color).scale(\"a\", .5).toString();\n"
            "if (x < axisx.min || x > axisx.max || y < axisy.min || y > axisy.max) return;\n"
            "var pointRadius = series.points.radius + series.points.lineWidth / 2;\n"
            "octx.lineWidth = pointRadius;\n"
            "octx.strokeStyle = highlightColor;\n"
            "var radius = 1.5 * pointRadius;\n"
            "x = axisx.p2c(x);\n"
            "y = axisy.p2c(y);\n"
            "octx.beginPath();\n"
            "if (series.points.symbol == \"circle\") octx.arc(x, y, radius, 0, 2 * Math.PI, false);\n"
            "else series.points.symbol(octx, x, y, radius, false);\n"
            "octx.closePath();\n"
            "octx.stroke()\n"
        "}\n"
        "function drawBarHighlight(series, point) {\n"
            "var highlightColor = typeof series.highlightColor === \"string\" ? series.highlightColor: $.color.parse(series.color).scale(\"a\", .5).toString(),\n"
            "fillStyle = highlightColor,\n"
            "barLeft;\n"
            "switch (series.bars.align) {\n"
            "case \"left\":\n"
                "barLeft = 0;\n"
                "break;\n"
            "case \"right\":\n"
                "barLeft = -series.bars.barWidth;\n"
                "break;\n"
            "default:\n"
                "barLeft = -series.bars.barWidth / 2\n"
            "}\n"
            "octx.lineWidth = series.bars.lineWidth;\n"
            "octx.strokeStyle = highlightColor;\n"
            "drawBar(point[0], point[1], point[2] || 0, barLeft, barLeft + series.bars.barWidth,\n"
            "function() {\n"
                "return fillStyle\n"
            "},\n"
            "series.xaxis, series.yaxis, octx, series.bars.horizontal, series.bars.lineWidth)\n"
        "}\n"
        "function getColorOrGradient(spec, bottom, top, defaultColor) {\n"
            "if (typeof spec == \"string\") return spec;\n"
            "else {\n"
                "var gradient = ctx.createLinearGradient(0, top, 0, bottom);\n"
                "for (var i = 0,\n"
                "l = spec.colors.length; i < l; ++i) {\n"
                    "var c = spec.colors[i];\n"
                    "if (typeof c != \"string\") {\n"
                        "var co = $.color.parse(defaultColor);\n"
                        "if (c.brightness != null) co = co.scale(\"rgb\", c.brightness);\n"
                        "if (c.opacity != null) co.a *= c.opacity;\n"
                        "c = co.toString()\n"
                    "}\n"
                    "gradient.addColorStop(i / (l - 1), c)\n"
                "}\n"
                "return gradient\n"
            "}\n"
        "}\n"
    "}\n"
    "$.plot = function(placeholder, data, options) {\n"
        "var plot = new Plot($(placeholder), data, options, $.plot.plugins);\n"
        "return plot\n"
    "};\n"
    "$.plot.version = \"0.8.3\";\n"
    "$.plot.plugins = [];\n"
    "$.fn.plot = function(data, options) {\n"
        "return this.each(function() {\n"
            "$.plot(this, data, options)\n"
        "})\n"
    "};\n"
    "function floorInBase(n, base) {\n"
        "return base * Math.floor(n / base)\n"
    "}\n"
"})(jQuery);\n"
};
#else
static const char j_003[]={0};
#endif
#endif
